package cats

import cats.arrow.Arrow
import cats.instances.list._
import simulacrum.typeclass

/**
 * Applicative functor.
 *
 * Allows application of a function in an Applicative context to a value in an Applicative context
 *
 * See: [[https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf The Essence of the Iterator Pattern]]
 * Also: [[http://staff.city.ac.uk/~ross/papers/Applicative.pdf Applicative programming with effects]]
 *
 * Must obey the laws defined in cats.laws.ApplicativeLaws.
 */
@typeclass trait Applicative[F[_]] extends Apply[F] with InvariantMonoidal[F] { self =>



  /**
   * `pure` lifts any value into the Applicative Functor.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> Applicative[Option].pure(10)
   * res0: Option[Int] = Some(10)
   * }}}
   */
  def pure[A](x: A): F[A]

  /**
   * Returns an `F[Unit]` value, equivalent with `pure(())`.
   *
   * A useful shorthand, also allowing implementations to optimize the
   * returned reference (e.g. it can be a `val`).
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> Applicative[Option].unit
   * res0: Option[Unit] = Some(())
   * }}}
   */
  def unit: F[Unit] = pure(())

  override def map[A, B](fa: F[A])(f: A => B): F[B] =
    ap(pure(f))(fa)

  /**
   * Given `fa` and `n`, apply `fa` `n` times to construct an `F[List[A]]` value.
   *
   * Example:
   * {{{
   * scala> import cats.data.State
   *
   * scala> type Counter[A] = State[Int, A]
   * scala> val getAndIncrement: Counter[Int] = State { i => (i + 1, i) }
   * scala> val getAndIncrement5: Counter[List[Int]] =
   *      | Applicative[Counter].replicateA(5, getAndIncrement)
   * scala> getAndIncrement5.run(0).value
   * res0: (Int, List[Int]) = (5,List(0, 1, 2, 3, 4))
   * }}}
   */
  def replicateA[A](n: Int, fa: F[A]): F[List[A]] =
    Traverse[List].sequence(List.fill(n)(fa))(this)

  /**
   * Compose an `Applicative[F]` and an `Applicative[G]` into an
   * `Applicative[λ[α => F[G[α]]]]`.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val alo = Applicative[List].compose[Option]
   *
   * scala> alo.pure(3)
   * res0: List[Option[Int]] = List(Some(3))
   *
   * scala> alo.product(List(None, Some(true), Some(false)), List(Some(2), None))
   * res1: List[Option[(Boolean, Int)]] = List(None, None, Some((true,2)), None, Some((false,2)), None)
   * }}}
   */
  def compose[G[_]: Applicative]: Applicative[λ[α => F[G[α]]]] =
    new ComposedApplicative[F, G] {
      val F = self
      val G = Applicative[G]
    }

  /**
   * Compose an `Applicative[F]` and a `ContravariantMonoidal[G]` into a
   * `ContravariantMonoidal[λ[α => F[G[α]]]]`.
   *
   * Example:
   * {{{
   * scala> import cats.kernel.Comparison
   * scala> import cats.implicits._
   *
   * // compares strings by alphabetical order
   * scala> val alpha: Order[String] = Order[String]
   *
   * // compares strings by their length
   * scala> val strLength: Order[String] = Order.by[String, Int](_.length)
   *
   * scala> val stringOrders: List[Order[String]] = List(alpha, strLength)
   *
   * // first comparison is with alpha order, second is with string length
   * scala> stringOrders.map(o => o.comparison("abc", "de"))
   * res0: List[Comparison] = List(LessThan, GreaterThan)
   *
   * scala> val le = Applicative[List].composeContravariantMonoidal[Order]
   *
   * // create Int orders that convert ints to strings and then use the string orders
   * scala> val intOrders: List[Order[Int]] = le.contramap(stringOrders)(_.toString)
   *
   * // first comparison is with alpha order, second is with string length
   * scala> intOrders.map(o => o.comparison(12, 3))
   * res1: List[Comparison] = List(LessThan, GreaterThan)
   *
   * // create the `product` of the string order list and the int order list
   * // `p` contains a list of the following orders:
   * // 1. (alpha comparison on strings followed by alpha comparison on ints)
   * // 2. (alpha comparison on strings followed by length comparison on ints)
   * // 3. (length comparison on strings followed by alpha comparison on ints)
   * // 4. (length comparison on strings followed by length comparison on ints)
   * scala> val p: List[Order[(String, Int)]] = le.product(stringOrders, intOrders)
   *
   * scala> p.map(o => o.comparison(("abc", 12), ("def", 3)))
   * res2: List[Comparison] = List(LessThan, LessThan, LessThan, GreaterThan)
   * }}}
   */
  def composeContravariantMonoidal[G[_]: ContravariantMonoidal]: ContravariantMonoidal[λ[α => F[G[α]]]] =
    new ComposedApplicativeContravariantMonoidal[F, G] {
      val F = self
      val G = ContravariantMonoidal[G]
    }

  /**
   * Returns the given argument (mapped to Unit) if `cond` is `false`,
   * otherwise, unit lifted into F.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> Applicative[List].unlessA(true)(List(1, 2, 3))
   * res0: List[Unit] = List(())
   *
   * scala> Applicative[List].unlessA(false)(List(1, 2, 3))
   * res1: List[Unit] = List((), (), ())
   *
   * scala> Applicative[List].unlessA(true)(List.empty[Int])
   * res2: List[Unit] = List(())
   *
   * scala> Applicative[List].unlessA(false)(List.empty[Int])
   * res3: List[Unit] = List()
   * }}}
   */
  def unlessA[A](cond: Boolean)(f: => F[A]): F[Unit] =
    if (cond) pure(()) else void(f)

  /**
   * Returns the given argument (mapped to Unit) if `cond` is `true`, otherwise,
   * unit lifted into F.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> Applicative[List].whenA(true)(List(1, 2, 3))
   * res0: List[Unit] = List((), (), ())
   *
   * scala> Applicative[List].whenA(false)(List(1, 2, 3))
   * res1: List[Unit] = List(())
   *
   * scala> Applicative[List].whenA(true)(List.empty[Int])
   * res2: List[Unit] = List()
   *
   * scala> Applicative[List].whenA(false)(List.empty[Int])
   * res3: List[Unit] = List(())
   * }}}
   */
  def whenA[A](cond: Boolean)(f: => F[A]): F[Unit] =
    if (cond) void(f) else pure(())

}

object Applicative {
  def monoid[F[_], A](implicit f: Applicative[F], monoid: Monoid[A]): Monoid[F[A]] =
    new ApplicativeMonoid[F, A](f, monoid)

  /**
   * Creates an applicative functor for `F`, holding domain fixed and combining
   * over the codomain.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.Applicative.catsApplicativeForArrow
   * scala> val toLong: Int => Long = _.toLong
   * scala> val double: Int => Int = 2*_
   * scala> val f: Int => (Long, Int) = catsApplicativeForArrow.product(toLong, double)
   * scala> f(3)
   * res0: (Long, Int) = (3,6)
   * }}}
   */
  implicit def catsApplicativeForArrow[F[_, _], A](implicit F: Arrow[F]): Applicative[F[A, ?]] =
    new ArrowApplicative[F, A](F)


  /**
   * Creates a CoflatMap for an Applicative `F`.
   * Cannot be implicit in 1.0 for Binary Compatibility Reasons
   *
   * Example:
   * {{{
   * scala> import cats._
   * scala> import cats.implicits._
   * scala> val fa = Some(3)
   * fa: Option[Int] = Some(3)
   * scala> Applicative.coflatMap[Option].coflatten(fa)
   * res0: Option[Option[Int]] = Some(Some(3))
   * }}}
   */
  def coflatMap[F[_]](implicit F: Applicative[F]): CoflatMap[F] =
    new CoflatMap[F] {
      def coflatMap[A, B](fa: F[A])(f: F[A] => B): F[B] = F.pure(f(fa))
      def map[A, B](fa: F[A])(f: A => B): F[B] = F.map(fa)(f)
    }

}

private[cats] class ApplicativeMonoid[F[_], A](f: Applicative[F], monoid: Monoid[A]) extends ApplySemigroup(f, monoid) with Monoid[F[A]] {
  def empty: F[A] = f.pure(monoid.empty)
}

private[cats] class ArrowApplicative[F[_, _], A](F: Arrow[F]) extends Applicative[F[A, ?]] {
  def pure[B](b: B): F[A, B] = F.lift[A, B](_ => b)
  override def map[B, C](fb: F[A, B])(f: B => C): F[A, C] = F.rmap(fb)(f)
  def ap[B, C](ff: F[A, B => C])(fb: F[A, B]): F[A, C] =
    F.rmap(F.andThen(F.lift((x: A) => (x, x)), F.split(ff, fb)))(tup => tup._1(tup._2))
  override def product[B, C](fb: F[A, B], fc: F[A, C]): F[A, (B, C)] =
    F.andThen(F.lift((x: A) => (x, x)), F.split(fb, fc))
}
package cats
package arrow

import cats.functor.Strong

trait Arrow[F[_, _]] extends Split[F] with Strong[F] with Category[F] { self =>

  /**
    * Lift a function into the context of an Arrow
    */
  def lift[A, B](f: A => B): F[A, B]

  /**
    * Create a new arrow from an existing arrow that applies `f` to the input
    * of the original arrow and then applies `g` to the output.
    *
    * Example:
    * {{{
    * scala> import cats.std.function._
    * scala> import cats.arrow.Arrow
    * scala> val fab: Double => Double = x => x + 0.3
    * scala> val f: Int => Double = x => x.toDouble / 2
    * scala> val g: Double => Double = x => x * 3
    * scala> val dimapArrow = Arrow[Function1].dimap(fab)(f)(g)
    * scala> dimapArrow(3)
    * res0: Double = 5.4
    * }}}
    */
  def dimap[A, B, C, D](fab: F[A, B])(f: C => A)(g: B => D): F[C, D] =
    compose(lift(g), andThen(lift(f), fab))

  /**
    * Create a new arrow that takes two inputs, but only modifies the first input
    *
    * Example:
    * {{{
    * scala> import cats.std.function._
    * scala> import cats.arrow.Arrow
    * scala> val f: Int => Int = _ * 2
    * scala> val fab = Arrow[Function1].first[Int,Int,Int](f)
    * scala> fab((2,3))
    * res0: (Int, Int) = (4,3)
    * }}}
    */
  def first[A, B, C](fa: F[A, B]): F[(A, C), (B, C)]

  /**
    * Create a new arrow that takes two inputs, but only modifies the second input
    *
    * Example:
    * {{{
    * scala> import cats.std.function._
    * scala> import cats.arrow.Arrow
    * scala> val f: Int => Int = _ * 2
    * scala> val fab = Arrow[Function1].second[Int,Int,Int](f)
    * scala> fab((2,3))
    * res0: (Int, Int) = (2,6)
    * }}}
    */
  def second[A, B, C](fa: F[A, B]): F[(C, A), (C, B)] = {
    def swap[X, Y]: F[(X, Y), (Y, X)] = lift[(X, Y), (Y, X)] {
      case (x, y) => (y, x)
    }
    compose(swap, compose(first[A, B, C](fa), swap))
  }

  /**
    * Create a new arrow that splits its input between the `f` and `g` arrows
    * and combines the output of each.
    *
    * Example:
    * {{{
    * scala> import cats.std.function._
    * scala> import cats.arrow.Arrow
    * scala> val toLong: Int => Long = _.toLong
    * scala> val toDouble: Float => Double = _.toDouble
    * scala> val f: ((Int, Float)) => (Long, Double) = Arrow[Function1].split(toLong, toDouble)
    * scala> f((3, 4.0f))
    * res0: (Long, Double) = (3,4.0)
    * }}}
    */
  def split[A, B, C, D](f: F[A, B], g: F[C, D]): F[(A, C), (B, D)] =
    andThen(first(f), second(g))
}

object Arrow {
  def apply[F[_, _]](implicit ev: Arrow[F]): Arrow[F] = ev
}
import sbt._
import sbt.Keys._
import com.typesafe.sbt.pgp.PgpKeys
import org.portablescala.sbtplatformdeps.PlatformDepsPlugin.autoImport._
import org.scalajs.sbtplugin.ScalaJSPlugin.autoImport.{crossProject => _, CrossType => _, _}
import sbtcrossproject.CrossPlugin.autoImport._
import sbtrelease.ReleasePlugin.autoImport._
import scalajscrossproject.ScalaJSCrossPlugin.autoImport._
import Lib._

object UnivEqBuild {

  private val ghProject = "univeq"

  private val publicationSettings =
    Lib.publicationSettings(ghProject)

  object Ver {
    final val Cats            = "2.0.0"
    final val MTest           = "0.6.9"
    final val Scala212        = "2.12.10"
    final val Scala213        = "2.13.1"
    final val Scalaz          = "7.2.28"
    final val ScalaCollCompat = "2.1.3"
    final val ScalaJsDom      = "0.9.8"
  }

  def scalacFlags = Seq(
    "-deprecation",
    "-unchecked",
    "-feature",
    "-language:postfixOps",
    "-language:implicitConversions",
    "-language:higherKinds",
    "-language:existentials",
    "-opt:l:inline",
    "-opt-inline-from:scala.**",
    "-opt-inline-from:japgolly.univeq.**",
    "-Ywarn-dead-code",
    "-Ywarn-value-discard")

  val commonSettings = ConfigureBoth(
    _.settings(
      organization                  := "com.github.japgolly.univeq",
      homepage                      := Some(url("https://github.com/japgolly/" + ghProject)),
      licenses                      += ("Apache-2.0", url("http://opensource.org/licenses/Apache-2.0")),
      startYear                     := Some(2015),
      scalaVersion                  := Ver.Scala213,
      crossScalaVersions            := Seq(Ver.Scala212, Ver.Scala213),
      scalacOptions                ++= scalacFlags,
      scalacOptions in Test        --= Seq("-Ywarn-dead-code"),
      shellPrompt in ThisBuild      := ((s: State) => Project.extract(s).currentRef.project + "> "),
      incOptions                    := incOptions.value,
      updateOptions                 := updateOptions.value.withCachedResolution(true),
      releasePublishArtifactsAction := PgpKeys.publishSigned.value,
      releaseTagComment             := s"v${(version in ThisBuild).value}",
      releaseVcsSign                := true))

  def definesMacros: Project => Project =
    _.settings(
      scalacOptions += "-language:experimental.macros",
      libraryDependencies ++= Seq(
        // "org.scala-lang" % "scala-reflect" % scalaVersion.value,
        // "org.scala-lang" % "scala-library" % scalaVersion.value,
        "org.scala-lang" % "scala-compiler" % scalaVersion.value % "provided"))

  def utestSettings = ConfigureBoth(
    _.settings(
      libraryDependencies += "com.lihaoyi" %%% "utest" % Ver.MTest % "test",
      testFrameworks      += new TestFramework("utest.runner.Framework")))
    .jsConfigure(
      // Not mandatory; just faster.
      _.settings(jsEnv in Test := PhantomJSEnv().value))

  lazy val root =
    Project("root", file("."))
      .configure(commonSettings.jvm, preventPublication)
      .aggregate(rootJVM, rootJS)

  lazy val rootJVM =
    Project("JVM", file(".rootJVM"))
      .configure(commonSettings.jvm, preventPublication)
      .aggregate(univEqJVM, scalazJVM, catsJVM)

  lazy val rootJS =
    Project("JS", file(".rootJS"))
      .configure(commonSettings.jvm, preventPublication)
      .aggregate(univEqJS , scalazJS , catsJS)

  lazy val univEqJVM = univEq.jvm
  lazy val univEqJS  = univEq.js
  lazy val univEq = crossProject(JSPlatform, JVMPlatform)
    .in(file("univeq"))
    .configureCross(commonSettings, publicationSettings, utestSettings)
    .bothConfigure(definesMacros)
    .settings(
      moduleName := "univeq",
      libraryDependencies += "org.scala-lang.modules" %%% "scala-collection-compat" % Ver.ScalaCollCompat)
    .jsSettings(libraryDependencies += "org.scala-js" %%% "scalajs-dom" % Ver.ScalaJsDom)

  lazy val scalazJVM = scalaz.jvm
  lazy val scalazJS  = scalaz.js
  lazy val scalaz = crossProject(JSPlatform, JVMPlatform)
    .in(file("univeq-scalaz"))
    .configureCross(commonSettings, publicationSettings)
    .dependsOn(univEq)
    .configureCross(utestSettings)
    .settings(
      moduleName          := "univeq-scalaz",
      libraryDependencies += "org.scalaz" %%% "scalaz-core" % Ver.Scalaz)

  lazy val catsJVM = cats.jvm
  lazy val catsJS  = cats.js
  lazy val cats = crossProject(JSPlatform, JVMPlatform)
    .in(file("univeq-cats"))
    .configureCross(commonSettings, publicationSettings)
    .dependsOn(univEq)
    .configureCross(utestSettings)
    .settings(
      moduleName          := "univeq-cats",
      libraryDependencies += "org.typelevel" %%% "cats-core" % Ver.Cats)
}
import java.text.SimpleDateFormat
import java.time.{Instant, LocalDateTime}
import java.time.format.DateTimeFormatter
import java.util.Date

import cats.Monad
import cats.effect._
import cats.effect.implicits._
import util.log

import scala.concurrent.{Await, Awaitable, Future}
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
import model._
import cats.implicits._
import cats._

/**
  * Created by ikhoon on 19/08/2017.
  */


object util {
  val formatter = new SimpleDateFormat("HH:mm:ss")
  def log(str: => String): Unit =
    println(s"${formatter.format(new Date())} - $str")

}
object model {
  case class Item(id: Int, catalogId: Int, brandId: Int)
  type Catalog = String
  type Brand = String
  type Wish = String
  type Category = String
  type Detail = String
  type Certification = String
}

sealed trait AsyncApiComponent[AsyncIO[+_]] {

  import model._

  def itemRepository: ItemRepository
  def catalogRepository: CatalogRepository
  def brandRepository: BrandRepository
  def itemWishCountRepository: ItemWishCountRepository
  def categoryRepository: CategoryRepository
  def itemDetailRepository: ItemDetailRepository
  def itemCertificationRepository: ItemCertificationRepository


  trait ItemRepository {
    def findById(id: Int): AsyncIO[Item]
  }

  trait CatalogRepository {
    def findById(id: Int): AsyncIO[Catalog]
  }

  trait BrandRepository {
    def findById(id: Int): AsyncIO[Brand]
  }

  trait ItemWishCountRepository {
    def findByItemId(id: Int): AsyncIO[Wish]
  }

  trait CategoryRepository {
    def findOneByBrandId(id: Int): AsyncIO[Category]
  }

  trait ItemDetailRepository {
    def findByItemId(id: Int): AsyncIO[Detail]
  }

  trait ItemCertificationRepository {
    def findByItemId(id: Int): AsyncIO[Certification]
  }
}

object ScalaFutureApiComponent extends AsyncApiComponent[Future] {

  def itemRepository: ItemRepository = itemRepositoryScalaFuture
  def catalogRepository: CatalogRepository = catalogRepositoryScalaFuture
  def brandRepository: BrandRepository = brandRepositoryScalaFuture
  def itemWishCountRepository: ItemWishCountRepository = itemWishCountRepositoryScalaFuture
  def categoryRepository: CategoryRepository = categoryRepositoryScalaFuture
  def itemDetailRepository: ItemDetailRepository = itemDetailRepositoryScalaFuture
  def itemCertificationRepository: ItemCertificationRepository = itemCertificationRepositoryScalaFuture

  object itemRepositoryScalaFuture extends ItemRepository {
    def findById(id: Int): Future[Item] = Future {
      Thread.sleep(1000)
      log(s"item-$id")
      Item(id, 1000, 100000)
    }
  }

  object catalogRepositoryScalaFuture extends CatalogRepository {
    def findById(id: Int): Future[Catalog] = Future {
      Thread.sleep(1000)
      log(s"catalog-$id")
      s"catalog-$id"
    }
  }

  object brandRepositoryScalaFuture extends BrandRepository {
    def findById(id: Int): Future[Brand] = Future {
      Thread.sleep(1000)
      log(s"brand-$id")
      s"brand-$id"
    }
  }

  object itemWishCountRepositoryScalaFuture extends ItemWishCountRepository {
    def findByItemId(id: Int): Future[Wish] = Future {
      Thread.sleep(1000)
      log(s"wish-$id")
      s"wish-$id"
    }
  }

  object categoryRepositoryScalaFuture extends CategoryRepository {
    def findOneByBrandId(id: Int): Future[Category] = Future {
      Thread.sleep(1000)
      log(s"category-$id")
      s"category-$id"
    }
  }

  object itemDetailRepositoryScalaFuture extends ItemDetailRepository {
    def findByItemId(id: Int): Future[Detail] = Future {
      Thread.sleep(1000)
      log(s"detail-$id")
      s"detail-$id"
    }
  }

  object itemCertificationRepositoryScalaFuture extends ItemCertificationRepository {
    def findByItemId(id: Int): Future[Certification] = Future {
      Thread.sleep(1000)
      log(s"certification-$id")
      s"certification-$id"
    }
  }


}


object CatsEffectApiComponent extends AsyncApiComponent[IO] {
//  type AsyncIO[+A] = cats.effect.IO[A]

  def itemRepository: ItemRepository = itemRepositoryCatsEffect
  def catalogRepository: CatalogRepository = catalogRepositoryCatsEffect
  def brandRepository: BrandRepository = brandRepositoryCatsEffect
  def itemWishCountRepository: ItemWishCountRepository = itemWishCountRepositoryCatsEffect
  def categoryRepository: CategoryRepository = categoryRepositoryCatsEffect
  def itemDetailRepository: ItemDetailRepository = itemDetailRepositoryCatsEffect
  def itemCertificationRepository: ItemCertificationRepository = itemCertificationRepositoryCatsEffect

  object itemRepositoryCatsEffect extends ItemRepository {
    def findById(id: Int): IO[Item] = IO.async[Item] { cb =>
      Thread.sleep(1000)
      log(s"item-$id")
      cb(Right(Item(id, 1000, 100000)))
    }
  }

  object catalogRepositoryCatsEffect extends CatalogRepository {
    def findById(id: Int): IO[Catalog] = IO.async[Catalog] { cb =>
      Thread.sleep(1000)
      log(s"catalog-$id")
      cb(Right(s"catalog-$id"))
    }
  }

  object brandRepositoryCatsEffect extends BrandRepository {
    def findById(id: Int): IO[Brand] = IO.async[Brand] { cb =>
      Thread.sleep(1000)
      log(s"brand-$id")
      cb(Right(s"brand-$id"))
    }
  }

  object itemWishCountRepositoryCatsEffect extends ItemWishCountRepository {
    def findByItemId(id: Int): IO[Wish] = IO.async[Wish] { cb =>
      Thread.sleep(1000)
      log(s"wish-$id")
      cb(Right(s"wish-$id"))
    }
  }

  object categoryRepositoryCatsEffect extends CategoryRepository {
    def findOneByBrandId(id: Int): IO[Category] = IO.async[Category] { cb =>
      Thread.sleep(1000)
      log(s"category-$id")
      cb(Right(s"category-$id"))
    }
  }

  object itemDetailRepositoryCatsEffect extends ItemDetailRepository {
    def findByItemId(id: Int): IO[Detail] = IO.async[Detail] { cb =>
      Thread.sleep(1000)
      log(s"detail-$id")
      cb(Right(s"detail-$id"))
    }
  }

  object itemCertificationRepositoryCatsEffect extends ItemCertificationRepository {
    def findByItemId(id: Int): IO[Certification] = IO.async[Certification] { cb =>
      Thread.sleep(1000)
      log(s"certification-$id")
      cb(Right(s"certification-$id"))
    }
  }

}


object experiment {

  def main(args: Array[String]): Unit = {
    val scalaFutureResult = awaitTime { getProduct(ScalaFutureApiComponent, 10) }
    println(scalaFutureResult)

    val catsEffectResult = awaitTime { getProduct(CatsEffectApiComponent, 10).unsafeToFuture() }
    println(catsEffectResult)
  }

  def awaitTime[R](block: => Awaitable[R]): R = {
    val start = System.nanoTime()
    val result = Await.result(block, 1 minutes)
    val elapsed = System.nanoTime() - start
    println("elapsed : " + elapsed / (1000 * 1000 * 1000.0) + " sec")
    result
  }
  def getProduct[F[+_]: Monad](api: AsyncApiComponent[F], itemId: Int): F[List[String]] = {
    import api._
    val itemFuture = itemRepository.findById(itemId)
    itemFuture.flatMap{ item =>
      val catalogFuture = catalogRepository.findById(item.catalogId)
      val brandFuture =  brandRepository.findById(item.brandId)
      val wishFuture = itemWishCountRepository.findByItemId(item.id)
      val categoryFuture = categoryRepository.findOneByBrandId(item.brandId)
      val itemDetailFuture = itemDetailRepository.findByItemId(item.id)
      val itemCertificationFuture = itemCertificationRepository.findByItemId(item.id)
      for {
        catalog <- catalogFuture
        brand <- brandFuture
        wishCount <- wishFuture
        category <- categoryFuture
        detail <- itemDetailFuture
        certifications <- itemCertificationFuture
      } yield
        List(brand, catalog, wishCount, category, detail, certifications)
    }
  }

}

package org.functor

import cats.Functor
import cats.instances.list._
import cats.instances.option._
import cats.Functor.ops._

import scala.concurrent.ExecutionContext.Implicits._
import scala.concurrent.duration._
import scala.concurrent.{Await, Future}
//import scala.language.{higherKinds, postfixOps}

object CatsFunctor extends App {

  // Scala functors out of the box
  println(List(1, 2, 3) map { _ * 2 })
  println(Option(42) map { "'" + _ + "'" })
  println(Await.result(Future("Hello world") map { _.toUpperCase }, 1 second))

  val func1: Int => String = value => value.toString
  val func2: String => Double = value => value.toDouble
  println((func2 compose func1)(42))

  // Cats functors out of the box
  val list = 1 :: 2 :: 3 :: Nil
  println(Functor[List].map(list)(_ * 2))

  val option = Option(42)
  println(Functor[Option].map(option)(_.toString))

  val func = (x: Int) => x + 1
  val lifted = Functor[Option].lift(func)
  println(lifted(Option(42)))

}
package hrscala.validation

import Models.{Row, ScalaDeveloper}
import scala.util.Try
import cats.Apply
import cats.data.ValidatedNel
import cats.data.Validated.{invalidNel, valid}


object CatsValidation
    extends App
    with CommonCatsValidations
    with BusinessCatsValidations {

  def constructScalaDeveloper(row: Row): ValidatedNel[String, ScalaDeveloper] = {
    Apply[ValidatedNel[String, ?]].map3(
      nonEmptyString(row.cells(0)),
      positiveNumber(row.cells(1)) andThen noMinor,
      commaSeparatedStrings(row.cells(2)) andThen mustHaveScala
    )(ScalaDeveloper(_, _, _))
  }

  Models.people foreach { row =>
    println(constructScalaDeveloper(row))
  }
}

trait CommonCatsValidations {
  def nonEmptyString(input: String): ValidatedNel[String, String] =
    if (input != null && input.nonEmpty) valid(input) else invalidNel("Input string is empty")

  def number(input: String): ValidatedNel[String, Int] =
    nonEmptyString(input) andThen { nes =>
      Try(valid(input.toInt)).getOrElse(invalidNel(s"Invalid number format for input: $input"))
    }

  def positiveNumber(input: String): ValidatedNel[String, Int] =
    number(input) andThen { num =>
      if(num > 0L) valid(num) else invalidNel("The input value is not positive")
    }

  def commaSeparatedStrings(input: String): ValidatedNel[String, Seq[String]] =
    nonEmptyString(input) andThen  { nes =>
      valid(nes.split(", *").toSeq)
    }
}

trait BusinessCatsValidations {
  def noMinor(age: Int): ValidatedNel[String, Int] =
    if (age < 18) invalidNel("Person is a minor") else valid(age)

  def mustHaveScala(languages: Seq[String]): ValidatedNel[String, Seq[String]] =
    languages.find(_ == "scala") match {
      case _: Some[String] => valid(languages)
      case _ => invalidNel("Languages did not contain Scala")
    }
}
package com.zaphod.UnderScore

object Chapter09_MapReduce extends App {
  object Exercise {
    import cats.Monoid
    import cats.syntax.monoid._

    def foldMap[A, B: Monoid](as: Vector[A])(f: A => B): B = {
//      as.map(f).foldLeft(Monoid[B].empty)(_ |+| _)
      as.foldLeft(Monoid[B].empty)(_ |+| f(_))
    }

    import cats.instances.int._
    import cats.instances.string._

    val v1 = Vector(1, 2, 3)
    val b1 = foldMap(v1)(identity)
    val b2 = foldMap(v1)(_.toString + "!")
    val b3 = foldMap("Hello World!".toVector)(_.toString.toUpperCase)

    println(s"b1: $b1")
    println(s"b2: $b2")
    println(s"b3: $b3")

    import scala.concurrent.Future
    import scala.concurrent.ExecutionContext.Implicits.global

    def parFoldMap[A, B: Monoid](as: Vector[A])(f: A => B): Future[B] = {
      val numCores  = Runtime.getRuntime.availableProcessors()
      val groupSize = (1.0 * as.size / numCores).ceil.toInt

      val batches   = as.grouped(groupSize)

      val futures   = batches map { batch =>
        Future {
          foldMap(batch)(f)
        }
      }

      Future.sequence(futures) map { b =>
        b.foldLeft(Monoid[B].empty)(_ |+| _)
      }
    }

    val v2 = (1 to 1000000).toVector

    val f1 = parFoldMap(v2)(identity)
  }

  object FoldMapWithCats {
    import cats.Monoid
    import cats.Traverse

    import cats.instances.int._
    import cats.instances.future._
    import cats.instances.vector._

    import cats.syntax.foldable._
    import cats.syntax.traverse._

    import scala.concurrent.Future
    import scala.concurrent.ExecutionContext.Implicits.global

    def parFoldMap[A, B: Monoid](as: Vector[A])(f: A => B): Future[B] = {
      val numCores  = Runtime.getRuntime.availableProcessors()
      val groupSize = (1.0 * as.size / numCores).ceil.toInt

      as.grouped(groupSize)
        .toVector
        .traverse(batch => Future(batch.foldMap(f)))
        .map(_.combineAll)
    }

    val v2 = (1 to 1000000).toVector

    val f1 = parFoldMap(v2)(identity)
  }

  Exercise

  import scala.concurrent.Await
  import scala.concurrent.duration._

  val b4 = Await.result(Exercise.f1, 1.second)
  val b5 = Await.result(FoldMapWithCats.f1, 1.second)

  println(s"b4: $b4")
  println(s"b5: $b5")
}
package io.circe.cats.arrow

import io.circe.cats.SemigroupK
import io.circe.cats.kernel.Semigroup

/**
 * Must obey the laws defined in cats.laws.ComposeLaws.
 *
 * Here's how you can use `>>>` and `<<<`
 * Example:
 * {{{
 * scala> import cats.implicits._
 * scala> val f : Int => Int = (_ + 1)
 * scala> val g : Int => Int = (_ * 100)
 * scala> (f >>> g)(3)
 * res0: Int = 400
 * scala> (f <<< g)(3)
 * res1: Int = 301
 * }}}
 */
trait Compose[F[_, _]] { self =>
  def compose[A, B, C](f: F[B, C], g: F[A, B]): F[A, C]

  def andThen[A, B, C](f: F[A, B], g: F[B, C]): F[A, C] =
    compose(g, f)

  def algebraK: SemigroupK[[x] =>> F[x, x]] =
    new SemigroupK[[x] =>> F[x, x]] {
      def combineK[A](f1: F[A, A], f2: F[A, A]): F[A, A] = self.compose(f1, f2)
    }

  def algebra[A]: Semigroup[F[A, A]] =
    new Semigroup[F[A, A]] {
      def combine(f1: F[A, A], f2: F[A, A]): F[A, A] = self.compose(f1, f2)
    }
}

object Compose {  
  def apply[F[_, _]] given (F: Compose[F]): Compose[F] = F

  given as ArrowChoice[Function1] = io.circe.cats.instances.Function1Instance

  given as Compose[Map] {
    /**
     * Compose two maps `g` and `f` by using the values in `f` as keys for `g`.
     * {{{
     * scala> import cats.arrow.Compose
     * scala> import cats.implicits._
     * scala> val first = Map(1 -> "a", 2 -> "b", 3 -> "c", 4 -> "a")
     * scala> val second = Map("a" -> true, "b" -> false, "d" -> true)
     * scala> Compose[Map].compose(second, first)
     * res0: Map[Int, Boolean] = Map(1 -> true, 2 -> false, 4 -> true)
     * }}}
     */
    def compose[A, B, C](f: Map[B, C], g: Map[A, B]): Map[A, C] =
      g.foldLeft(Map.empty[A, C]) {
        case (acc, (key, value)) =>
          f.get(value) match {
            case Some(other) => acc + (key -> other)
            case _           => acc
          }
      }
  }

  private[cats] trait Ops {
    given ComposeOps[F[_, _], A, B] {
      def (f: F[A, B]) <<< [C] (g: F[C, A]) given (F: Compose[F]): F[C, B] = F.compose(f, g)
      def (f: F[A, B]) >>> [C] (g: F[B, C]) given (F: Compose[F]): F[A, C] = F.andThen(f, g)
      def (f: F[A, B]) compose[C](g: F[C, A]) given (F: Compose[F]): F[C, B] = F.compose(f, g)
      def (f: F[A, B]) andThen[C](g: F[B, C]) given (F: Compose[F]): F[A, C] = F.andThen(f, g)
    }
  }
}package harmony.tocats.data

import cats.Eval
import harmony.{NaturalTransformation, BiNaturalTransformation}
import scalaz.Name

trait CoproductConverter {
  implicit def scalazToCatsCoproductNaturalTransformation[F[_], G[_], F0[_], G0[_]](implicit F: NaturalTransformation[F, F0], G: NaturalTransformation[G, G0]): NaturalTransformation[scalaz.Coproduct[F, G, ?], cats.data.Coproduct[F0, G0, ?]] =
    new NaturalTransformation[scalaz.Coproduct[F, G, ?], cats.data.Coproduct[F0, G0, ?]] {
      override def apply[A](fa: scalaz.Coproduct[F, G, A]): cats.data.Coproduct[F0, G0, A] =
        cats.data.Coproduct[F0, G0, A](fa.run.bimap(F.apply, G.apply).toEither)
    }

  implicit def scalazToCatsCoproduct[F[_], G[_], F0[_], G0[_], A](inner: scalaz.Coproduct[F, G, A])(implicit F: NaturalTransformation[F, F0], G: NaturalTransformation[G, G0]): cats.data.Coproduct[F0, G0, A] =
    scalazToCatsCoproductNaturalTransformation[F, G, F0, G0].apply[A](inner)

}

object CoproductConverter extends CoproductConverter

trait CoyonedaConverter {

  implicit def scalazToCatsCoyonedaNaturalTransformation[F[_], F0[_]](implicit inner: NaturalTransformation[F, F0]): NaturalTransformation[scalaz.Coyoneda[F, ?], cats.free.Coyoneda[F0, ?]] =
    new NaturalTransformation[scalaz.Coyoneda[F, ?], cats.free.Coyoneda[F0, ?]] {
      override def apply[A](fa: scalaz.Coyoneda[F, A]): cats.free.Coyoneda[F0, A] =
        cats.free.Coyoneda[F0, fa.I, A](inner.apply(fa.fi))(fa.k)
    }

  implicit def scalazToCatsCoyonedaValue[F[_], F0[_], A](c: scalaz.Coyoneda[F, A])(implicit F: scalaz.Functor[F], inner: NaturalTransformation[F, F0]): cats.free.Coyoneda[F0, A] =
    scalazToCatsCoyonedaNaturalTransformation[F, F0].apply[A](c)

}

object CoyonedaConverter extends CoyonedaConverter

trait DisjunctionConverter {
  implicit val scalazDisjunctionToScalaEitherNaturalTransformation: BiNaturalTransformation[scalaz.Disjunction, scala.Either] =
    new BiNaturalTransformation[scalaz.Disjunction, scala.Either] {
      override def apply[A, B](f: scalaz.Disjunction[A, B]): Either[A, B] =
        f.toEither
    }

  implicit def dLeftToScalaLeft[A, B](s: scalaz.DLeft[A]): scala.Left[A, B] =
    scala.Left(s.a)

  implicit def dRightToScalaRight[A, B](s: scalaz.DRight[B]): scala.Right[A, B] =
    scala.Right(s.b)

  implicit def disjunctionToScalaEither[A, B](s: scalaz.Disjunction[A, B]): scala.Either[A, B] =
    scalazDisjunctionToScalaEitherNaturalTransformation.apply[A, B](s)
}

object DisjunctionConverter extends DisjunctionConverter

trait EitherTConverter {
  import harmony.toscalaz.typeclass.FunctorConverter._

  implicit def scalazToCatsEitherTBiNaturalTransformation[F[_], F0[_]](implicit trans: NaturalTransformation[F, F0], F: cats.Functor[F]): BiNaturalTransformation[scalaz.EitherT[F, ?, ?], cats.data.EitherT[F0, ?, ?]] =
    new BiNaturalTransformation[scalaz.EitherT[F, ?, ?], cats.data.EitherT[F0, ?, ?]] {
      override def apply[A, B](f: scalaz.EitherT[F, A, B]): cats.data.EitherT[F0, A, B] =
        cats.data.EitherT[F0, A, B](trans.apply(f.toEither))
    }

  implicit def scalazToCatsEitherTValue[F[_], F0[_], A, B](inner: scalaz.EitherT[F, A, B])(implicit trans: NaturalTransformation[F, F0], F: cats.Functor[F]): cats.data.EitherT[F0, A, B] =
    scalazToCatsEitherTBiNaturalTransformation.apply(inner)

}

object EitherTConverter extends EitherTConverter

trait IdTConverter {
  implicit def scalazToCatsIdTNaturalTransformation[F[_], F0[_]](implicit trans: NaturalTransformation[F, F0]): NaturalTransformation[scalaz.IdT[F, ?], cats.data.IdT[F0, ?]] =
    new NaturalTransformation[scalaz.IdT[F, ?], cats.data.IdT[F0, ?]] {
      override def apply[A](fa: scalaz.IdT[F, A]): cats.data.IdT[F0, A] =
        cats.data.IdT(trans.apply(fa.run))
    }

  implicit def scalazToCatsIdT[F[_], F0[_], A](inner: scalaz.IdT[F, A])(implicit trans: NaturalTransformation[F, F0]): cats.data.IdT[F0, A] =
    scalazToCatsIdTNaturalTransformation[F, F0].apply[A](inner)
}

object IdTConverter extends IdTConverter

trait KleisliConverter {
  implicit def scalazToCatsKleisliBiNaturalTransformation[F[_], F0[_]](implicit trans: NaturalTransformation[F, F0]): BiNaturalTransformation[scalaz.Kleisli[F, ?, ?], cats.data.Kleisli[F0, ?, ?]] =
    new BiNaturalTransformation[scalaz.Kleisli[F, ?, ?], cats.data.Kleisli[F0, ?, ?]] {
      override def apply[A, B](f: scalaz.Kleisli[F, A, B]): cats.data.Kleisli[F0, A, B] =
        cats.data.Kleisli(a => trans.apply(f.run(a)))
    }

  implicit def scalazToCatsKleisli[F[_], F0[_], A, B](inner: scalaz.Kleisli[F, A, B])(implicit trans: NaturalTransformation[F, F0]): cats.data.Kleisli[F0, A, B] =
    scalazToCatsKleisliBiNaturalTransformation[F, F0].apply[A, B](inner)
}

object KleisliConverter extends KleisliConverter

trait MaybeConverter {
  implicit val scalazMaybeToScalaOptionNaturalTransoformation: NaturalTransformation[scalaz.Maybe, scala.Option] =
    new NaturalTransformation[scalaz.Maybe, scala.Option] {
      override def apply[A](fa: scalaz.Maybe[A]): Option[A] =
        fa.toOption
    }

  implicit def scalazMaybeEmptyToCats[A](inner: scalaz.Maybe.Empty[A]): scala.None.type =
    scala.None

  implicit def scalazMaybeJustToCats[A](inner: scalaz.Maybe.Just[A]): scala.Some[A] =
    scala.Some(inner.a)

  implicit def scalazMaybeToCats[A](inner: scalaz.Maybe[A]): scala.Option[A] =
    scalazMaybeToScalaOptionNaturalTransoformation.apply[A](inner)
}

object MaybeConverter extends MaybeConverter

trait MaybeTConverter {
  import MaybeConverter._

  implicit def scalazMaybeTToCatsOptionTNaturalTransformation[F[_], F0[_]](implicit trans: NaturalTransformation[F, F0], F: cats.Functor[F]): NaturalTransformation[scalaz.MaybeT[F, ?], cats.data.OptionT[F0, ?]] =
    new NaturalTransformation[scalaz.MaybeT[F, ?], cats.data.OptionT[F0, ?]] {
      override def apply[A](fa: scalaz.MaybeT[F, A]): cats.data.OptionT[F0, A] =
        cats.data.OptionT[F0, A](trans.apply(F.map(fa.run)(scalazMaybeToCats)))
    }

  implicit def scalazMaybeTToCatsOptionT[F[_], F0[_], A](inner: scalaz.MaybeT[F, A])(implicit trans: NaturalTransformation[F, F0], F: cats.Functor[F]): cats.data.OptionT[F0, A] =
    scalazMaybeTToCatsOptionTNaturalTransformation[F, F0].apply[A](inner)
}

object MaybeTConverter extends MaybeTConverter

trait NameConverter {
  implicit val scalazToCatsEvalNaturalTransformation: NaturalTransformation[scalaz.Name, cats.Eval] =
    new NaturalTransformation[scalaz.Name, cats.Eval] {
      override def apply[A](fa: Name[A]): Eval[A] =
        fa match {
          case v: scalaz.Value[A] =>
            scalazToCatsNow(v)
          case need: scalaz.Need[A] =>
            scalazToCatsLater(need)
          case name: scalaz.Name[A] =>
            scalazToCatsAlways(name)
        }
    }

  implicit def scalazToCatsNow[A](inner: scalaz.Value[A]): cats.Now[A] =
    cats.Now(inner.value)

  implicit def scalazToCatsLater[A](inner: scalaz.Need[A]): cats.Later[A] =
    cats.Later(inner.value)

  implicit def scalazToCatsAlways[A](inner: scalaz.Name[A]): cats.Always[A] =
    cats.Always(inner.value)

  implicit def scalazToCatsEval[A](inner: scalaz.Name[A]): cats.Eval[A] =
    scalazToCatsEvalNaturalTransformation.apply(inner)
}

object NameConverter extends NameConverter

trait NonEmptyListConverter {
  implicit lazy val scalazToCatsNonEmptyListNaturalTransformation: NaturalTransformation[scalaz.NonEmptyList, cats.data.NonEmptyList] =
    new NaturalTransformation[scalaz.NonEmptyList, cats.data.NonEmptyList] {
      override def apply[A](fa: scalaz.NonEmptyList[A]): cats.data.NonEmptyList[A] =
        cats.data.NonEmptyList[A](fa.head, fa.tail.toList)
    }

  implicit def scalazToCatsNonEmptyList[A](inner: scalaz.NonEmptyList[A]): cats.data.NonEmptyList[A] =
    scalazToCatsNonEmptyListNaturalTransformation.apply(inner)
}

object NonEmptyListConverter extends NonEmptyListConverter

trait IListConverter {
  implicit val scalazIListToScalaListNaturalTransformation: NaturalTransformation[scalaz.IList, scala.List] =
    new NaturalTransformation[scalaz.IList, scala.List] {
      override def apply[A](fa: scalaz.IList[A]): scala.List[A] =
        fa.toList
    }

  implicit def scalazIListToScalaList[A](inner: scalaz.IList[A]): scala.List[A] =
    scalazIListToScalaListNaturalTransformation.apply(inner)
}

object IListConverter extends IListConverter

trait OneAndConverter {
  implicit def scalazToCatsOneAndNaturalTransformation[F[_], F0[_]](implicit inner: NaturalTransformation[F, F0]): NaturalTransformation[scalaz.OneAnd[F, ?], cats.data.OneAnd[F0, ?]] =
    new NaturalTransformation[scalaz.OneAnd[F, ?], cats.data.OneAnd[F0, ?]] {
      override def apply[A](fa: scalaz.OneAnd[F, A]): cats.data.OneAnd[F0, A] =
        cats.data.OneAnd(fa.head, inner.apply(fa.tail))
    }

  implicit def scalazToCatsOneAnd[F[_], F0[_], A](a: scalaz.OneAnd[F, A])(implicit inner: NaturalTransformation[F, F0]): cats.data.OneAnd[F0, A] =
    scalazToCatsOneAndNaturalTransformation[F, F0].apply(a)

  //Overrides for concrete type cats.data.NonEmptyVector. Remove these if cats.data.NonEmptyVector becomes an alias for cats.data.OneAnd[Vector, ?].
  implicit val scalazToCatsNonEmptyVectorNaturalTransformation: NaturalTransformation[scalaz.OneAnd[Vector, ?], cats.data.NonEmptyVector] =
    new NaturalTransformation[scalaz.OneAnd[Vector, ?], cats.data.NonEmptyVector] {
      override def apply[A](fa: scalaz.OneAnd[Vector, A]): cats.data.NonEmptyVector[A] =
        cats.data.NonEmptyVector(fa.head, fa.tail)
    }

  implicit def scalazToCatsNonEmptyVector[A](inner: scalaz.OneAnd[Vector, A]): cats.data.NonEmptyVector[A] =
    scalazToCatsNonEmptyVectorNaturalTransformation.apply[A](inner)
}

object OneAndConverter extends OneAndConverter

trait OptionTConverter {
  implicit def scalazOptionTToCatsOptionTNaturalTransformation[F[_], F0[_]](implicit trans: NaturalTransformation[F, F0]): NaturalTransformation[scalaz.OptionT[F, ?], cats.data.OptionT[F0, ?]] =
    new NaturalTransformation[scalaz.OptionT[F, ?], cats.data.OptionT[F0, ?]] {
      override def apply[A](fa: scalaz.OptionT[F, A]): cats.data.OptionT[F0, A] =
        cats.data.OptionT[F0, A](trans.apply(fa.run))
    }

  implicit def scalazOptionTToCatsOptionT[F[_], F0[_], A](inner: scalaz.OptionT[F, A])(implicit trans: NaturalTransformation[F, F0]): cats.data.OptionT[F0, A] =
    scalazOptionTToCatsOptionTNaturalTransformation[F, F0].apply[A](inner)
}

object OptionTConverter extends OptionTConverter

trait OrderingConverter {
  implicit def scalazToCatsOrderingEqualTo(inner: scalaz.Ordering.EQ.type): cats.kernel.Comparison.EqualTo.type =
    cats.kernel.Comparison.EqualTo

  implicit def scalazToCatsOrderingGreaterThan(inner: scalaz.Ordering.GT.type): cats.kernel.Comparison.GreaterThan.type =
    cats.kernel.Comparison.GreaterThan

  implicit def scalazToCatsOrderingLessThan(inner: scalaz.Ordering.LT.type): cats.kernel.Comparison.LessThan.type =
    cats.kernel.Comparison.LessThan

  implicit def scalazToCatsOrdering[F](inner: scalaz.Ordering): cats.kernel.Comparison =
    cats.kernel.Comparison.fromInt(inner.toInt)
}

object OrderingConverter extends OrderingConverter

trait StateTConverter {
  implicit def scalazToCatsStateTBiNaturalTransformation[F[_], F0[_]](implicit F: scalaz.Monad[F], A: cats.Applicative[F0], trans: NaturalTransformation[F, F0]): BiNaturalTransformation[scalaz.StateT[F, ?, ?], cats.data.StateT[F0, ?, ?]] =
    new BiNaturalTransformation[scalaz.StateT[F, ?, ?], cats.data.StateT[F0, ?, ?]] {
      override def apply[A, B](f: scalaz.StateT[F, A, B]): cats.data.StateT[F0, A, B] =
        cats.data.StateT[F0, A, B](a => trans.apply(f.run(a)))
    }


  implicit def scalazToCatsStateT[F[_], F0[_], L, V](inner: scalaz.StateT[F, L, V])(implicit F: scalaz.Monad[F], A: cats.Applicative[F0], trans: NaturalTransformation[F, F0]): cats.data.StateT[F0, L, V] =
    scalazToCatsStateTBiNaturalTransformation[F, F0].apply[L, V](inner)
}

object StateTConverter extends StateTConverter

trait ValidationConverter {
  implicit def scalazToCatsInvalid[E](inner: scalaz.Failure[E]): cats.data.Validated.Invalid[E] =
    cats.data.Validated.Invalid(inner.e)

  implicit def scalazToCatsValid[A](inner: scalaz.Success[A]): cats.data.Validated.Valid[A] =
    cats.data.Validated.Valid(inner.a)

  implicit def scalazToCatsValidated[E, A](inner: scalaz.Validation[E, A]): cats.data.Validated[E, A] =
    inner.fold(cats.data.Validated.invalid, cats.data.Validated.valid)
}

object ValidationConverter extends ValidationConverter

trait ValidationNelConverter {
  import ValidationConverter._
  import NonEmptyListConverter._

  implicit val scalazToCatsValidatedNelBiNaturalTransformation: BiNaturalTransformation[scalaz.ValidationNel[?, ?], cats.data.ValidatedNel[?, ?]] =
    new BiNaturalTransformation[scalaz.ValidationNel[?, ?], cats.data.ValidatedNel[?, ?]] {
      override def apply[A, B](f: scalaz.ValidationNel[A, B]): cats.data.ValidatedNel[A, B] =
        f.leftMap(scalazToCatsNonEmptyList)
    }

  implicit def scalazToCatsValidatedNel[E, A](inner: scalaz.ValidationNel[E, A]): cats.data.ValidatedNel[E, A] =
    scalazToCatsValidatedNelBiNaturalTransformation.apply[E, A](inner)
}

object ValidationNelConverter extends ValidationNelConverter

trait WriterTConverter {
  implicit def scalazToCatsWriterTBiNaturalTransformation[F[_], F0[_]](implicit trans: NaturalTransformation[F, F0]): BiNaturalTransformation[scalaz.WriterT[F, ?, ?], cats.data.WriterT[F0, ?, ?]] =
    new BiNaturalTransformation[scalaz.WriterT[F, ?, ?], cats.data.WriterT[F0, ?, ?]] {
      override def apply[A, B](f: scalaz.WriterT[F, A, B]): cats.data.WriterT[F0, A, B] =
        cats.data.WriterT[F0, A, B](trans.apply(f.run))
    }

  implicit def scalazToCatsWriterT[F[_], F0[_], L, V](inner: scalaz.WriterT[F, L, V])(implicit trans: NaturalTransformation[F, F0]): cats.data.WriterT[F0, L, V] =
    scalazToCatsWriterTBiNaturalTransformation.apply[L, V](inner)
}

object WriterTConverter extends WriterTConverter

trait YonedaConverter {
  implicit def scalazToCatsYonedaNaturalTransformation[F[_], F0[_]](implicit inner: NaturalTransformation[F, F0], F: cats.Functor[F0]): NaturalTransformation[scalaz.Yoneda[F, ?], cats.free.Yoneda[F0, ?]] =
    new NaturalTransformation[scalaz.Yoneda[F, ?], cats.free.Yoneda[F0, ?]] {
      override def apply[A](fa: scalaz.Yoneda[F, A]): cats.free.Yoneda[F0, A] =
        cats.free.Yoneda[F0, A](inner.apply(fa.run))
    }

  implicit def scalazToCatsYoneda[F[_], F0[_], A](inner: scalaz.Yoneda[F, A])(implicit T: NaturalTransformation[F, F0], F: cats.Functor[F0]): cats.free.Yoneda[F0, A] =
    scalazToCatsYonedaNaturalTransformation[F, F0].apply[A](inner)
}

object YonedaConverter extends YonedaConverter
package ch.epfl.scala.index.model
package release

import org.scalatest._

class DefaultReleaseTests extends FunSpec {

  def emptyRelease(maven: MavenReference,
                   reference: Release.Reference): Release =
    Release(
      maven,
      reference,
      resolver = None,
      name = None,
      description = None,
      released = None,
      licenses = Set(),
      isNonStandardLib = false,
      id = None,
      liveData = false,
      scalaDependencies = Seq(),
      javaDependencies = Seq(),
      reverseDependencies = Seq(),
      internalDependencies = Seq(),
      targetType = "JVM",
      fullScalaVersion = None,
      scalaVersion = None,
      scalaJsVersion = None,
      scalaNativeVersion = None,
      sbtVersion = None
    )

  def prepare(organization: String,
              repository: String,
              groupdId: String,
              releases: List[(String, String)]) = {
    releases
      .flatMap {
        case (artifactId, rawVersion) =>
          for {
            (artifact, target) <- Artifact(artifactId)
            version <- SemanticVersion(rawVersion)
          } yield (artifactId, rawVersion, artifact, target, version)
      }
      .map {
        case (artifactId, rawVersion, artifact, target, version) =>
          emptyRelease(
            MavenReference(groupdId, artifactId, rawVersion),
            Release.Reference(organization,
                              repository,
                              artifact,
                              version,
                              Some(target))
          )
      }
      .toSet
  }

  describe("Default Release") {
    it("latest version pre release scala") {

      val organization = "typelevel"
      val repository = "cats"
      val groupdId = "org.typelevel"
      val releases = prepare(
        organization,
        repository,
        groupdId,
        List(
          ("cats-core_2.11", "0.6.0"),
          ("cats-core_2.11", "0.6.0-M2"),
          ("cats-core_2.11", "0.6.0-M1"),
          ("cats-core_2.11", "0.5.0"),
          ("cats-core_2.11", "0.4.1"),
          ("cats-core_2.11", "0.4.0"),
          ("cats-core_2.10", "0.6.0"),
          ("cats-core_2.10", "0.6.0-M2"),
          ("cats-core_2.10", "0.6.0-M1"),
          ("cats-core_2.10", "0.5.0"),
          ("cats-core_2.10", "0.4.1"),
          ("cats-core_2.10", "0.4.0"),
          ("cats-core_sjs0.6_2.11", "0.6.0"),
          ("cats-core_sjs0.6_2.11", "0.6.0-M2"),
          ("cats-core_sjs0.6_2.11", "0.6.0-M1"),
          ("cats-core_sjs0.6_2.11", "0.5.0"),
          ("cats-core_sjs0.6_2.11", "0.4.1"),
          ("cats-core_sjs0.6_2.11", "0.4.0"),
          ("cats-core_sjs0.6_2.10", "0.6.0"),
          ("cats-core_sjs0.6_2.10", "0.6.0-M2"),
          ("cats-core_sjs0.6_2.10", "0.6.0-M1"),
          ("cats-core_sjs0.6_2.10", "0.5.0"),
          ("cats-core_sjs0.6_2.10", "0.4.1"),
          ("cats-core_sjs0.6_2.10", "0.4.0")
        )
      )

      val result =
        DefaultRelease(repository, ReleaseSelection.empty, releases, None, true)

      val versions: List[SemanticVersion] =
        List(
          SemanticVersion("0.6.0").get,
          SemanticVersion("0.6.0-M2").get,
          SemanticVersion("0.6.0-M1").get,
          SemanticVersion("0.5.0").get,
          SemanticVersion("0.4.1").get,
          SemanticVersion("0.4.0").get
        )

      val targets: List[ScalaTarget] =
        List(
          ScalaTarget.scalaJs(SemanticVersion("2.11").get,
                              SemanticVersion("0.6").get),
          ScalaTarget.scalaJs(SemanticVersion("2.10").get,
                              SemanticVersion("0.6").get),
          ScalaTarget.scala(SemanticVersion("2.11").get),
          ScalaTarget.scala(SemanticVersion("2.10").get)
        )

      val expected: Option[ReleaseOptions] =
        Some(
          ReleaseOptions(
            artifacts = List(
              "cats-core"
            ),
            versions = versions,
            targets = targets,
            release = emptyRelease(
              MavenReference(groupdId, "cats-core_2.11", "0.6.0"),
              Release.Reference(
                organization,
                repository,
                "cats-core",
                SemanticVersion("0.6.0").get,
                Some(ScalaTarget.scala(SemanticVersion("2.11").get))
              )
            )
          )
        )

      assert(expected == result)
    }

    it("selected artifact") {
      val organization = "akka"
      val repository = "akka"
      val groupdId = "com.typesafe.akka"
      val releases =
        prepare(organization,
                repository,
                groupdId,
                List(
                  ("akka-distributed-data-experimental_2.11", "2.4.8"),
                  ("akka-actors_2.11", "2.4.8")
                ))

      val result = DefaultRelease(
        repository,
        ReleaseSelection(
          artifact = Some("akka-distributed-data-experimental"),
          target = None,
          version = None,
          selected = None
        ),
        releases,
        None,
        true
      )

      val expected =
        Some(
          ReleaseOptions(
            artifacts = List(
              "akka-actors",
              "akka-distributed-data-experimental"
            ),
            versions = List(
              SemanticVersion("2.4.8").get
            ),
            targets = List(
              ScalaTarget.scala(SemanticVersion("2.11").get)
            ),
            release = emptyRelease(
              MavenReference(groupdId,
                             "akka-distributed-data-experimental_2.11",
                             "2.4.8"),
              Release.Reference(
                organization,
                repository,
                "akka-distributed-data-experimental",
                SemanticVersion("2.4.8").get,
                Some(ScalaTarget.scala(SemanticVersion("2.11").get))
              )
            )
          )
        )

      assert(result == expected)
    }

    it("scalafix ordering") {
      // 0.5.3 on 2.12 vs 0.3.4 on 2.12.2

      val organization = "scalacenter"
      val repository = "scalafix"
      val groupdId = "ch.epfl.scala"
      val releases = prepare(
        organization,
        repository,
        groupdId,
        List(
          ("scalafix-core_2.12.2", "0.3.4"),
          ("scalafix-core_2.12", "0.5.3")
        )
      )

      val result =
        DefaultRelease(repository, ReleaseSelection.empty, releases, None, true)

      val versions: List[SemanticVersion] =
        List(
          SemanticVersion("0.3.4").get,
          SemanticVersion("0.5.3").get
        )

      val targets: List[ScalaTarget] =
        List(
          ScalaTarget.scala(SemanticVersion("2.12.2").get),
          ScalaTarget.scala(SemanticVersion("2.12").get)
        )

      val expected: Option[ReleaseOptions] =
        Some(
          ReleaseOptions(
            artifacts = List(
              "scalafix-core"
            ),
            versions = versions,
            targets = targets,
            release = emptyRelease(
              MavenReference(groupdId, "scalafix-core_2.12", "0.5.3"),
              Release.Reference(
                organization,
                repository,
                "scalafix-core",
                SemanticVersion("0.5.3").get,
                Some(ScalaTarget.scala(SemanticVersion("2.12").get))
              )
            )
          )
        )

      assert(
        result.get.release.reference.version == SemanticVersion("0.5.3").get
      )
    }
  }
}
package tests

import scala.concurrent.Future
import scala.concurrent.duration.Duration
import scala.meta.internal.metals.Messages.Only212Navigation
import scala.meta.internal.metals.MetalsServerConfig
import scala.meta.internal.metals.StatisticsConfig

object DefinitionSlowSuite extends BaseSlowSuite("definition") {
  override def serverConfig: MetalsServerConfig =
    super.serverConfig.copy(statistics = new StatisticsConfig("diagnostics"))

  override def testAsync(
      name: String,
      maxDuration: Duration = Duration("3min")
  )(run: => Future[Unit]): Unit = {
    if (isAppveyor) {
      // src.zip is missing on Appveyor which breaks definition tests.
      ignore(name) {}
    } else {
      super.testAsync(name, maxDuration)(run)
    }
  }

  testAsync("definition") {
    for {
      _ <- server.initialize(
        """|
           |/metals.json
           |{
           |  "a": { },
           |  "b": {
           |    "libraryDependencies": [
           |      "org.scalatest::scalatest:3.0.5"
           |    ],
           |    "dependsOn": [ "a" ]
           |  }
           |}
           |/a/src/main/java/a/Message.java
           |package a;
           |public class Message {
           |  public static String message = "Hello world!";
           |}
           |/a/src/main/scala/a/Main.scala
           |package a
           |import java.util.concurrent.Future // unused
           |import scala.util.Failure // unused
           |object Main extends App {
           |  val message = Message.message
           |  new java.io.PrintStream(new java.io.ByteArrayOutputStream())
           |  println(message)
           |}
           |/b/src/main/scala/a/MainSuite.scala
           |package a
           |import java.util.concurrent.Future // unused
           |import scala.util.Failure // unused
           |import org.scalatest.FunSuite
           |object MainSuite extends FunSuite {
           |  test("a") {
           |    val condition = Main.message.contains("Hello")
           |    assert(condition)
           |  }
           |}
           |""".stripMargin
      )
      _ = assertNoDiff(server.workspaceDefinitions, "")
      _ <- server.didOpen("a/src/main/scala/a/Main.scala")
      _ <- server.didOpen("b/src/main/scala/a/MainSuite.scala")
      _ = assertNoDiff(client.workspaceDiagnostics, "")
      _ = assertNoDiff(
        server.workspaceDefinitions,
        """|/a/src/main/scala/a/Main.scala
           |package a
           |import java.util.concurrent.Future/*Future.java*/ // unused
           |import scala.util.Failure/*Try.scala*/ // unused
           |object Main/*L3*/ extends App/*App.scala*/ {
           |  val message/*L4*/ = Message/*Message.java:1*/.message/*Message.java:2*/
           |  new java.io.PrintStream/*PrintStream.java*/(new java.io.ByteArrayOutputStream/*ByteArrayOutputStream.java*/())
           |  println/*Predef.scala*/(message/*L4*/)
           |}
           |/b/src/main/scala/a/MainSuite.scala
           |package a
           |import java.util.concurrent.Future/*Future.java*/ // unused
           |import scala.util.Failure/*Try.scala*/ // unused
           |import org.scalatest.FunSuite/*FunSuite.scala*/
           |object MainSuite/*L4*/ extends FunSuite/*FunSuite.scala*/ {
           |  test/*FunSuiteLike.scala*/("a") {
           |    val condition/*L6*/ = Main/*Main.scala:3*/.message/*Main.scala:4*/.contains/*String.java*/("Hello")
           |    assert/*Assertions.scala*/(condition/*L6*/)
           |  }
           |}
           |""".stripMargin
      )
      _ <- server.didChange("b/src/main/scala/a/MainSuite.scala") { text =>
        ">>>>>>>\n\n" + text.replaceFirst("\"a\"", "testName")
      }
      _ <- server.didChange("a/src/main/scala/a/Main.scala") { text =>
        ">>>>>>>\n\n" + text.replaceFirst("message", "helloMessage")
      }
      _ = assertNoDiff(
        // Check that:
        // - navigation works for all unchanged identifiers, even if the buffer doesn't parse
        // - line numbers have shifted by 2 for both local and Main.scala references in MainSuite.scala
        // - old references to `message` don't resolve because it has been renamed to `helloMessage`
        // - new references to like `testName` don't resolve
        server.workspaceDefinitions,
        """|/a/src/main/scala/a/Main.scala
           |>>>>>>>/*<no symbol>*/
           |
           |package a
           |import java.util.concurrent.Future/*Future.java*/ // unused
           |import scala.util.Failure/*Try.scala*/ // unused
           |object Main/*L5*/ extends App/*App.scala*/ {
           |  val helloMessage/*<no symbol>*/ = Message/*Message.java:1*/.message/*Message.java:2*/
           |  new java.io.PrintStream/*PrintStream.java*/(new java.io.ByteArrayOutputStream/*ByteArrayOutputStream.java*/())
           |  println/*Predef.scala*/(message/*<no symbol>*/)
           |}
           |/b/src/main/scala/a/MainSuite.scala
           |>>>>>>>/*<no symbol>*/
           |
           |package a
           |import java.util.concurrent.Future/*Future.java*/ // unused
           |import scala.util.Failure/*Try.scala*/ // unused
           |import org.scalatest.FunSuite/*FunSuite.scala*/
           |object MainSuite/*L6*/ extends FunSuite/*FunSuite.scala*/ {
           |  test/*FunSuiteLike.scala*/(testName/*<no symbol>*/) {
           |    val condition/*L8*/ = Main/*Main.scala:5*/.message/*<no symbol>*/.contains/*String.java*/("Hello")
           |    assert/*Assertions.scala*/(condition/*L8*/)
           |  }
           |}
           |""".stripMargin
      )
    } yield ()
  }

  // This test shows what happens when external dependency sources require compiler
  // plugins that are not enabled in the user's build. In this case, cats-core
  // requires org.scalamacros:macroparadise and io.spire-match:kind-projector.
  // Navigation continues to mostly work, except for areas that have compilation
  // errors.
  testAsync("missing-compiler-plugin") {
    for {
      _ <- server.initialize(
        """
          |/metals.json
          |{
          |  "a": {
          |    "libraryDependencies": [
          |      "org.typelevel::cats-core:1.4.0"
          |    ]
          |  }
          |}
          |/a/src/main/scala/a/Main.scala
          |import cats._
          |import cats.implicits._
          |object Main {
          |  println(Contravariant[Show])
          |}
          |""".stripMargin
      )
      _ <- server.didOpen("a/src/main/scala/a/Main.scala")
      _ = server.workspaceDefinitions // trigger definition
      _ <- server.didOpen("cats/Contravariant.scala")
      _ = assertNoDiff(
        server.workspaceDefinitions,
        """|/.metals/readonly/cats/Contravariant.scala
           |package cats
           |import simulacrum/*<no symbol>*/.typeclass/*L5*/
           |/**
           | * Must obey the laws defined in cats.laws.ContravariantLaws.
           | */
           |@typeclass/*<no symbol>*/ trait Contravariant/*L5*/[F/*L5*/[_]] extends Invariant/*Invariant.scala*/[F/*L5*/] { self/*L5*/ =>
           |  def contramap/*L6*/[A/*L6*/, B/*L6*/](fa/*L6*/: F/*L5*/[A/*L6*/])(f/*L6*/: B/*L6*/ => A/*L6*/): F/*L5*/[B/*L6*/]
           |  override def imap/*L7*/[A/*L7*/, B/*L7*/](fa/*L7*/: F/*L5*/[A/*L7*/])(f/*L7*/: A/*L7*/ => B/*L7*/)(fi/*L7*/: B/*L7*/ => A/*L7*/): F/*L5*/[B/*L7*/] = contramap/*L6*/(fa/*L7*/)(fi/*L7*/)
           |
           |  def compose/*L9*/[G/*L9*/[_]: Contravariant/*L5*/]: Functor/*Functor.scala*/[λ/*<no symbol>*/[α/*<no symbol>*/ => F/*<no symbol>*/[G/*<no symbol>*/[α/*<no symbol>*/]]]] =
           |    new ComposedContravariant/*Composed.scala*/[F/*L5*/, G/*L9*/] {
           |      val F/*L11*/ = self/*L5*/
           |      val G/*L12*/ = Contravariant/*<no symbol>*/[G/*L9*/]
           |    }
           |
           |  /**
           |   * Lifts natural subtyping contravariance of contravariant Functors.
           |   * could be implemented as contramap(identity), but the Functor laws say this is equivalent
           |   */
           |  def narrow/*L19*/[A/*L19*/, B/*L19*/ <: A/*L19*/](fa/*L19*/: F/*L5*/[A/*L19*/]): F/*L5*/[B/*L19*/] = fa/*L19*/.asInstanceOf/*<no symbol>*/[F/*L5*/[B/*L19*/]]
           |
           |  def liftContravariant/*L21*/[A/*L21*/, B/*L21*/](f/*L21*/: A/*L21*/ => B/*L21*/): F/*L5*/[B/*L21*/] => F/*L5*/[A/*L21*/] = contramap/*L6*/(_: F/*L5*/[B/*L21*/])(f/*L21*/)
           |
           |  override def composeFunctor/*L23*/[G/*L23*/[_]: Functor/*Functor.scala*/]: Contravariant/*L5*/[λ/*<no symbol>*/[α/*<no symbol>*/ => F/*<no symbol>*/[G/*<no symbol>*/[α/*<no symbol>*/]]]] =
           |    new ComposedContravariantCovariant/*Composed.scala*/[F/*L5*/, G/*L23*/] {
           |      val F/*L25*/ = self/*L5*/
           |      val G/*L26*/ = Functor/*Functor.scala*/[G/*L23*/]
           |    }
           |}
           |
           |/a/src/main/scala/a/Main.scala
           |import cats._
           |import cats.implicits/*implicits.scala*/._
           |object Main/*L2*/ {
           |  println/*Predef.scala*/(Contravariant/*Contravariant.scala*/[Show/*Show.scala*/])
           |}
          """.stripMargin
      )
      _ = assertNoDiff(
        client.workspaceDiagnostics,
        """|.metals/readonly/cats/Contravariant.scala:2:8: information: not found: object simulacrum
           |import simulacrum.typeclass
           |       ^^^^^^^^^^
           |.metals/readonly/cats/Contravariant.scala:6:2: information: not found: type typeclass
           |@typeclass trait Contravariant[F[_]] extends Invariant[F] { self =>
           | ^^^^^^^^^
           |.metals/readonly/cats/Contravariant.scala:10:45: information: not found: type λ
           |  def compose[G[_]: Contravariant]: Functor[λ[α => F[G[α]]]] =
           |                                            ^
           |.metals/readonly/cats/Contravariant.scala:10:45: information: <error> takes no type parameters, expected: one
           |  def compose[G[_]: Contravariant]: Functor[λ[α => F[G[α]]]] =
           |                                            ^
           |.metals/readonly/cats/Contravariant.scala:13:15: information: not found: value Contravariant
           |      val G = Contravariant[G]
           |              ^^^^^^^^^^^^^
           |.metals/readonly/cats/Contravariant.scala:24:61: information: not found: type λ
           |  override def composeFunctor[G[_]: Functor]: Contravariant[λ[α => F[G[α]]]] =
           |                                                            ^
           |.metals/readonly/cats/Contravariant.scala:24:61: information: <error> takes no type parameters, expected: one
           |  override def composeFunctor[G[_]: Functor]: Contravariant[λ[α => F[G[α]]]] =
           |                                                            ^
           |""".stripMargin
      )
      _ <- server.didFocus("a/src/main/scala/a/Main.scala")
      // dependency diagnostics are unpublished.
      _ = assertNoDiff(client.workspaceDiagnostics, "")
    } yield ()
  }

  testAsync("2.11") {
    cleanDatabase()
    for {
      _ <- server.initialize(
        """
          |/metals.json
          |{
          |  "a": {
          |    "scalaVersion": "2.11.12"
          |  }
          |}
          |/a/src/main/scala/a/Main.scala
          |object Main {
          |  println("hello!")
          |}
          |""".stripMargin
      )
      _ = client.messageRequests.clear()
      _ <- server.didOpen("a/src/main/scala/a/Main.scala")
      _ = server.workspaceDefinitions // trigger definition
      _ <- server.didOpen("scala/Predef.scala")
      _ = assertNoDiff(
        client.workspaceMessageRequests,
        Only212Navigation.params("2.11.12").getMessage
      )
      _ = assertNoDiff(client.workspaceDiagnostics, "")
    } yield ()
  }

  testAsync("stale") {
    for {
      _ <- server.initialize(
        """
          |/metals.json
          |{
          |  "a": { }
          |}
          |/a/src/main/scala/a/Main.scala
          |object Main {
          |  val x: Int = math.max(1, 2)
          |}
          |""".stripMargin
      )
      _ = client.messageRequests.clear()
      _ <- server.didOpen("a/src/main/scala/a/Main.scala")
      _ = assertNoDiff(
        server.workspaceDefinitions,
        """|/a/src/main/scala/a/Main.scala
           |object Main/*L0*/ {
           |  val x/*L1*/: Int/*Int.scala*/ = math.max/*package.scala*/(1, 2)
           |}
        """.stripMargin
      )
      _ <- server.didSave("a/src/main/scala/a/Main.scala")(
        _.replaceAllLiterally("max(1, 2)", "max")
      )
      _ = assertNoDiff(
        server.workspaceDefinitions,
        """|/a/src/main/scala/a/Main.scala
           |object Main/*L0*/ {
           |  val x/*L1*/: Int/*Int.scala*/ = math.max/*package.scala*/
           |}
           |""".stripMargin
      )
    } yield ()
  }

  testAsync("annotations") {
    for {
      _ <- server.initialize(
        """
          |/metals.json
          |{
          |  "a": {
          |    "compilerPlugins": [
          |      "org.scalamacros:::paradise:2.1.1"
          |    ],
          |    "libraryDependencies": [
          |      "io.circe::circe-core:0.9.0",
          |      "io.circe::circe-derivation:0.9.0-M4"
          |    ]
          |  }
          |}
          |/a/src/main/scala/a/User.scala
          |package a
          |import io.circe.derivation.JsonCodec
          |@JsonCodec case class User(name: String)
          |/a/src/main/scala/a/Main.scala
          |package a
          |object Main {
          |  val user = User("John")
          |  val name = user.name
          |  val encoder = User.encodeUser
          |}
          |""".stripMargin
      )
      _ <- server.didOpen("a/src/main/scala/a/Main.scala")
      _ = assertNoDiff(client.workspaceDiagnostics, "")
      _ = assertNoDiff(
        server.workspaceDefinitions,
        """
          |/a/src/main/scala/a/Main.scala
          |package a
          |object Main/*L1*/ {
          |  val user/*L2*/ = User/*User.scala:2*/("John")
          |  val name/*L3*/ = user/*L2*/.name/*User.scala:2*/
          |  val encoder/*L4*/ = User/*User.scala:2*/.encodeUser/*User.scala:2*/
          |}
          |""".stripMargin
      )
    } yield ()
  }

}
import sbt._

object Dependencies {

  val CatsVersion = "1.0.1"
  val ScalaXmlVersion = "1.1.0"

  lazy val cats = Seq(
    "org.typelevel" %% "cats-core" % CatsVersion,
    "org.typelevel" %% "cats-effect" % "1.0.0-RC2")

  lazy val scalaXml = "org.scala-lang.modules" %% "scala-xml" %  ScalaXmlVersion

  lazy val scalaTest = "org.scalatest" %% "scalatest" % "3.0.5"
  lazy val scalaMock = "org.scalamock" %% "scalamock" % "4.1.0"
  lazy val scalaCheck = "org.scalacheck" %% "scalacheck" % "1.14.0"


  lazy val dependencies: Seq[ModuleID] = cats ++ Seq(
    scalaXml,
    scalaTest % Test,
    scalaMock % Test,
    scalaCheck % Test
  )

}
import sbt._
import sbt.Keys._

object DependenciesPlugin extends AutoPlugin {
  type Deps = Seq[ModuleID]

  def group( organization: String, version: String )( artifacts: String* )( testArtifacts: String* ): Seq[ModuleID] =
    artifacts.map( organization %% _ % version ) ++ testArtifacts.map( organization %% _ % version % "test" )

  object autoImport {
    type Deps = DependenciesPlugin.Deps

    def depsGroup( organization: String, version: String )( artifacts: String* )(
        testArtifacts: String* ): Seq[ModuleID] =
      DependenciesPlugin.group( organization, version )( artifacts: _* )( testArtifacts: _* )

    implicit def ToGroupOps( deps: Deps ): GroupOps = new GroupOps( deps )

    val kindProjector: Deps = Seq( compilerPlugin( "org.spire-math" %% "kind-projector" % "0.9.6" ) )
    val splain: Deps        = Seq( compilerPlugin( "io.tryp"        % "splain"          % "0.2.7" cross CrossVersion.patch ) )

    val catsVersion     = "1.1.0"
    val cats: Deps      = group( "org.typelevel", catsVersion )( "cats-core" )()
    val catsExtra: Deps = group( "org.typelevel", catsVersion )( "cats-free", "cats-macros" )()

    val machinist = Seq( "org.typelevel" %% "machinist" % "0.6.2" )

    val mouse: Deps = group( "org.typelevel", "0.17" )( "mouse" )()

    val scalaArm: Deps = group( "com.jsuereth", "2.0" )( "scala-arm" )()
    val monocleVersion = "1.5.0-cats"
    val monocle: Deps =
      group( "com.github.julien-truffaut", monocleVersion )( "monocle-core", "monocle-macro" )()

    val circeVersion = "0.9.3"
    val circe: Deps =
      group( "io.circe", circeVersion )( "circe-core", "circe-generic", "circe-parser" )()
    val circeOptics = Seq( "io.circe" %% "circe-optics" % circeVersion )

    val akkaVersion           = "2.5.12"
    val akkaHttpVersion       = "10.1.1"
    val akkaHttpTestkit: Deps = Seq( "com.typesafe.akka" %% "akka-http-testkit" % akkaHttpVersion )

    val akkaHttp: Deps =
      group( "com.typesafe.akka", akkaVersion )( "akka-actor", "akka-stream" )() ++
        group( "com.typesafe.akka", akkaHttpVersion )( "akka-http" )( "akka-http-testkit" ) ++
        Seq( "de.heikoseeberger" %% "akka-http-circe" % "1.20.1" )

    val sslConfigCore   = Seq( "com.typesafe"        %% "ssl-config-core" % "0.2.2" )
    val reactiveStreams = Seq( "org.reactivestreams" % "reactive-streams" % "1.0.2" )

    val enumeratum: Deps =
      Seq( "com.beachape" %% "enumeratum" % "1.5.13", "com.beachape" %% "enumeratum-circe" % "1.5.17" )

    val shapeless: Deps = Seq( "com.chuusai" %% "shapeless" % "2.3.3" )

    val java8compat: Deps      = Seq( "org.scala-lang.modules" %% "scala-java8-compat" % "0.9.0" )
    val scalaLangModules: Deps = group( "org.scala-lang.modules", "1.0.6" )( "scala-parser-combinators", "scala-xml" )()

    val logging: Deps = Seq( "org.slf4j" % "slf4j-api" % "1.7.25",
                            "ch.qos.logback"             % "logback-classic" % "1.2.3",
                            "com.typesafe.scala-logging" %% "scala-logging"  % "3.9.0" )

    val pureconfig: Deps = Seq( "com.typesafe" % "config" % "1.3.2", "com.github.pureconfig" %% "pureconfig" % "0.9.1" )

    val slickVersion       = "3.2.3"
    val slick: Deps        = group( "com.typesafe.slick", slickVersion )( "slick", "slick-hikaricp" )()
    val slickCodegen: Deps = Seq( "com.typesafe.slick" %% "slick-codegen" % slickVersion )

    val postgresql: Deps     = Seq( "org.postgresql" % "postgresql" % "9.4.1212" )
    val h2databaseMain: Deps = Seq( "com.h2database" % "h2" % "1.4.197" )
    val h2database: Deps     = h2databaseMain % "test"
    val flywayCore: Deps     = Seq( "org.flywaydb" % "flyway-core" % "5.0.7" )

    val univocity: Deps = Seq( "com.univocity" % "univocity-parsers" % "2.6.1" )

    val jose4j: Deps = Seq( "org.bitbucket.b_c" % "jose4j" % "0.6.3" )

    val scalatestMain: Deps = Seq( "org.scalatest" %% "scalatest" % "3.0.5" )
    val scalatest: Deps     = scalatestMain % "test"

    val scalacheckMain: Deps =
      Seq(
        "org.scalacheck"      %% "scalacheck"      % "1.13.4",
        "io.github.amrhassan" %% "scalacheck-cats" % "0.4.0"
      )
    val scalacheck: Deps = scalacheckMain % "test"

    val autoDiff: Deps =
      group( "fr.thomasdufour", "0.2.0" )()( "auto-diff-core",
                                            "auto-diff-generic",
                                            "auto-diff-scalatest",
                                            "auto-diff-enumeratum" )

    val gatlingVersion = "2.3.1"
    val gatling =
      Seq(
        "io.gatling.highcharts" % "gatling-charts-highcharts" % gatlingVersion,
        "io.gatling"            % "gatling-test-framework"    % gatlingVersion
      ) % "test,it"

  }

  import autoImport._

  override def buildSettings: Seq[Def.Setting[_]] =
    dependencyOverrides in ThisBuild ++= Seq(
      "org.scala-lang" % "scala-library" % scalaVersion.value,
      "org.scala-lang" % "scala-reflect" % scalaVersion.value
    ) ++
      cats ++
      catsExtra ++
      machinist
//  ++
//  mouse ++
//    scalaArm ++
//    monocle ++
//    circe ++
//    akkaHttp ++
//    sslConfigCore ++
//    reactiveStreams ++
//    enumeratum ++
//    shapeless ++
//    java8compat ++
//    scalaLangModules ++
//    logging ++
//    pureconfig ++
//    slick ++
//    slickCodegen ++
//    postgresql ++
//    h2database ++
//    flywayCore ++
//    univocity ++
//    jose4j ++
//    scalatest ++
//    scalacheck ++
//    autoDiff ++
//    gatling

  class GroupOps( val self: Seq[ModuleID] ) extends AnyVal {
    def exclude( org: String, name: String ): Seq[ModuleID] =
      self.map( _.exclude( org, name ) )

    def %( configurations: String ): Seq[ModuleID] =
      self.map( _ % configurations )

    def classifier( c: String ): Seq[ModuleID] =
      self.map( _ classifier c )
  }
}
import sbt.Keys.libraryDependencies
import sbt._
import sbt.librarymanagement.{CrossVersion, ModuleID}

object DependencySettings {

  val commonDependencies: Seq[Def.Setting[Seq[ModuleID]]] = Seq(
    libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.8" % Test,
    libraryDependencies += "com.github.ghik" %% "silencer-lib" % "1.4.1" % Provided,
    libraryDependencies += compilerPlugin("com.github.ghik" %% "silencer-plugin" % "1.4.1"),
  )

  val catsDependency = libraryDependencies += {
    CrossVersion.partialVersion(Keys.scalaVersion.value) match {
      case Some((2, 13))     => "org.typelevel" %% "cats-core" % "2.0.0-M4"
      case Some((2, 12)) | _ => "org.typelevel" %% "cats-core" % "1.6.1"
    }
  }

  val catsEffectDependency = libraryDependencies += {
    CrossVersion.partialVersion(Keys.scalaVersion.value) match {
      case Some((2, 13))     => "org.typelevel" %% "cats-effect" % "2.0.0-RC1"
      case Some((2, 12)) | _ => "org.typelevel" %% "cats-effect" % "1.4.0"
    }
  }

  val fs2Dependency = libraryDependencies += {
    CrossVersion.partialVersion(Keys.scalaVersion.value) match {
      case Some((2, 13))     => "co.fs2" %% "fs2-core" % "1.1.0-M1"
      case Some((2, 12)) | _ => "co.fs2" %% "fs2-core" % "1.0.5"
    }
  }

  val circeDependency = libraryDependencies += {
    CrossVersion.partialVersion(Keys.scalaVersion.value) match {
      case Some((2, 13))     => "io.circe" %% "circe-core" % "0.12.0-RC1"
      case Some((2, 12)) | _ => "io.circe" %% "circe-core" % "0.11.1"
    }
  }

  val spireDependency = libraryDependencies += {
    CrossVersion.partialVersion(Keys.scalaVersion.value) match {
      case Some((2, 13))     => "org.typelevel" %% "spire" % "0.17.0-M1"
      case Some((2, 12)) | _ => "org.typelevel" %% "spire" % "0.16.2"
    }
  }

  val catsTestKitDependency = libraryDependencies += {
    CrossVersion.partialVersion(Keys.scalaVersion.value) match {
      case Some((2, 13))     => "org.typelevel" %% "cats-testkit" % "2.0.0-M4" % Test
      case Some((2, 12)) | _ => "org.typelevel" %% "cats-testkit" % "1.6.1"    % Test
    }
  }

}
package cats
package data

import cats.Bifunctor
import cats.instances.either._
import cats.syntax.either._

/**
 * Transformer for `Either`, allowing the effect of an arbitrary type constructor `F` to be combined with the
 * fail-fast effect of `Either`.
 *
 * `EitherT[F, A, B]` wraps a value of type `F[Either[A, B]]`. An `F[C]` can be lifted in to `EitherT[F, A, C]` via `EitherT.right`,
 * and lifted in to a `EitherT[F, C, B]` via `EitherT.left`.
 */
final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
  def fold[C](fa: A => C, fb: B => C)(implicit F: Functor[F]): F[C] = F.map(value)(_.fold(fa, fb))

  def isLeft(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.isLeft)

  def isRight(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.isRight)

  def swap(implicit F: Functor[F]): EitherT[F, B, A] = EitherT(F.map(value)(_.swap))

  def getOrElse[BB >: B](default: => BB)(implicit F: Functor[F]): F[BB] = F.map(value)(_.getOrElse(default))

  def getOrElseF[BB >: B](default: => F[BB])(implicit F: Monad[F]): F[BB] = {
    F.flatMap(value) {
      case Left(_) => default
      case Right(b) => F.pure(b)
    }
  }

  def orElse[AA, BB >: B](default: => EitherT[F, AA, BB])(implicit F: Monad[F]): EitherT[F, AA, BB] = {
    EitherT(F.flatMap(value) {
      case Left(_) => default.value
      case r @ Right(_) => F.pure(r.leftCast)
    })
  }

  def recover(pf: PartialFunction[A, B])(implicit F: Functor[F]): EitherT[F, A, B] =
    EitherT(F.map(value)(_.recover(pf)))

  def recoverWith(pf: PartialFunction[A, EitherT[F, A, B]])(implicit F: Monad[F]): EitherT[F, A, B] =
    EitherT(F.flatMap(value) {
      case Left(a) if pf.isDefinedAt(a) => pf(a).value
      case other => F.pure(other)
    })

  def valueOr[BB >: B](f: A => BB)(implicit F: Functor[F]): F[BB] = fold(f, identity)

  def forall(f: B => Boolean)(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.forall(f))

  def exists(f: B => Boolean)(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.exists(f))

  def ensure[AA >: A](onFailure: => AA)(f: B => Boolean)(implicit F: Functor[F]): EitherT[F, AA, B] =
    EitherT(F.map(value)(_.ensure(onFailure)(f)))

  def ensureOr[AA >: A](onFailure: B => AA)(f: B => Boolean)(implicit F: Functor[F]): EitherT[F, AA, B] =
    EitherT(F.map(value)(_.ensureOr(onFailure)(f)))

  def toOption(implicit F: Functor[F]): OptionT[F, B] = OptionT(F.map(value)(_.toOption))

  def to[G[_]](implicit F: Functor[F], G: Alternative[G]): F[G[B]] =
    F.map(value)(_.to[G])

  def collectRight(implicit FA: Alternative[F], FM: Monad[F]): F[B] =
    FM.flatMap(value)(_.to[F])

  def bimap[C, D](fa: A => C, fb: B => D)(implicit F: Functor[F]): EitherT[F, C, D] = EitherT(F.map(value)(_.bimap(fa, fb)))

  def bitraverse[G[_], C, D](f: A => G[C], g: B => G[D])(implicit traverseF: Traverse[F], applicativeG: Applicative[G]): G[EitherT[F, C, D]] =
    applicativeG.map(traverseF.traverse(value)(axb => Bitraverse[Either].bitraverse(axb)(f, g)))(EitherT.apply)

  def applyAlt[D](ff: EitherT[F, A, B => D])(implicit F: Apply[F]): EitherT[F, A, D] =
    EitherT[F, A, D](F.map2(this.value, ff.value)((xb, xbd) => Apply[Either[A, ?]].ap(xbd)(xb)))

  def flatMap[AA >: A, D](f: B => EitherT[F, AA, D])(implicit F: Monad[F]): EitherT[F, AA, D] =
    EitherT(F.flatMap(value) {
      case l @ Left(_) => F.pure(l.rightCast)
      case Right(b) => f(b).value
    })

  def flatMapF[AA >: A, D](f: B => F[Either[AA, D]])(implicit F: Monad[F]): EitherT[F, AA, D] =
    flatMap(f andThen EitherT.apply)

  def transform[C, D](f: Either[A, B] => Either[C, D])(implicit F: Functor[F]): EitherT[F, C, D] =
    EitherT(F.map(value)(f))

  def subflatMap[AA >: A, D](f: B => Either[AA, D])(implicit F: Functor[F]): EitherT[F, AA, D] =
    transform(_.flatMap(f))

  def map[D](f: B => D)(implicit F: Functor[F]): EitherT[F, A, D] = bimap(identity, f)

  /**
   * Modify the context `F` using transformation `f`.
   */
  def mapK[G[_]](f: F ~> G): EitherT[G, A, B] = EitherT[G, A, B](f(value))

  def semiflatMap[D](f: B => F[D])(implicit F: Monad[F]): EitherT[F, A, D] =
    flatMap(b => EitherT.right(f(b)))

  def leftMap[C](f: A => C)(implicit F: Functor[F]): EitherT[F, C, B] = bimap(f, identity)

  def leftFlatMap[BB >: B, D](f: A => EitherT[F, D, BB])(implicit F: Monad[F]): EitherT[F, D, BB] =
    EitherT(F.flatMap(value) {
      case Left(a) => f(a).value
      case r@Right(_) => F.pure(r.leftCast)
    })

  def leftSemiflatMap[D](f: A => F[D])(implicit F: Monad[F]): EitherT[F, D, B] =
    EitherT(F.flatMap(value) {
      case Left(a) => F.map(f(a)) { d => Left(d) }
      case r@Right(_) => F.pure(r.leftCast)
    })

  def compare(that: EitherT[F, A, B])(implicit o: Order[F[Either[A, B]]]): Int =
    o.compare(value, that.value)

  def partialCompare(that: EitherT[F, A, B])(implicit p: PartialOrder[F[Either[A, B]]]): Double =
    p.partialCompare(value, that.value)

  def ===(that: EitherT[F, A, B])(implicit eq: Eq[F[Either[A, B]]]): Boolean =
    eq.eqv(value, that.value)

  def traverse[G[_], D](f: B => G[D])(implicit traverseF: Traverse[F], applicativeG: Applicative[G]): G[EitherT[F, A, D]] =
    applicativeG.map(traverseF.traverse(value)(axb => Traverse[Either[A, ?]].traverse(axb)(f)))(EitherT.apply)

  def foldLeft[C](c: C)(f: (C, B) => C)(implicit F: Foldable[F]): C =
    F.foldLeft(value, c)((c, axb) => axb.foldLeft(c)(f))

  def foldRight[C](lc: Eval[C])(f: (B, Eval[C]) => Eval[C])(implicit F: Foldable[F]): Eval[C] =
    F.foldRight(value, lc)((axb, lc) => axb.foldRight(lc)(f))

  def merge[AA >: A](implicit ev: B <:< AA, F: Functor[F]): F[AA] = F.map(value)(_.fold(identity, ev.apply))

  /**
   * Similar to `Either#combine` but mapped over an `F` context.
   *
   * Examples:
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> val l1: EitherT[Option, String, Int] = EitherT.left(Some("error 1"))
   * scala> val l2: EitherT[Option, String, Int] = EitherT.left(Some("error 2"))
   * scala> val r3: EitherT[Option, String, Int] = EitherT.right(Some(3))
   * scala> val r4: EitherT[Option, String, Int] = EitherT.right(Some(4))
   * scala> val noneEitherT: EitherT[Option, String, Int] = EitherT.left(None)
   *
   * scala> l1 combine l2
   * res0: EitherT[Option, String, Int] = EitherT(Some(Left(error 1)))
   *
   * scala> l1 combine r3
   * res1: EitherT[Option, String, Int] = EitherT(Some(Left(error 1)))
   *
   * scala> r3 combine l1
   * res2: EitherT[Option, String, Int] = EitherT(Some(Left(error 1)))
   *
   * scala> r3 combine r4
   * res3: EitherT[Option, String, Int] = EitherT(Some(Right(7)))
   *
   * scala> l1 combine noneEitherT
   * res4: EitherT[Option, String, Int] = EitherT(None)
   *
   * scala> noneEitherT combine l1
   * res5: EitherT[Option, String, Int] = EitherT(None)
   *
   * scala> r3 combine noneEitherT
   * res6: EitherT[Option, String, Int] = EitherT(None)
   *
   * scala> noneEitherT combine r4
   * res7: EitherT[Option, String, Int] = EitherT(None)
   * }}}
   */
  def combine(that: EitherT[F, A, B])(implicit F: Apply[F], B: Semigroup[B]): EitherT[F, A, B] =
    EitherT(F.map2(this.value, that.value)(_ combine _))

  def toValidated(implicit F: Functor[F]): F[Validated[A, B]] =
    F.map(value)(_.toValidated)

  def toValidatedNel(implicit F: Functor[F]): F[ValidatedNel[A, B]] =
    F.map(value)(_.toValidatedNel)

  /** Run this value as a `[[Validated]]` against the function and convert it back to an `[[EitherT]]`.
   *
   * The [[Applicative]] instance for `EitherT` "fails fast" - it is often useful to "momentarily" have
   * it accumulate errors instead, which is what the `[[Validated]]` data type gives us.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> type Error = String
   * scala> val v1: Validated[NonEmptyList[Error], Int] = Validated.invalidNel("error 1")
   * scala> val v2: Validated[NonEmptyList[Error], Int] = Validated.invalidNel("error 2")
   * scala> val eithert: EitherT[Option, Error, Int] = EitherT.leftT[Option, Int]("error 3")
   * scala> eithert.withValidated { v3 => (v1, v2, v3.toValidatedNel).mapN { case (i, j, k) => i + j + k } }
   * res0: EitherT[Option, NonEmptyList[Error], Int] = EitherT(Some(Left(NonEmptyList(error 1, error 2, error 3))))
   * }}}
   */
  def withValidated[AA, BB](f: Validated[A, B] => Validated[AA, BB])(implicit F: Functor[F]): EitherT[F, AA, BB] =
    EitherT(F.map(value)(either => f(either.toValidated).toEither))

  def show(implicit show: Show[F[Either[A, B]]]): String = show.show(value)

  /**
   * Transform this `EitherT[F, A, B]` into a `[[Nested]][F, Either[A, ?], B]`.
   *
   * An example where `toNested` can be used, is to get the `Apply.ap` function with the
   * behavior from the composed `Apply` instances from `F` and `Either[A, ?]`, which is
   * inconsistent with the behavior of the `ap` from `Monad` of `EitherT`.
   *
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> val ff: EitherT[List, String, Int => String] =
   *      |   EitherT(List(Either.right(_.toString), Either.left("error")))
   * scala> val fa: EitherT[List, String, Int] =
   *      |   EitherT(List(Either.right(1), Either.right(2)))
   * scala> ff.ap(fa)
   * res0: EitherT[List,String,String] = EitherT(List(Right(1), Right(2), Left(error)))
   * scala> EitherT((ff.toNested).ap(fa.toNested).value)
   * res1: EitherT[List,String,String] = EitherT(List(Right(1), Right(2), Left(error), Left(error)))
   * }}}
   *
   */
  def toNested: Nested[F, Either[A, ?], B] = Nested[F, Either[A, ?], B](value)

  /**
    * Transform this `EitherT[F, A, B]` into a `[[Nested]][F, Validated[A, ?], B]`.
    *
    * Example:
    * {{{
    * scala> import cats.data.{EitherT, Validated}
    * scala> import cats.implicits._
    * scala> val f: Int => String = i => (i*2).toString
    * scala> val r1: EitherT[Option, String, Int => String] = EitherT.right(Some(f))
    * r1: cats.data.EitherT[Option,String,Int => String] = EitherT(Some(Right(<function1>)))
    * scala> val r2: EitherT[Option, String, Int] = EitherT.right(Some(10))
    * r2: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(10)))
    * scala> type ErrorOr[A] = Validated[String, A]
    * scala> (r1.toNestedValidated).ap(r2.toNestedValidated)
    * res0: cats.data.Nested[Option,ErrorOr,String] = Nested(Some(Valid(20)))
    * }}}
    */
  def toNestedValidated(implicit F: Functor[F]): Nested[F, Validated[A, ?], B] =
    Nested[F, Validated[A, ?], B](F.map(value)(_.toValidated))

  /**
   * Transform this `EitherT[F, A, B]` into a `[[Nested]][F, ValidatedNel[A, ?], B]`.
   */
  def toNestedValidatedNel(implicit F: Functor[F]): Nested[F, ValidatedNel[A, ?], B] =
    Nested[F, ValidatedNel[A, ?], B](F.map(value)(_.toValidatedNel))
}

object EitherT extends EitherTInstances {

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class LeftPartiallyApplied[B](val dummy: Boolean = true) extends AnyVal {
    def apply[F[_], A](fa: F[A])(implicit F: Functor[F]): EitherT[F, A, B] = EitherT(F.map(fa)(Either.left))
  }

  /**
   * Creates a left version of `EitherT[F, A, B]` from a `F[A]`
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> EitherT.left[Int](Option("err"))
   * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Left(err)))
   * }}}
   */
  final def left[B]: LeftPartiallyApplied[B] = new LeftPartiallyApplied[B]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class LeftTPartiallyApplied[F[_], B](val dummy: Boolean = true) extends AnyVal {
    def apply[A](a: A)(implicit F: Applicative[F]): EitherT[F, A, B] = EitherT(F.pure(Either.left(a)))
  }

  /**
   * Creates a left version of `EitherT[F, A, B]` from a `A`
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> EitherT.leftT[Option, Int]("err")
   * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Left(err)))
   * }}}
   */
  final def leftT[F[_], B]: LeftTPartiallyApplied[F, B] = new LeftTPartiallyApplied[F, B]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class RightPartiallyApplied[A](val dummy: Boolean = true) extends AnyVal {
    def apply[F[_], B](fb: F[B])(implicit F: Functor[F]): EitherT[F, A, B] = EitherT(F.map(fb)(Either.right))
  }

  /**
   * Creates a right version of `EitherT[F, A, B]` from a `F[B]`
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> EitherT.right[String](Option(3))
   * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(3)))
   * }}}
   */
  final def right[A]: RightPartiallyApplied[A] = new RightPartiallyApplied[A]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class PurePartiallyApplied[F[_], A](val dummy: Boolean = true) extends AnyVal {
    def apply[B](b: B)(implicit F: Applicative[F]): EitherT[F, A, B] = right(F.pure(b))
  }

  /**
   * Creates a new `EitherT[F, A, B]` from a `B`
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> EitherT.pure[Option, String](3)
   * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(3)))
   * }}}
   */
  final def pure[F[_], A]: PurePartiallyApplied[F, A] = new PurePartiallyApplied[F, A]

  /**
   * Alias for [[pure]]
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> EitherT.rightT[Option, String](3)
   * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(3)))
   * }}}
   */
  final def rightT[F[_], A]: PurePartiallyApplied[F, A] = pure


  /**
   * Alias for [[right]]
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.implicits._
   * scala> val o: Option[Int] = Some(3)
   * scala> val n: Option[Int] = None
   * scala> EitherT.liftF(o)
   * res0: cats.data.EitherT[Option,Nothing,Int] = EitherT(Some(Right(3)))
   * scala> EitherT.liftF(n)
   * res1: cats.data.EitherT[Option,Nothing,Int] = EitherT(None)
   * }}}
   */
  final def liftF[F[_], A, B](fb: F[B])(implicit F: Functor[F]): EitherT[F, A, B] = right(fb)

  /**
   * Same as [[liftF]], but expressed as a FunctionK for use with mapK
   * {{{
   * scala> import cats._, data._, implicits._
   * scala> val a: OptionT[Eval, Int] = 1.pure[OptionT[Eval, ?]]
   * scala> val b: OptionT[EitherT[Eval, String, ?], Int] = a.mapK(EitherT.liftK)
   * scala> b.value.value.value
   * res0: Either[String,Option[Int]] = Right(Some(1))
   * }}}
   */
  final def liftK[F[_], A](implicit F: Functor[F]): F ~> EitherT[F, A, ?] =
    λ[F ~> EitherT[F, A, ?]](right(_))

  @deprecated("Use EitherT.liftF.", "1.0.0-RC1")
  final def liftT[F[_], A, B](fb: F[B])(implicit F: Functor[F]): EitherT[F, A, B] = right(fb)

  /** Transforms an `Either` into an `EitherT`, lifted into the specified `Applicative`.
   *
   * Note: The return type is a FromEitherPartiallyApplied[F], which has an apply method
   * on it, allowing you to call fromEither like this:
   * {{{
   * scala> import cats.implicits._
   * scala> val t: Either[String, Int] = Either.right(3)
   * scala> EitherT.fromEither[Option](t)
   * res0: EitherT[Option, String, Int] = EitherT(Some(Right(3)))
   * }}}
   *
   * The reason for the indirection is to emulate currying type parameters.
   */
  final def fromEither[F[_]]: FromEitherPartiallyApplied[F] = new FromEitherPartiallyApplied

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class FromEitherPartiallyApplied[F[_]](val dummy: Boolean = true) extends AnyVal {
    def apply[E, A](either: Either[E, A])(implicit F: Applicative[F]): EitherT[F, E, A] =
      EitherT(F.pure(either))
  }

  /** Transforms an `Option` into an `EitherT`, lifted into the specified `Applicative` and using
   *  the second argument if the `Option` is a `None`.
   * {{{
   * scala> import cats.implicits._
   * scala> val o: Option[Int] = None
   * scala> EitherT.fromOption[List](o, "Answer not known.")
   * res0: EitherT[List, String, Int]  = EitherT(List(Left(Answer not known.)))
   * scala> EitherT.fromOption[List](Some(42), "Answer not known.")
   * res1: EitherT[List, String, Int] = EitherT(List(Right(42)))
   * }}}
   */
  final def fromOption[F[_]]: FromOptionPartiallyApplied[F] = new FromOptionPartiallyApplied

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class FromOptionPartiallyApplied[F[_]](val dummy: Boolean = true) extends AnyVal {
    def apply[E, A](opt: Option[A], ifNone: => E)(implicit F: Applicative[F]): EitherT[F, E, A] =
      EitherT(F.pure(Either.fromOption(opt, ifNone)))
  }

  /** Transforms an `F[Option]` into an `EitherT`, using the second argument if the `Option` is a `None`.
   * {{{
   * scala> import cats.implicits._
   * scala> val o: Option[Int] = None
   * scala> EitherT.fromOptionF(List(o), "Answer not known.")
   * res0: EitherT[List, String, Int]  = EitherT(List(Left(Answer not known.)))
   * scala> EitherT.fromOptionF(List(Option(42)), "Answer not known.")
   * res1: EitherT[List, String, Int] = EitherT(List(Right(42)))
   * }}}
   */
  final def fromOptionF[F[_], E, A](fopt: F[Option[A]], ifNone: => E)(implicit F: Functor[F]): EitherT[F, E, A] =
    EitherT(F.map(fopt)(opt => Either.fromOption(opt, ifNone)))

  /**  If the condition is satisfied, return the given `A` in `Right`
    *  lifted into the specified `Applicative`, otherwise, return the
    *  given `E` in `Left` lifted into the specified `Applicative`.
    *
    * {{{
    * scala> import cats.Id
    * scala> import cats.data.EitherT
    * scala> val userInput = "hello world"
    * scala> EitherT.cond[Id](
    *      |   userInput.forall(_.isDigit) && userInput.size == 10,
    *      |   userInput,
    *      |   "The input does not look like a phone number")
    * res0: EitherT[Id, String, String] = EitherT(Left(The input does not look like a phone number))
    * }}}
    */
  final def cond[F[_]]: CondPartiallyApplied[F] = new CondPartiallyApplied

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  private[data] final class CondPartiallyApplied[F[_]](val dummy: Boolean = true) extends AnyVal {
    def apply[E, A](test: Boolean, right: => A, left: => E)(implicit F: Applicative[F]): EitherT[F, E, A] =
      EitherT(F.pure(Either.cond(test, right, left)))
  }
}

private[data] abstract class EitherTInstances extends EitherTInstances1 {

  implicit def catsDataOrderForEitherT[F[_], L, R](implicit F: Order[F[Either[L, R]]]): Order[EitherT[F, L, R]] =
    new EitherTOrder[F, L, R] {
      val F0: Order[F[Either[L, R]]] = F
    }

  implicit def catsDataShowForEitherT[F[_], L, R](implicit sh: Show[F[Either[L, R]]]): Show[EitherT[F, L, R]] =
    Contravariant[Show].contramap(sh)(_.value)

  implicit def catsDataBifunctorForEitherT[F[_]](implicit F: Functor[F]): Bifunctor[EitherT[F, ?, ?]] =
    new Bifunctor[EitherT[F, ?, ?]] {
      override def bimap[A, B, C, D](fab: EitherT[F, A, B])(f: A => C, g: B => D): EitherT[F, C, D] = fab.bimap(f, g)
    }

  implicit def catsDataTraverseForEitherT[F[_], L](implicit F: Traverse[F]): Traverse[EitherT[F, L, ?]] =
    new EitherTTraverse[F, L] {
      val F0: Traverse[F] = F
    }

  implicit def catsMonoidForEitherT[F[_], L, A](implicit F: Monoid[F[Either[L, A]]]): Monoid[EitherT[F, L, A]] =
    new EitherTMonoid[F, L, A] { implicit val F0 = F }

}

private[data] abstract class EitherTInstances1 extends EitherTInstances2 {

  implicit def catsSemigroupForEitherT[F[_], L, A](implicit F: Semigroup[F[Either[L, A]]]): Semigroup[EitherT[F, L, A]] =
    new EitherTSemigroup[F, L, A] { implicit val F0 = F }

  implicit def catsDataFoldableForEitherT[F[_], L](implicit F: Foldable[F]): Foldable[EitherT[F, L, ?]] =
    new EitherTFoldable[F, L] {
      val F0: Foldable[F] = F
    }

  implicit def catsDataPartialOrderForEitherT[F[_], L, R](implicit F: PartialOrder[F[Either[L, R]]]): PartialOrder[EitherT[F, L, R]] =
    new EitherTPartialOrder[F, L, R] {
      val F0: PartialOrder[F[Either[L, R]]] = F
    }

  implicit def catsDataBitraverseForEitherT[F[_]](implicit F: Traverse[F]): Bitraverse[EitherT[F, ?, ?]] =
    new EitherTBitraverse[F] {
      val F0: Traverse[F] = F
    }

  implicit def catsDataMonadErrorForEitherT[F[_], L](implicit F0: Monad[F]): MonadError[EitherT[F, L, ?], L] =
    new EitherTMonadError[F, L] {
      implicit val F = F0
      override def ensure[A](fa: EitherT[F, L, A])(error: => L)(predicate: (A) => Boolean): EitherT[F, L, A] =
        fa.ensure(error)(predicate)(F)

      override def ensureOr[A](fa: EitherT[F, L, A])(error: (A) => L)(predicate: (A) => Boolean): EitherT[F, L, A] =
        fa.ensureOr(error)(predicate)(F)
    }
}

private[data] abstract class EitherTInstances2 extends EitherTInstances3 {
  /**  Monad error instance for recovering errors in F instead of
   *  the underlying Either.
   *
   * {{{
   * scala> import cats.data.EitherT
   * scala> import cats.MonadError
   * scala> import cats.instances.option._
   * scala> val noInt: Option[Either[String, Int]] = None
   * scala> val et = EitherT[Option, String, Int](noInt)
   * scala> val me = MonadError[EitherT[Option, String, ?], Unit]
   * scala> me.recover(et) { case () => 1 }
   * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(1)))
   * }}}
   */
  implicit def catsDataMonadErrorFForEitherT[F[_], E, L](implicit FE0: MonadError[F, E]): MonadError[EitherT[F, L, ?], E] =
    new EitherTMonadErrorF[F, E, L] { implicit val F = FE0 }


  implicit def catsDataSemigroupKForEitherT[F[_], L](implicit F0: Monad[F]): SemigroupK[EitherT[F, L, ?]] =
    new EitherTSemigroupK[F, L] { implicit val F = F0 }

  implicit def catsDataEqForEitherT[F[_], L, R](implicit F: Eq[F[Either[L, R]]]): Eq[EitherT[F, L, R]] =
    new EitherTEq[F, L, R] {
      val F0: Eq[F[Either[L, R]]] = F
    }
}

private[data] abstract class EitherTInstances3 {
  implicit def catsDataFunctorForEitherT[F[_], L](implicit F0: Functor[F]): Functor[EitherT[F, L, ?]] =
    new EitherTFunctor[F, L] { implicit val F = F0 }
}

private[data] trait EitherTSemigroup[F[_], L, A] extends Semigroup[EitherT[F, L, A]] {
  implicit val F0: Semigroup[F[Either[L, A]]]
  def combine(x: EitherT[F, L , A], y: EitherT[F, L , A]): EitherT[F, L , A] =
    EitherT(F0.combine(x.value, y.value))
}

private[data] trait EitherTMonoid[F[_], L, A] extends Monoid[EitherT[F, L, A]] with EitherTSemigroup[F, L, A] {
  implicit val F0: Monoid[F[Either[L, A]]]
  def empty: EitherT[F, L, A] = EitherT(F0.empty)
}

private[data] trait EitherTSemigroupK[F[_], L] extends SemigroupK[EitherT[F, L, ?]] {
  implicit val F: Monad[F]
  def combineK[A](x: EitherT[F, L, A], y: EitherT[F, L, A]): EitherT[F, L, A] =
    EitherT(F.flatMap(x.value) {
      case l @ Left(_) => y.value
      case r @ Right(_) => F.pure(r)
    })
}

private[data] trait EitherTFunctor[F[_], L] extends Functor[EitherT[F, L, ?]] {
  implicit val F: Functor[F]
  override def map[A, B](fa: EitherT[F, L, A])(f: A => B): EitherT[F, L, B] = fa map f
}

private[data] trait EitherTMonad[F[_], L] extends Monad[EitherT[F, L, ?]] with EitherTFunctor[F, L] {
  implicit val F: Monad[F]
  def pure[A](a: A): EitherT[F, L, A] = EitherT.pure(a)

  def flatMap[A, B](fa: EitherT[F, L, A])(f: A => EitherT[F, L, B]): EitherT[F, L, B] = fa flatMap f
  def tailRecM[A, B](a: A)(f: A => EitherT[F, L, Either[A, B]]): EitherT[F, L, B] =
    EitherT(F.tailRecM(a)(a0 => F.map(f(a0).value) {
      case Left(l)         => Right(Left(l))
      case Right(Left(a1)) => Left(a1)
      case Right(Right(b)) => Right(Right(b))
    }))
}

private[data] trait EitherTMonadErrorF[F[_], E, L] extends MonadError[EitherT[F, L, ?], E] with EitherTMonad[F, L] {
  implicit val F: MonadError[F, E]

  def handleErrorWith[A](fea: EitherT[F, L, A])(f: E => EitherT[F, L, A]): EitherT[F, L, A] =
    EitherT(F.handleErrorWith(fea.value)(f(_).value))

  def raiseError[A](e: E): EitherT[F, L, A] = EitherT(F.raiseError(e))
}

private[data] trait EitherTMonadError[F[_], L] extends MonadError[EitherT[F, L, ?], L] with EitherTMonad[F, L] {
  def handleErrorWith[A](fea: EitherT[F, L, A])(f: L => EitherT[F, L, A]): EitherT[F, L, A] =
    EitherT(F.flatMap(fea.value) {
      case Left(e) => f(e).value
      case r @ Right(_) => F.pure(r)
    })
  override def handleError[A](fea: EitherT[F, L, A])(f: L => A): EitherT[F, L, A] =
    EitherT(F.flatMap(fea.value) {
      case Left(e) => F.pure(Right(f(e)))
      case r @ Right(_) => F.pure(r)
    })
  def raiseError[A](e: L): EitherT[F, L, A] = EitherT.left(F.pure(e))
  override def attempt[A](fla: EitherT[F, L, A]): EitherT[F, L, Either[L, A]] = EitherT.right(fla.value)
  override def recover[A](fla: EitherT[F, L, A])(pf: PartialFunction[L, A]): EitherT[F, L, A] =
    fla.recover(pf)
  override def recoverWith[A](fla: EitherT[F, L, A])(pf: PartialFunction[L, EitherT[F, L, A]]): EitherT[F, L, A] =
    fla.recoverWith(pf)
}

private[data] sealed trait EitherTFoldable[F[_], L] extends Foldable[EitherT[F, L, ?]] {
  implicit def F0: Foldable[F]

  def foldLeft[A, B](fa: EitherT[F, L, A], b: B)(f: (B, A) => B): B =
    fa.foldLeft(b)(f)

  def foldRight[A, B](fa: EitherT[F, L, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
    fa.foldRight(lb)(f)
}

private[data] sealed trait EitherTTraverse[F[_], L] extends Traverse[EitherT[F, L, ?]] with EitherTFoldable[F, L] {
  override implicit def F0: Traverse[F]

  override def traverse[G[_]: Applicative, A, B](fa: EitherT[F, L, A])(f: A => G[B]): G[EitherT[F, L, B]] =
    fa traverse f
}

private[data] sealed trait EitherTBifoldable[F[_]] extends Bifoldable[EitherT[F, ?, ?]] {
  implicit def F0: Foldable[F]

  def bifoldLeft[A, B, C](fab: EitherT[F, A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
    F0.foldLeft(fab.value, c)( (acc, axb) => Bifoldable[Either].bifoldLeft(axb, acc)(f, g))

  def bifoldRight[A, B, C](fab: EitherT[F, A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
    F0.foldRight(fab.value, c)( (axb, acc) => Bifoldable[Either].bifoldRight(axb, acc)(f, g))
}

private[data] sealed trait EitherTBitraverse[F[_]] extends Bitraverse[EitherT[F, ?, ?]] with EitherTBifoldable[F] {
  override implicit def F0: Traverse[F]

  override def bitraverse[G[_], A, B, C, D](fab: EitherT[F, A, B])(f: A => G[C], g: B => G[D])(implicit G: Applicative[G]): G[EitherT[F, C, D]] =
    fab.bitraverse(f, g)
}

private[data] sealed trait EitherTEq[F[_], L, A] extends Eq[EitherT[F, L, A]] {
  implicit def F0: Eq[F[Either[L, A]]]

  override def eqv(x: EitherT[F, L, A], y: EitherT[F, L, A]): Boolean = x === y
}

private[data] sealed trait EitherTPartialOrder[F[_], L, A] extends PartialOrder[EitherT[F, L, A]] with EitherTEq[F, L, A]{
  override implicit def F0: PartialOrder[F[Either[L, A]]]

  override def partialCompare(x: EitherT[F, L, A], y: EitherT[F, L, A]): Double =
    x partialCompare y
}

private[data] sealed trait EitherTOrder[F[_], L, A] extends Order[EitherT[F, L, A]] with EitherTPartialOrder[F, L, A]{
  override implicit def F0: Order[F[Either[L, A]]]

  override def compare(x: EitherT[F, L, A], y: EitherT[F, L, A]): Int = x compare y
}
package chapter7

import cats.Foldable
import cats.instances.list._
import cats.instances.option._

object Example2 extends App {

  // scala foldLeft
  val scalaFoldLeft = List(1, 2, 3, 4, 5).foldLeft(0)(_ + _)

  // scala-cats foldLeft
  val scalaCatsFoldLeft = Foldable[List].foldLeft(List(1, 2, 3, 4, 5), 0)(_ + _)

  assert(scalaFoldLeft == scalaCatsFoldLeft)

  //scala foldLeft with Option
  val scalaFoldLeftOption = Option(9).foldLeft(10)(_ * _)

  // scala cats foldLeft with Option
  val scalaCatsFoldLeftOption = Foldable[Option].foldLeft(Option(9), 10)(_ * _)

  assert(scalaFoldLeftOption == scalaCatsFoldLeftOption)
}
package io.circe.cats

import io.circe.cats.kernel.Order
import scala.collection.immutable.SortedMap

/**
 * FlatMap type class gives us flatMap, which allows us to have a value
 * in a context (F[A]) and then feed that into a function that takes
 * a normal value and returns a value in a context (A => F[B]).
 *
 * One motivation for separating this out from Monad is that there are
 * situations where we can implement flatMap but not pure.  For example,
 * we can implement map or flatMap that transforms the values of Map[K, *],
 * but we can't implement pure (because we wouldn't know what key to use
 * when instantiating the new Map).
 *
 * @see See [[https://github.com/typelevel/cats/issues/3]] for some discussion.
 *
 * Must obey the laws defined in cats.laws.FlatMapLaws.
 */
trait FlatMap[F[_]] extends Apply[F] {
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]

  /**
   * "flatten" a nested `F` of `F` structure into a single-layer `F` structure.
   *
   * This is also commonly called `join`.
   *
   * Example:
   * {{{
   * scala> import cats.Eval
   * scala> import cats.implicits._
   *
   * scala> val nested: Eval[Eval[Int]] = Eval.now(Eval.now(3))
   * scala> val flattened: Eval[Int] = nested.flatten
   * scala> flattened.value
   * res0: Int = 3
   * }}}
   */
  def flatten[A](ffa: F[F[A]]): F[A] =
    flatMap(ffa)(fa => fa)

  /**
   * Sequentially compose two actions, discarding any value produced by the first. This variant of
   * [[productR]] also lets you define the evaluation strategy of the second action. For instance
   * you can evaluate it only ''after'' the first action has finished:
   *
   * {{{
   * scala> import cats.Eval
   * scala> import cats.implicits._
   * scala> val fa: Option[Int] = Some(3)
   * scala> def fb: Option[String] = Some("foo")
   * scala> fa.productREval(Eval.later(fb))
   * res0: Option[String] = Some(foo)
   * }}}
   */
  def productREval[A, B](fa: F[A])(fb: Eval[F[B]]): F[B] = flatMap(fa)(_ => fb.value)

  /**
   * Sequentially compose two actions, discarding any value produced by the second. This variant of
   * [[productL]] also lets you define the evaluation strategy of the second action. For instance
   * you can evaluate it only ''after'' the first action has finished:
   *
   * {{{
   * scala> import cats.Eval
   * scala> import cats.implicits._
   * scala> var count = 0
   * scala> val fa: Option[Int] = Some(3)
   * scala> def fb: Option[Unit] = Some(count += 1)
   * scala> fa.productLEval(Eval.later(fb))
   * res0: Option[Int] = Some(3)
   * scala> assert(count == 1)
   * scala> none[Int].productLEval(Eval.later(fb))
   * res1: Option[Int] = None
   * scala> assert(count == 1)
   * }}}
   */
  def productLEval[A, B](fa: F[A])(fb: Eval[F[B]]): F[A] = flatMap(fa)(a => map(fb.value)(_ => a))

  override def ap[A, B](ff: F[A => B])(fa: F[A]): F[B] =
    flatMap(ff)(f => map(fa)(f))

  override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
    flatMap(fa)(a => map(fb)(b => (a, b)))

  override def ap2[A, B, Z](ff: F[(A, B) => Z])(fa: F[A], fb: F[B]): F[Z] =
    flatMap(fa)(a => flatMap(fb)(b => map(ff)(_(a, b))))

  override def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] =
    flatMap(fa)(a => map(fb)(b => f(a, b)))

  override def productR[A, B](fa: F[A])(fb: F[B]): F[B] =
    flatMap(fa)(_ => fb)

  override def productL[A, B](fa: F[A])(fb: F[B]): F[A] =
    map2(fa, fb)((a, _) => a)

  /**
   * Pair `A` with the result of function application.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> List("12", "34", "56").mproduct(_.toList)
   * res0: List[(String, Char)] = List((12,1), (12,2), (34,3), (34,4), (56,5), (56,6))
   * }}}
   */
  def mproduct[A, B](fa: F[A])(f: A => F[B]): F[(A, B)] =
    flatMap(fa)(a => map(f(a))((a, _)))

  /**
   * `if` lifted into monad.
   */
  def ifM[B](fa: F[Boolean])(ifTrue: => F[B], ifFalse: => F[B]): F[B] =
    flatMap(fa)(if (_) ifTrue else ifFalse)

  /**
   * Keeps calling `f` until a `scala.util.Right[B]` is returned.
   *
   * Based on Phil Freeman's
   * [[http://functorial.com/stack-safety-for-free/index.pdf Stack Safety for Free]].
   *
   * Implementations of this method should use constant stack space relative to `f`.
   */
  def tailRecM[A, B](a: A)(f: A => F[Either[A, B]]): F[B]

  /**
   * Apply a monadic function and discard the result while keeping the effect.
   *
   * {{{
   * scala> import cats._, implicits._
   * scala> Option(1).flatTap(_ => None)
   * res0: Option[Int] = None
   * scala> Option(1).flatTap(_ => Some("123"))
   * res1: Option[Int] = Some(1)
   * scala> def nCats(n: Int) = List.fill(n)("cat")
   * nCats: (n: Int)List[String]
   * scala> List[Int](0).flatTap(nCats)
   * res2: List[Int] = List()
   * scala> List[Int](4).flatTap(nCats)
   * res3: List[Int] = List(4, 4, 4, 4)
   * }}}
   */
  def flatTap[A, B](fa: F[A])(f: A => F[B]): F[A] =
    flatMap(fa)(a => as(f(a), a))
}

object FlatMap {  
  def apply[F[_]] given (F: FlatMap[F]): FlatMap[F] = F

  private[cats] trait Ops {
    given [F[_], A] given (F: FlatMap[F]) {
      def (fa: F[A]) flatMap[B](f: A => F[B]): F[B] = F.flatMap(fa)(f)
      def (fa: F[A]) productREval[B](fb: Eval[F[B]]): F[B] = F.productREval(fa)(fb)
      def (fa: F[A]) productLEval[B](fb: Eval[F[B]]): F[A] = F.productLEval(fa)(fb)
      def (fa: F[A]) mproduct[B](f: A => F[B]): F[(A, B)] = F.mproduct(fa)(f)
      def (fa: F[A]) flatTap[B](f: A => F[B]): F[A] = F.flatTap(fa)(f)
    }

    given [F[_]] given (F: FlatMap[F]) {
      def (fa: F[Boolean]) ifM[B](ifTrue: => F[B], ifFalse: => F[B]): F[B] = F.ifM(fa)(ifTrue, ifFalse)
    }
  }
}package cats

import simulacrum.{noop, typeclass}

/**
 * Functor.
 *
 * The name is short for "covariant functor".
 *
 * Must obey the laws defined in cats.laws.FunctorLaws.
 */
@typeclass trait Functor[F[_]] extends Invariant[F] { self =>
  def map[A, B](fa: F[A])(f: A => B): F[B]

  override def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B] = map(fa)(f)

  // derived methods

  /**
   * Alias for [[map]], since [[map]] can't be injected as syntax if
   * the implementing type already had a built-in `.map` method.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val m: Map[Int, String] = Map(1 -> "hi", 2 -> "there", 3 -> "you")
   *
   * scala> m.fmap(_ ++ "!")
   * res0: Map[Int,String] = Map(1 -> hi!, 2 -> there!, 3 -> you!)
   * }}}
   */
  final def fmap[A, B](fa: F[A])(f: A => B): F[B] = map(fa)(f)

  /**
   * Lifts natural subtyping covariance of covariant Functors.
   *
   * NOTE: In certain (perhaps contrived) situations that rely on universal
   * equality this can result in a `ClassCastException`, because it is
   * implemented as a type cast. It could be implemented as `map(identity)`, but
   * according to the functor laws, that should be equal to `fa`, and a type
   * cast is often much more performant.
   * See [[https://github.com/typelevel/cats/issues/1080#issuecomment-225892635 this example]]
   * of `widen` creating a `ClassCastException`.
   *
   * Example:
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForOption
   *
   * scala> val s = Some(42)
   * scala> Functor[Option].widen(s)
   * res0: Option[Int] = Some(42)
   * }}}
   */
  def widen[A, B >: A](fa: F[A]): F[B] = fa.asInstanceOf[F[B]]

  /**
   * Lift a function f to operate on Functors
   *
   * Example:
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForOption
   *
   * scala> val o = Option(42)
   * scala> Functor[Option].lift((x: Int) => x + 10)(o)
   * res0: Option[Int] = Some(52)
   * }}}
   */
  def lift[A, B](f: A => B): F[A] => F[B] = map(_)(f)

  /**
   * Empty the fa of the values, preserving the structure
   *
   * Example:
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForList
   *
   * scala> Functor[List].void(List(1,2,3))
   * res0: List[Unit] = List((), (), ())
   * }}}
   */
  def void[A](fa: F[A]): F[Unit] = as(fa, ())

  /**
   * Tuple the values in fa with the result of applying a function
   * with the value
   *
   * Example:
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForOption
   *
   * scala> Functor[Option].fproduct(Option(42))(_.toString)
   * res0: Option[(Int, String)] = Some((42,42))
   * }}}
   */
  def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)] = map(fa)(a => a -> f(a))

  /**
   * Replaces the `A` value in `F[A]` with the supplied value.
   *
   * Example:
   *
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForList
   *
   * scala> Functor[List].as(List(1,2,3), "hello")
   * res0: List[String] = List(hello, hello, hello)
   * }}}
   */
  def as[A, B](fa: F[A], b: B): F[B] = map(fa)(_ => b)

  /**
   * Tuples the `A` value in `F[A]` with the supplied `B` value, with the `B` value on the left.
   *
   * Example:
   * {{{
   * scala> import scala.collection.immutable.Queue
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForQueue
   *
   * scala> Functor[Queue].tupleLeft(Queue("hello", "world"), 42)
   * res0: scala.collection.immutable.Queue[(Int, String)] = Queue((42,hello), (42,world))
   * }}}
   */
  def tupleLeft[A, B](fa: F[A], b: B): F[(B, A)] = map(fa)(a => (b, a))

  /**
   * Tuples the `A` value in `F[A]` with the supplied `B` value, with the `B` value on the right.
   *
   * Example:
   * {{{
   * scala> import scala.collection.immutable.Queue
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForQueue
   *
   * scala> Functor[Queue].tupleRight(Queue("hello", "world"), 42)
   * res0: scala.collection.immutable.Queue[(String, Int)] = Queue((hello,42), (world,42))
   * }}}
   */
  def tupleRight[A, B](fa: F[A], b: B): F[(A, B)] = map(fa)(a => (a, b))

  /**
   * Un-zips an `F[(A, B)]` consisting of element pairs or Tuple2 into two separate F's tupled.
   *
   * NOTE: Check for effect duplication, possibly memoize before
   *
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForList
   *
   * scala> Functor[List].unzip(List((1,2), (3, 4)))
   * res0: (List[Int], List[Int]) = (List(1, 3),List(2, 4))
   * }}}
   *
   */
  @noop
  def unzip[A, B](fab: F[(A, B)]): (F[A], F[B]) = (map(fab)(_._1), map(fab)(_._2))

  /**
   * Lifts `if` to Functor
   *
   * Example:
   * {{{
   * scala> import cats.Functor
   * scala> import cats.implicits.catsStdInstancesForList
   *
   * scala> Functor[List].ifF(List(true, false, false))(1, 0)
   * res0: List[Int] = List(1, 0, 0)
   * }}}
   */
  def ifF[A](fb: F[Boolean])(ifTrue: => A, ifFalse: => A): F[A] = map(fb)(x => if (x) ifTrue else ifFalse)

  def compose[G[_]: Functor]: Functor[λ[α => F[G[α]]]] =
    new ComposedFunctor[F, G] {
      val F = self
      val G = Functor[G]
    }

  override def composeContravariant[G[_]: Contravariant]: Contravariant[λ[α => F[G[α]]]] =
    new ComposedCovariantContravariant[F, G] {
      val F = self
      val G = Contravariant[G]
    }
}
package io.circe.cats

import io.circe.cats.kernel.Order
import scala.collection.immutable.SortedMap

/**
 * `FunctorFilter[F]` allows you to `map` and filter out elements simultaneously.
 */
trait FunctorFilter[F[_]] extends Serializable {
  def functor: Functor[F]

  /**
   * A combined `map` and `filter`. Filtering is handled via `Option`
   * instead of `Boolean` such that the output type `B` can be different than
   * the input type `A`.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> val m: Map[Int, String] = Map(1 -> "one", 3 -> "three")
   * scala> val l: List[Int] = List(1, 2, 3, 4)
   * scala> def asString(i: Int): Option[String] = m.get(i)
   * scala> l.mapFilter(i => m.get(i))
   * res0: List[String] = List(one, three)
   * }}}
   */
  def mapFilter[A, B](fa: F[A])(f: A => Option[B]): F[B]

  /**
   * Similar to [[mapFilter]] but uses a partial function instead of a function
   * that returns an `Option`.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> val l: List[Int] = List(1, 2, 3, 4)
   * scala> FunctorFilter[List].collect(l){
   *      |   case 1 => "one"
   *      |   case 3 => "three"
   *      | }
   * res0: List[String] = List(one, three)
   * }}}
   */
  def collect[A, B](fa: F[A])(f: PartialFunction[A, B]): F[B] =
    mapFilter(fa)(f.lift)

  /**
   * "Flatten" out a structure by collapsing `Option`s.
   * Equivalent to using `mapFilter` with `identity`.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> val l: List[Option[Int]] = List(Some(1), None, Some(3), None)
   * scala> l.flattenOption
   * res0: List[Int] = List(1, 3)
   * }}}
   */
  def flattenOption[A](fa: F[Option[A]]): F[A] =
    mapFilter(fa)(identity)

  /**
   * Apply a filter to a structure such that the output structure contains all
   * `A` elements in the input structure that satisfy the predicate `f` but none
   * that don't.
   */
  def filter[A](fa: F[A])(f: A => Boolean): F[A] =
    mapFilter(fa)(a => if (f(a)) Some(a) else None)
}

object FunctorFilter {
  def apply[F[_]] given (F: FunctorFilter[F]): FunctorFilter[F] = F

  given as TraverseFilter[List] = io.circe.cats.instances.ListInstance
  given as TraverseFilter[Vector] = io.circe.cats.instances.VectorInstance
  given as TraverseFilter[Stream] = io.circe.cats.instances.StreamInstance
  given as TraverseFilter[Option] = io.circe.cats.instances.OptionInstance
  given [K] as TraverseFilter[[x] =>> SortedMap[K, x]] given Order[K] = io.circe.cats.instances.SortedMapInstance[K]

  private[cats] trait Ops {
    given [F[_], A] given (F: FunctorFilter[F]) {
      def (fa: F[A]) mapFilter[B](f: A => Option[B]): F[B] = F.mapFilter(fa)(f)
      def (fa: F[A]) collect[B](f: PartialFunction[A, B]): F[B] = F.collect(fa)(f)
      def (fa: F[A]) filter(f: A => Boolean): F[A] = F.filter(fa)(f)
    }
  }
}
package hammock

import cats.syntax.show._
import cats.free.Free

import hi.Opts
import Encoder.ops._

object Hammock {

  /** Creates an [[HttpF]] and from the
   * [[Method]], [[Uri]], and [[Map[String, String] headers]].  It
   * can be later executed via an interpreter.
   */
  def request(method: Method, uri: Uri, headers: Map[String, String]): Free[HttpF, HttpResponse] = method match {
    case Method.OPTIONS => Ops.options(uri, headers)
    case Method.GET     => Ops.get(uri, headers)
    case Method.HEAD    => Ops.head(uri, headers)
    case Method.POST    => Ops.post(uri, headers, None)
    case Method.PUT     => Ops.put(uri, headers, None)
    case Method.DELETE  => Ops.delete(uri, headers)
    case Method.TRACE   => Ops.trace(uri, headers)
    case Method.PATCH   => Ops.patch(uri, headers, None)
  }

  /** similar to [[request]], but you can pass it a
   * body when it exists an instance for the [[Encoder]]
   * typeclass for the given type [[A]]
   */
  def request[A: Encoder](
      method: Method,
      uri: Uri,
      headers: Map[String, String],
      body: Option[A]): Free[HttpF, HttpResponse] = method match {
    case Method.OPTIONS => Ops.options(uri, headers)
    case Method.GET     => Ops.get(uri, headers)
    case Method.HEAD    => Ops.head(uri, headers)
    case Method.POST    => Ops.post(uri, headers, body.map(x => x.encode))
    case Method.PUT     => Ops.put(uri, headers, body.map(x => x.encode))
    case Method.DELETE  => Ops.delete(uri, headers)
    case Method.TRACE   => Ops.trace(uri, headers)
    case Method.PATCH   => Ops.patch(uri, headers, body.map(x => x.encode))
  }

  /** Creates a request value given a [[Method method]], [[Uri uri]], and [[hi.Opts opts]], and suspends it into a [[cats.free.Free]].
   *
   * Usage:
   *
   * {{{
   * scala> import hammock._, hammock.jvm.Interpreter, hammock.hi._, hammock.hi._, cats._, cats.implicits._, scala.util.Try
   * import hammock._
   * import hammock.jvm.Interpreter
   * import hammock.hi._
   * import cats._
   * import cats.implicits._
   * import scala.util.Try
   *
   * scala> val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   * opts: hammock.hi.Opts = Opts(Some(BasicAuth(user,pass)),Map(X-Test -> works!),Some(List(Cookie(key,value,None,None,None,None,None,None,None,None))))
   *
   * scala> val response = Hammock.withOpts(Method.GET, uri"http://httpbin.org/get", opts)
   * response: Free[HttpF, hammock.HttpResponse] = Free(...)
   * }}}
   *
   */
  def withOpts(method: Method, uri: Uri, opts: Opts): Free[HttpF, HttpResponse] =
    request(method, uri, constructHeaders(opts))

  /** Variant of [[withOpts]] methods that also takes an optional body
   * of a request. There should be a Encoder instance for the body type
   * for this to work.
   *
   * @see Hammock.withOpts
   */
  def withOpts[A: Encoder](method: Method, uri: Uri, opts: Opts, body: Option[A]): Free[HttpF, HttpResponse] =
    request(method, uri, constructHeaders(opts), body)

  /** Creates an OPTIONS request to the given [[Uri uri]] and [[hi.Opts opts]].
   *
   * {{{
   * scala> import hammock._, hammock.jvm.Interpreter, hammock.hi._, hammock.hi._, cats._, cats.implicits._, scala.util.Try
   * import hammock._
   * import hammock.jvm.Interpreter
   * import hammock.hi._
   * import cats._
   * import cats.implicits._
   * import scala.util.Try
   *
   * scala> val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   * opts: hammock.hi.Opts = Opts(Some(BasicAuth(user,pass)),Map(X-Test -> works!),Some(List(Cookie(key,value,None,None,None,None,None,None,None,None))))
   *
   * scala> Hammock.optionsWithOpts(uri"http://httpbin.org/get", opts)
   * res1: Free[HttpF, hammock.HttpResponse] = Free(...)
   * }}}
   *
   */
  def optionsWithOpts(uri: Uri, opts: Opts): Free[HttpF, HttpResponse] = withOpts(Method.OPTIONS, uri, opts)

  /** Creates a GET request to the given [[Uri uri]] and [[hi.Opts opts]].
   *
   * {{{
   * scala> import hammock._, hammock.jvm.Interpreter, hammock.hi._, hammock.hi._, cats._, cats.implicits._, scala.util.Try
   * import hammock._
   * import hammock.jvm.Interpreter
   * import hammock.hi._
   * import cats._
   * import cats.implicits._
   * import scala.util.Try
   *
   * scala> val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   * opts: hammock.hi.Opts = Opts(Some(BasicAuth(user,pass)),Map(X-Test -> works!),Some(List(Cookie(key,value,None,None,None,None,None,None,None,None))))
   *
   * scala> Hammock.getWithOpts(uri"http://httpbin.org/get", opts)
   * res1: Free[HttpF, hammock.HttpResponse] = Free(...)
   * }}}
   *
   */
  def getWithOpts(uri: Uri, opts: Opts): Free[HttpF, HttpResponse] = withOpts(Method.GET, uri, opts)

  /** Creates a HEAD request to the given [[Uri uri]] and [[hi.Opts opts]].
   *
   * {{{
   * import hammock._
   * import hammock.jvm.Interpreter
   * import hammock.hi._
   * import cats._
   * import cats.implicits._
   * import scala.util.Try
   *
   * val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   *
   * Hammock.headWithOpts(uri"http://httpbin.org/get", opts)
   * }}}
   *
   */
  def headWithOpts(uri: Uri, opts: Opts): Free[HttpF, HttpResponse] = withOpts(Method.HEAD, uri, opts)

  /** Creates a POST request to the given [[Uri uri]] and [[hi.Opts opts]].
   * It also has an optional body parameter that can be
   * used.
   *
   * {{{
   * import hammock._
   * import hammock.jvm.Interpreter
   * import hammock.hi._
   * import cats._
   * import cats.implicits._
   * import scala.util.Try
   *
   * val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   *
   * implicit val stringEncoder = new Encoder[String] {
   *    def encode(s: String) = s
   * }
   *
   * Hammock.postWithOpts(uri"http://httpbin.org/get", opts, Some("""{"body": true}"""))
   * }}}
   */
  def postWithOpts[A: Encoder](uri: Uri, opts: Opts, body: Option[A] = None): Free[HttpF, HttpResponse] =
    withOpts(Method.POST, uri, opts, body)

  /** Creates a PUT request to the given [[Uri uri]] and [[hi.Opts opts]].
   * It also has an optional body parameter that can be
   * used.
   *
   * {{{
   * import hammock._
   * import hammock.jvm.Interpreter
   * import hammock.hi._
   * import cats._
   * import cats.implicits._
   * import scala.util.Try
   *
   * val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   *
   * implicit val stringEncoder = new Encoder[String] {
   *    def encode(s: String) = s
   * }
   *
   * Hammock.postWithOpts(uri"http://httpbin.org/get", opts, Some("""{"body": true}"""))
   * }}}
   *
   */
  def putWithOpts[A: Encoder](uri: Uri, opts: Opts, body: Option[A] = None): Free[HttpF, HttpResponse] =
    withOpts(Method.PUT, uri, opts, body)

  /** Creates a DELETE request to the given [[Uri uri]] and [[hi.Opts opts]].
   *
   * {{{
   * val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   *
   * Hammock.deleteWithOpts(uri"http://httpbin.org/get", opts)
   * }}}
   *
   */
  def deleteWithOpts(uri: Uri, opts: Opts): Free[HttpF, HttpResponse] = withOpts(Method.DELETE, uri, opts)

  /** Creates a TRACE request to the given [[Uri uri]] and [[hi.Opts opts]].
   *
   * {{{
   * val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
   *
   * Hammock.traceWithOpts(uri"http://httpbin.org/get", opts)
   * }}}
   *
   */
  def traceWithOpts(uri: Uri, opts: Opts): Free[HttpF, HttpResponse] = withOpts(Method.TRACE, uri, opts)

  /** Creates a PATCH request to the given [[Uri uri]] and [[hi.Opts opts]].
    * It also has an optional body parameter that can be
    * used.
    *
    * {{{
    * import hammock._
    * import hammock.jvm.Interpreter
    * import hammock.hi._
    * import cats._
    * import cats.implicits._
    * import scala.util.Try
    *
    * val opts = (header("X-Test" -> "works!") >>> auth(Auth.BasicAuth("user", "pass")) >>> cookie(Cookie("key", "value")))(Opts.empty)
    *
    * implicit val stringCodec = new Codec[String] {
    *    def encode(s: String) = s
    *    def decode(s: String) = Right(s)
    * }
    *
    * Hammock.patchWithOpts(uri"http://httpbin.org/patch", opts, Some("""{"body": true}"""))
    * }}}
    *
    */
  def patchWithOpts[A: Codec](uri: Uri, opts: Opts, body: Option[A] = None): Free[HttpF, HttpResponse] =
    withOpts(Method.PATCH, uri, opts, body)

  private def constructHeaders(opts: Opts) =
    opts.headers ++
      opts.cookies.map(_.map(cookie => "Set-Cookie" -> cookie.show)).getOrElse(Map()) ++
      opts.auth.map(auth => Map("Authorization"    -> auth.show)).getOrElse(Map())
}

import PresentationUtil._
import japgolly.scalajs.react.ScalaComponent
import japgolly.scalajs.react.vdom.html_<^._
import org.scalajs.dom

import scala.scalajs.js.JSApp
import scala.scalajs.js.annotation.JSExport

object IOLecture extends JSApp {

  import Enumeration._

  val overview = chapter(
    chapterSlide(
      <.h1("IO")
    ),

    slide(
      "What we will learn in this lecture",
      Enumeration(
        Item.stable("Cats Effect IO"),
        Item.fadeIn("Shared State")
      )
    )
  )

  val io = chapter(
    chapterSlide(
      <.h2("Cats Effect IO")
    ),

    noHeaderSlide(
      <.a(
        ^.href := "https://github.com/typelevel/cats-effect",
        "https://github.com/typelevel/cats-effect"
      )
    ),

    slide(
      "Cats Effect IO",
      <.p("Provides an implementation of the described IO concept to handle side effects (and more).")
    ),

    slide(
      "Side Effect Example",
      scalaC("""
        // idea
        for {
          name <- readLine()
           
          _    <- println("Hello" + name)
        } yield () //: IO[Unit]
      """)
    ),

    slide(
      "Side Effect Example",
      scalaC("""
        // code
        import cats.effects.IO

        val appIO = for {
          name <- IO(readLine())
           
          _    <- IO(println("Hello" + name))
        } yield ()
      """)
    ),

    slide(
      "Cats Effect IO",
      <.p("IO is a Monad and comes with all its properties."),
      <.br,
      scalaC("""
        IO.pure(0) // never put side-effects here

        IO(readLine()).flatMap(name => println("Hello " + name)
      """)
    ),
   
    slide(
      "Cats Effect IO",
      <.p("We got an ", <.strong("appIO: IO[Unit]"), ". Nothing happend. What want action.")
    ),

    slide(
      "Cats Effect IO: run",
      scalaC("""
        // danger-zone - blocks, throws Exceptions ... impure 
        appIO.unsafeRunSync()
        // $ Gandalf
        // $ Hello Gandalf
      """),
      scalaCFragment("""
        appIO.unsafeRunSync()
        // $ Frodo
        // $ Hello Frodo
      """)
    ),

    slide(
      "Cats Effect IO: run", 
      scalaC("""
        appIO.unsafeRunTimed(FiniteDuration(5, SECONDS)
      """)
    ),

    slide(
      "Cats Effect IO: run", 
      scalaC("""
        appIO.unsafeRunAsync {
          case Right(a)    => ???
          case Left(error) => ???
        }
      """)
    ),

    slide(
      "Cats Effect IO: run",
      <.p("There are more ways to run an IO. Take a look into the documentation.")
    ),

    slide(
      "Cats Effect IO: run",
      <.p("But, you can also move the IO execution part out of your program into ", <.strong("IOApp"), ".")
    ),

    slide(
      "Cats Effect IO: run",
      scalaC("""
        import cats.effect.{IOApp, ExitCode}

        object App extends IOApp {

          def run(args: List[String]): IO[ExitCode] = 
            appIO.map(_ => ExitCode.Success)
        }
      """)
    ),
  
    noHeaderSlide(
      <.h3("But wait there is more")
    ),

    slide(
      "Cats Effect IO: stack-safety",
      <.h4("Stack-Safety"),
      <.br,
      scalaC("""
        def replicate[A](n: Int, a: A): List[A] = 
          if (n > 0) a :: replicate(n - 1, a)
          else       Nil

        
        // blows up our program
        replicate(100000, 0)
      """)
    ),

    slide(
      "Cats Effect IO: stack-safety",
      <.h4("Stack-Safety"),
      <.br,
      scalaC("""
        def replicate[A](n: Int, a: A): IO[List[A]] = 
          if (n > 0) replicate(n - 1, a).map(tail => a :: tail)
          else       IO.pure(Nil)

      """),
      scalaCFragment("""
        // still blows up
        replicate(100000, 0)
      """)
    ),

    slide(
      "Cats Effect IO: stack-safety",
      scalaC("""
        // postpones IO creation
        IO.suspend[A](thunk: => IO[A]): IO[A]
      """)
    ),

    slide(
      "Cats Effect IO: stack-safety",
      scalaC("""
        def replicate[A](n: Int, a: A): IO[List[A]] = 
          if (n > 0) IO.suspend(replicate(n - 1, a).map(tail => a :: tail))
          else       IO.pure(Nil)
      """),
      scalaCFragment("""
        // fine
        replicate(100000, 0)
      """)
    ),

    noHeaderSlide(
      <.h3("Resource Management")
    ),

    slide(
      "Cats Effect IO: brackets",
      <.p("Often you acquire some resource (web socket, db connection, etc.) to do IO. But how to guarantee a proper handling?")
    ),

    slide(
      "Cats Effect IO: brackets",
      scalaC("""
        val resource = IO(new BufferedReader(...))

        resource.bracket(
          // use resource
          buf => {
          val line = buf.readLine()
          ...
          },
          // release it
          buf => {
            IO(buf.close())
          }
        )
      """)
    ),

    slide(
      "Cats Effect IO: brackets",
      <.p("Brackets ensure that your resources are released even when an error occurs.")
    ),

    noHeaderSlide(
      <.h3("Error Handling")
    ),

    slide(
      "Cats Effect IO: error handling",
      scalaC("""
        // can fail if the given resource (e.g. file) doesn't exist
        val acquire = IO(new BufferedInputStream(...))
      """)
    ),

    slide(
      "Cats Effect IO: error handling",
      <.p("In case of an error IO will fail all computations until the it is recovered or the execution point is reached.")
    ),

    slide(
      "Cats Effect IO: error handling",
      scalaC("""
        acquire.handleErrorWith(
          case cause: FileNotFoundException => IO(???)           
        )
      """)
    ),

    slide(
      "Cats Effect IO: error handling",
      scalaC("""
        acquire.attempt.map(
          case Right(a)    => ???
          case Left(cause) => ???
        )
      """)
    ),

    slide(
      "Cats Effect IO",
      <.p("There is way more to IO ..."),
      Enumeration(
        Item.stable("concurrency"),
        Item.fadeIn("asynchronous computations"),
        Item.fadeIn("computational resource control"),
        Item.fadeIn("and more")
      )
    ),

    exerciseSlide(
      "Let's Code",
      <.p("I created a dirty, impure app. Make it nice and shiny (read functional) using IO.")
    )
  )

  val sharedState = chapter(
    chapterSlide(
      <.h2("Shared State")
    ),

    slide(
      "Shared State",
      <.p("Sometimes it is not feasable to have immutable or local state.")
    ),

    noHeaderSlide(
      <.h3("MVar & Ref")
    ),

    slide(
      "Shared State",
      scalaC("""
        // block until channel is empty
        def produce(ch: Channel, users: List[User]): IO[Unit] = users match {
          case user :: tail => 
            ch.put(Some(user)).flatMap(_ => produce(ch, tail))

          case Nil => ch.put(None)
        }
      """),
      scalaCFragment("""
        // block until channel is full
        def consume(ch: Channel): IO[List[User]] = 
          ch.take.flatMap {
            case Some(user) => consumer(ch).map(tail => user :: tail))
            case None       => IO.pure(Nil)
          }
      """)
    ),

    slide(
      "Shared State",
      scalaC("""
        val ch = ???

        // thread A
        produce(ch, List(User("Gandalf", 2019), ...))

        ...

        // thread B
        consume(ch)
      """)
    ),

    noHeaderSlide(
      <.h3("Make this work with MVar")
    ),

    slide(
      "Shared State: MVar",
      scalaC("""
        for {
          ch <- MVar[IO].empty[Option[User]]

          // run concurrently
          prod <- produce(ch, List(User("Gandalf", 2019), ...)).start
          cons <- consumer(ch).start

          _     <- prod.join
          users <- cons.join
        } yield users
      """)
    ),

    slide(
      "Shared State: MVar",
      Enumeration(
        Item.stable("is a shared piece of memory"),
        Item.fadeIn("synchronized, thread-safe, mutable"),
        Item.fadeIn("you can also just `read`")
      )
    ),

    noHeaderSlide(
      <.h3("I need no synchronization"),
      <.br,
      <.h4("Ref")
    ),

    slide(
      "Shared State: Ref",
      scalaC("""
        for {
          counter <- Ref.of[IO, Int](0)

          // run concurrently
          a <- IO(counter.update(_ + 1)).start
          b <- IO(counter.update(_ + 1)).start

          a.join
          b.join

          c <- counter.get()
        } yield c
      """)
    ),

    slide(
      "Shared State",
      <.p("Again, there is way more stuff in the library. Just take a look.")
    )
  )

  val summary = chapter(
    chapterSlide(
      <.h2("Summary")
    ),

    slide(
      "Cats Effect IO",
      <.p("Use IO to make side effects referential transparent."),
      <.br,
      scalaC("""
        def hello  = IO(println("hello, world!"))

        val helloV = hello

        {hello; hello} == {helloV; helloV}
      """)
    ),

    slide(
      "cats Effect IO",
      <.p("Use it for resource management, error handling and much more.")
    ),

    slide(
      "Shared State",
      <.p("User MVar and Ref to represent shared state.")
    )
  )

  val Show = ScalaComponent
    .builder[Unit]("Slideshow")
    .renderStatic(
      <.div(
        ^.cls := "reveal",
        <.div(
          ^.cls := "slides",
          overview,
          io,
          sharedState,
          summary
        )
      )
    )
    .build

  @JSExport
  override def main(): Unit = {
    Show().renderIntoDOM(dom.document.body)
  }
}
package cats
package data

import cats.arrow.FunctionK
import cats.syntax.either._
import cats.syntax.option._

final case class IorT[F[_], A, B](value: F[Ior[A, B]]) {

  def fold[C](fa: A => C, fb: B => C, fab: (A, B) => C)(implicit F: Functor[F]): F[C] =
    F.map(value)(_.fold(fa, fb, fab))

  def isLeft(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.isLeft)

  def isRight(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.isRight)

  def isBoth(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.isBoth)

  def swap(implicit F: Functor[F]): IorT[F, B, A] = IorT(F.map(value)(_.swap))

  def getOrElse[BB >: B](default: => BB)(implicit F: Functor[F]): F[BB] = F.map(value)(_.getOrElse(default))

  def getOrElseF[BB >: B](default: => F[BB])(implicit F: Monad[F]): F[BB] =
    F.flatMap(value) {
      case Ior.Left(_)    => default
      case Ior.Right(b)   => F.pure(b)
      case Ior.Both(_, b) => F.pure(b)
    }

  def valueOr[BB >: B](f: A => BB)(implicit F: Functor[F], BB: Semigroup[BB]): F[BB] = F.map(value)(_.valueOr(f))

  def forall(f: B => Boolean)(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.forall(f))

  def exists(f: B => Boolean)(implicit F: Functor[F]): F[Boolean] = F.map(value)(_.exists(f))

  def toOption(implicit F: Functor[F]): OptionT[F, B] = OptionT(F.map(value)(_.toOption))

  def toEither(implicit F: Functor[F]): EitherT[F, A, B] = EitherT(F.map(value)(_.toEither))

  def toNested: Nested[F, Ior[A, *], B] = Nested[F, Ior[A, *], B](value)

  def toNestedValidated(implicit F: Functor[F]): Nested[F, Validated[A, *], B] =
    Nested[F, Validated[A, *], B](F.map(value)(_.toValidated))

  def toValidated(implicit F: Functor[F]): F[Validated[A, B]] = F.map(value)(_.toValidated)

  def to[G[_]](implicit F: Functor[F], G: Alternative[G]): F[G[B]] = F.map(value)(_.to[G, B])

  def collectRight(implicit FA: Alternative[F], FM: FlatMap[F]): F[B] = FM.flatMap(value)(_.to[F, B])

  def merge[AA >: A](implicit ev: B <:< AA, F: Functor[F], AA: Semigroup[AA]): F[AA] = F.map(value)(_.merge(ev, AA))

  def show(implicit show: Show[F[Ior[A, B]]]): String = show.show(value)

  def map[D](f: B => D)(implicit F: Functor[F]): IorT[F, A, D] = IorT(F.map(value)(_.map(f)))

  def mapK[G[_]](f: F ~> G): IorT[G, A, B] = IorT[G, A, B](f(value))

  def bimap[C, D](fa: A => C, fb: B => D)(implicit F: Functor[F]): IorT[F, C, D] = IorT(F.map(value)(_.bimap(fa, fb)))

  def leftMap[C](f: A => C)(implicit F: Functor[F]): IorT[F, C, B] = IorT(F.map(value)(_.leftMap(f)))

  def leftFlatMap[BB >: B, C](f: A => IorT[F, C, BB])(implicit F: Monad[F], BB: Semigroup[BB]): IorT[F, C, BB] =
    IorT(F.flatMap(value) {
      case Ior.Left(a)      => f(a).value
      case r @ Ior.Right(_) => F.pure(r.asInstanceOf[Ior[C, BB]])
      case Ior.Both(a, b) =>
        F.map(f(a).value) {
          case Ior.Left(c)     => Ior.Both(c, b)
          case Ior.Right(b1)   => Ior.Right(BB.combine(b, b1))
          case Ior.Both(c, b1) => Ior.Both(c, BB.combine(b, b1))
        }
    })

  def leftSemiflatMap[C](f: A => F[C])(implicit F: Monad[F]): IorT[F, C, B] =
    IorT(F.flatMap(value) {
      case Ior.Left(a)      => F.map(f(a))(Ior.Left(_))
      case r @ Ior.Right(_) => F.pure(r.asInstanceOf[Ior[C, B]])
      case Ior.Both(a, b)   => F.map(f(a))(Ior.Both(_, b))
    })

  def transform[C, D](f: Ior[A, B] => Ior[C, D])(implicit F: Functor[F]): IorT[F, C, D] = IorT(F.map(value)(f))

  def applyAlt[D](ff: IorT[F, A, B => D])(implicit F: Apply[F], A: Semigroup[A]): IorT[F, A, D] =
    IorT[F, A, D](F.map2(value, ff.value)((iorb, iorbd) => Apply[Ior[A, *]].ap(iorbd)(iorb)))

  def flatMap[AA >: A, D](f: B => IorT[F, AA, D])(implicit F: Monad[F], AA: Semigroup[AA]): IorT[F, AA, D] =
    IorT(F.flatMap(value) {
      case l @ Ior.Left(_) => F.pure(l.asInstanceOf[Ior[AA, D]])
      case Ior.Right(b)    => f(b).value
      case Ior.Both(a, b) =>
        F.map(f(b).value) {
          case Ior.Left(a1)    => Ior.Left(AA.combine(a, a1))
          case Ior.Right(d)    => Ior.Both(a, d)
          case Ior.Both(a1, d) => Ior.Both(AA.combine(a, a1), d)
        }
    })

  def flatMapF[AA >: A, D](f: B => F[Ior[AA, D]])(implicit F: Monad[F], AA: Semigroup[AA]): IorT[F, AA, D] =
    flatMap(f.andThen(IorT.apply))

  def subflatMap[AA >: A, D](f: B => Ior[AA, D])(implicit F: Functor[F], AA: Semigroup[AA]): IorT[F, AA, D] =
    IorT(F.map(value)(_.flatMap(f)))

  def semiflatMap[D](f: B => F[D])(implicit F: Monad[F]): IorT[F, A, D] =
    IorT(F.flatMap(value) {
      case l @ Ior.Left(_) => F.pure(l.asInstanceOf[Ior[A, D]])
      case Ior.Right(b)    => F.map(f(b))(Ior.right)
      case Ior.Both(a, b)  => F.map(f(b))(Ior.both(a, _))
    })

  def traverse[G[_], D](f: B => G[D])(implicit traverseF: Traverse[F], applicativeG: Applicative[G]): G[IorT[F, A, D]] =
    applicativeG.map(traverseF.traverse(value)(ior => Traverse[Ior[A, *]].traverse(ior)(f)))(IorT.apply)

  def foldLeft[C](c: C)(f: (C, B) => C)(implicit F: Foldable[F]): C =
    F.foldLeft(value, c)((c, ior) => ior.foldLeft(c)(f))

  def foldRight[C](lc: Eval[C])(f: (B, Eval[C]) => Eval[C])(implicit F: Foldable[F]): Eval[C] =
    F.foldRight(value, lc)((ior, lc) => ior.foldRight(lc)(f))

  def ===(that: IorT[F, A, B])(implicit eq: Eq[F[Ior[A, B]]]): Boolean =
    eq.eqv(value, that.value)

  def combine(that: IorT[F, A, B])(implicit F: Apply[F], A: Semigroup[A], B: Semigroup[B]): IorT[F, A, B] =
    IorT(F.map2(this.value, that.value)(_.combine(_)))
}

object IorT extends IorTInstances {

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class LeftPartiallyApplied[B](private val dummy: Boolean = true) extends AnyVal {
    def apply[F[_], A](fa: F[A])(implicit F: Functor[F]): IorT[F, A, B] = IorT(F.map(fa)(Ior.left))
  }

  /**
   * Creates a left version of `IorT[F, A, B]` from a `F[A]`
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.left[Int](Option("err"))
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Left(err)))
   * }}}
   */
  final def left[B]: LeftPartiallyApplied[B] = new LeftPartiallyApplied[B]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class LeftTPartiallyApplied[F[_], B](private val dummy: Boolean = true) extends AnyVal {
    def apply[A](a: A)(implicit F: Applicative[F]): IorT[F, A, B] = IorT(F.pure(Ior.left(a)))
  }

  /**
   * Creates a left version of `IorT[F, A, B]` from a `A`
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.leftT[Option, Int]("err")
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Left(err)))

   * }}}
   */
  final def leftT[F[_], B]: LeftTPartiallyApplied[F, B] = new LeftTPartiallyApplied[F, B]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class RightPartiallyApplied[A](private val dummy: Boolean = true) extends AnyVal {
    def apply[F[_], B](fb: F[B])(implicit F: Functor[F]): IorT[F, A, B] = IorT(F.map(fb)(Ior.right))
  }

  /**
   * Creates a right version of `IorT[F, A, B]` from a `F[B]`
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.right[String](Option(3))
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Right(3)))
   * }}}
   */
  final def right[A]: RightPartiallyApplied[A] = new RightPartiallyApplied[A]

  /**
   * Alias for [[pure]]
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.rightT[Option, String](3)
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Right(3)))
   * }}}
   */
  final def rightT[F[_], A]: PurePartiallyApplied[F, A] = pure

  /**
   * Creates a both version of `IorT[F, A, B]` from a `F[A]` and a `F[B]`
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.both(Option("err"), Option(3))
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Both(err,3)))
   * }}}
   */
  final def both[F[_], A, B](fa: F[A], fb: F[B])(implicit F: Apply[F]): IorT[F, A, B] =
    IorT(F.map2(fa, fb)((a, b) => Ior.Both(a, b)))

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class BothTPartiallyApplied[F[_]](private val dummy: Boolean = true) extends AnyVal {
    def apply[A, B](a: A, b: B)(implicit F: Applicative[F]): IorT[F, A, B] = IorT(F.pure(Ior.Both(a, b)))
  }

  /**
   * Creates a both version of `IorT[F, A, B]` from a `A` and a `B`
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.bothT[Option]("err", 3)
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Both(err,3)))
   * }}}
   */
  final def bothT[F[_]]: BothTPartiallyApplied[F] = new BothTPartiallyApplied[F]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class PurePartiallyApplied[F[_], A](private val dummy: Boolean = true) extends AnyVal {
    def apply[B](b: B)(implicit F: Applicative[F]): IorT[F, A, B] = IorT(F.pure(Ior.right(b)))
  }

  /**
   * Creates a right version of `IorT[F, A, B]` from a `B`
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> IorT.pure[Option, String](3)
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Right(3)))
   * }}}
   */
  final def pure[F[_], A]: PurePartiallyApplied[F, A] = new PurePartiallyApplied[F, A]

  /**
   * Alias for [[right]]
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val o: Option[Int] = Some(3)
   * scala> val n: Option[Int] = None
   * scala> IorT.liftF(o)
   * res0: cats.data.IorT[Option,Nothing,Int] = IorT(Some(Right(3)))
   * scala> IorT.liftF(n)
   * res1: cats.data.IorT[Option,Nothing,Int] = IorT(None)
   * }}}
   */
  final def liftF[F[_], A, B](fb: F[B])(implicit F: Applicative[F]): IorT[F, A, B] = right(fb)

  /**
   * Same as [[liftF]], but expressed as a FunctionK for use with [[IorT.mapK]]
   * {{{
   * scala> import cats._, data._, implicits._
   * scala> val a: OptionT[Eval, Int] = 1.pure[OptionT[Eval, *]]
   * scala> val b: OptionT[IorT[Eval, String, *], Int] = a.mapK(IorT.liftK)
   * scala> b.value.value.value
   * res0: cats.data.Ior[String,Option[Int]] = Right(Some(1))
   * }}}
   */
  final def liftK[F[_], A](implicit F: Functor[F]): F ~> IorT[F, A, *] =
    new (F ~> IorT[F, A, *]) {
      def apply[B](fb: F[B]): IorT[F, A, B] = right(fb)
    }

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class FromIorPartiallyApplied[F[_]](private val dummy: Boolean = true) extends AnyVal {
    def apply[A, B](ior: Ior[A, B])(implicit F: Applicative[F]): IorT[F, A, B] = IorT(F.pure(ior))
  }

  /**
   * Transforms an `Ior` into an `IorT`, lifted into the specified `Applicative`.
   * {{{
   * scala> import cats.data.{IorT, Ior}
   * scala> import cats.implicits._
   * scala> val i: Ior[String, Int] = Ior.both("warning", 3)
   * scala> IorT.fromIor[Option](i)
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Both(warning,3)))
   * }}}
   */
  final def fromIor[F[_]]: FromIorPartiallyApplied[F] = new FromIorPartiallyApplied[F]

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class FromEitherPartiallyApplied[F[_]](private val dummy: Boolean = true) extends AnyVal {
    def apply[E, A](either: Either[E, A])(implicit F: Applicative[F]): IorT[F, E, A] = IorT(F.pure(either.toIor))
  }

  /**
   * Transforms an `Either` into an `IorT`, lifted into the specified `Applicative`.
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val e: Either[String, Int] = Either.right(3)
   * scala> IorT.fromEither[Option](e)
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Right(3)))
   * }}}
   */
  final def fromEither[F[_]]: FromEitherPartiallyApplied[F] = new FromEitherPartiallyApplied[F]

  /**
   * Transforms an `F[Either]` into an `IorT`.
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val e: Either[String, Int] = Either.right(3)
   * scala> IorT.fromEitherF(Option(e))
   * res0: cats.data.IorT[Option,String,Int] = IorT(Some(Right(3)))
   * }}}
   */
  final def fromEitherF[F[_], E, A](feither: F[Either[E, A]])(implicit F: Functor[F]): IorT[F, E, A] =
    IorT(F.map(feither)(_.toIor))

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class FromOptionPartiallyApplied[F[_]](private val dummy: Boolean = true) extends AnyVal {
    def apply[E, A](option: Option[A], ifNone: => E)(implicit F: Applicative[F]): IorT[F, E, A] =
      IorT(F.pure(option.toRightIor(ifNone)))
  }

  /**
   * Transforms an `Option` into an `IorT`, lifted into the specified `Applicative` and using
   * the second argument if the `Option` is a `None`.
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val o: Option[Int] = None
   * scala> IorT.fromOption[List](o, "Answer not known.")
   * res0: cats.data.IorT[List,String,Int] = IorT(List(Left(Answer not known.)))
   * scala> IorT.fromOption[List](Some(42), "Answer not known.")
   * res1: cats.data.IorT[List,String,Int] = IorT(List(Right(42)))
   * }}}
   */
  final def fromOption[F[_]]: FromOptionPartiallyApplied[F] = new FromOptionPartiallyApplied[F]

  /**
   * Transforms an `F[Option]` into an `IorT`, using the second argument if the `Option` is a `None`.
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val o: Option[Int] = None
   * scala> IorT.fromOptionF(List(o), "Answer not known.")
   * res0: cats.data.IorT[List,String,Int]  = IorT(List(Left(Answer not known.)))
   * scala> IorT.fromOptionF(List(Option(42)), "Answer not known.")
   * res1: cats.data.IorT[List,String,Int] = IorT(List(Right(42)))
   * }}}
   */
  final def fromOptionF[F[_], E, A](foption: F[Option[A]], ifNone: => E)(implicit F: Functor[F]): IorT[F, E, A] =
    IorT(F.map(foption)(_.toRightIor(ifNone)))

  /**
   * Uses the [[http://typelevel.org/cats/guidelines.html#partially-applied-type-params Partially Applied Type Params technique]] for ergonomics.
   */
  final private[data] class CondPartiallyApplied[F[_]](private val dummy: Boolean = true) extends AnyVal {
    def apply[A, B](test: Boolean, right: => B, left: => A)(implicit F: Applicative[F]): IorT[F, A, B] =
      IorT(F.pure(if (test) Ior.right(right) else Ior.left(left)))
  }

  /**
   * If the condition is satisfied, return the given `B` in `Ior.Right`, otherwise, return the given
   * `A` in `Ior.Left`, lifted into the specified `Applicative`.
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val userInput = "hello world"
   * scala> IorT.cond[Option](
   *      |   userInput.forall(_.isDigit) && userInput.size == 10,
   *      |   userInput,
   *      |   "The input does not look like a phone number")
   * res0: cats.data.IorT[Option,String,String] = IorT(Some(Left(The input does not look like a phone number)))
   * }}}
   */
  final def cond[F[_]]: CondPartiallyApplied[F] = new CondPartiallyApplied[F]

  /**
   * If the condition is satisfied, return the value of `IorT.right` on `F[B]`, otherwise, return the
   * value of `IorT.left` on `F[A]`.
   * {{{
   * scala> import cats.data.IorT
   * scala> import cats.implicits._
   * scala> val userInput = "hello world"
   * scala> IorT.condF[Option, String, String](
   *      |   userInput.forall(_.isDigit) && userInput.size == 10,
   *      |   Some(userInput),
   *      |   None)
   * res0: cats.data.IorT[Option,String,String] = IorT(None)
   * }}}
   */
  final def condF[F[_], A, B](test: Boolean, right: => F[B], left: => F[A])(implicit F: Functor[F]): IorT[F, A, B] =
    IorT(if (test) F.map(right)(Ior.right) else F.map(left)(Ior.left))
}

abstract private[data] class IorTInstances extends IorTInstances1 {

  implicit def catsDataShowForIorT[F[_], A, B](implicit sh: Show[F[Ior[A, B]]]): Show[IorT[F, A, B]] =
    Contravariant[Show].contramap(sh)(_.value)

  implicit def catsDataBifunctorForIorT[F[_]](implicit F: Functor[F]): Bifunctor[IorT[F, *, *]] =
    new Bifunctor[IorT[F, *, *]] {
      override def bimap[A, B, C, D](iort: IorT[F, A, B])(fa: A => C, fb: B => D): IorT[F, C, D] = iort.bimap(fa, fb)
    }

  implicit def catsDataTraverseForIorT[F[_], A](implicit F: Traverse[F]): Traverse[IorT[F, A, *]] =
    new IorTTraverse[F, A] with IorTFunctor[F, A] { val F0: Traverse[F] = F }

  implicit def catsDataMonoidForIorT[F[_], A, B](implicit F: Monoid[F[Ior[A, B]]]): Monoid[IorT[F, A, B]] =
    new IorTMonoid[F, A, B] { val F0: Monoid[F[Ior[A, B]]] = F }

  implicit def catsDataParallelForIorTWithParallelEffect[M[_], F[_], E](
    implicit P: Parallel[M, F],
    E: Semigroup[E]
  ): Parallel[IorT[M, E, *], IorT[F, E, *]] { type Dummy } = new Parallel[IorT[M, E, *], IorT[F, E, *]] {
    type Dummy // fix to make this one more specific than the catsDataParallelForIorTWithSequentialEffect, see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775

    val parallel: IorT[M, E, *] ~> IorT[F, E, *] = λ[IorT[M, E, *] ~> IorT[F, E, *]](fm => IorT(P.parallel(fm.value)))
    val sequential: IorT[F, E, *] ~> IorT[M, E, *] =
      λ[IorT[F, E, *] ~> IorT[M, E, *]](ff => IorT(P.sequential(ff.value)))

    private[this] val FA: Applicative[F] = P.applicative
    private[this] val IorA: Applicative[Ior[E, *]] = Parallel[Ior[E, *], Ior[E, *]].applicative

    val applicative: Applicative[IorT[F, E, *]] = new Applicative[IorT[F, E, *]] {
      def pure[A](a: A): IorT[F, E, A] = IorT.pure(a)(FA)
      def ap[A, B](ff: IorT[F, E, A => B])(fa: IorT[F, E, A]): IorT[F, E, B] =
        IorT(FA.map2(ff.value, fa.value)((f, a) => IorA.ap(f)(a)))
    }

    lazy val monad: Monad[IorT[M, E, *]] = {
      implicit def underlyingMonadM: Monad[M] = P.monad
      Monad[IorT[M, E, *]]
    }
  }

  implicit def catsDataDeferForIor[F[_], E](implicit F: Defer[F]): Defer[IorT[F, E, *]] =
    new Defer[IorT[F, E, *]] {
      def defer[A](fa: => IorT[F, E, A]): IorT[F, E, A] =
        IorT(F.defer(fa.value))
    }
}

abstract private[data] class IorTInstances1 extends IorTInstances2 {
  implicit def catsDataSemigroupForIorT[F[_], A, B](implicit F: Semigroup[F[Ior[A, B]]]): Semigroup[IorT[F, A, B]] =
    new IorTSemigroup[F, A, B] { val F0: Semigroup[F[Ior[A, B]]] = F }

  implicit def catsDataFoldableForIorT[F[_], A](implicit F: Foldable[F]): Foldable[IorT[F, A, *]] =
    new IorTFoldable[F, A] { val F0: Foldable[F] = F }

  implicit def catsDataMonadErrorForIorT[F[_], A](implicit F: Monad[F], A: Semigroup[A]): MonadError[IorT[F, A, *], A] =
    new IorTMonadError[F, A] {
      val A0: Semigroup[A] = A
      val F0: Monad[F] = F
    }

  implicit def catsDataParallelForIorTWithSequentialEffect[F[_], E](
    implicit F: Monad[F],
    E: Semigroup[E]
  ): Parallel[IorT[F, E, *], IorT[F, E, *]] = new Parallel[IorT[F, E, *], IorT[F, E, *]] {
    private[this] val identityK: IorT[F, E, *] ~> IorT[F, E, *] = FunctionK.id
    private[this] val underlyingParallel: Parallel[Ior[E, *], Ior[E, *]] =
      Parallel[Ior[E, *], Ior[E, *]]

    def parallel: IorT[F, E, *] ~> IorT[F, E, *] = identityK
    def sequential: IorT[F, E, *] ~> IorT[F, E, *] = identityK

    val applicative: Applicative[IorT[F, E, *]] = new Applicative[IorT[F, E, *]] {
      def pure[A](a: A): IorT[F, E, A] = IorT.pure(a)
      def ap[A, B](ff: IorT[F, E, A => B])(fa: IorT[F, E, A]): IorT[F, E, B] =
        IorT(F.map2(ff.value, fa.value)((f, a) => underlyingParallel.applicative.ap(f)(a)))
    }

    lazy val monad: Monad[IorT[F, E, *]] = Monad[IorT[F, E, *]]
  }

}

abstract private[data] class IorTInstances2 extends IorTInstances3 {
  implicit def catsDataMonadErrorFForIorT[F[_], A, E](implicit FE: MonadError[F, E],
                                                      A: Semigroup[A]): MonadError[IorT[F, A, *], E] =
    new IorTMonadErrorF[F, A, E] {
      val A0: Semigroup[A] = A
      val F0: MonadError[F, E] = FE
    }

  implicit def catsDataEqForIorT[F[_], A, B](implicit F: Eq[F[Ior[A, B]]]): Eq[IorT[F, A, B]] =
    new IorTEq[F, A, B] { val F0: Eq[F[Ior[A, B]]] = F }
}

abstract private[data] class IorTInstances3 {
  implicit def catsDataFunctorForIorT[F[_], A](implicit F: Functor[F]): Functor[IorT[F, A, *]] =
    new IorTFunctor[F, A] { val F0: Functor[F] = F }
}

sealed private[data] trait IorTFunctor[F[_], A] extends Functor[IorT[F, A, *]] {
  implicit def F0: Functor[F]

  override def map[B, D](iort: IorT[F, A, B])(f: B => D): IorT[F, A, D] = iort.map(f)
}

sealed private[data] trait IorTEq[F[_], A, B] extends Eq[IorT[F, A, B]] {
  implicit def F0: Eq[F[Ior[A, B]]]

  override def eqv(x: IorT[F, A, B], y: IorT[F, A, B]): Boolean = x === y
}

sealed private[data] trait IorTMonad[F[_], A] extends Monad[IorT[F, A, *]] with IorTFunctor[F, A] {
  implicit def A0: Semigroup[A]
  implicit override def F0: Monad[F]

  override def pure[B](b: B): IorT[F, A, B] = IorT.pure(b)

  override def flatMap[B, D](iort: IorT[F, A, B])(f: B => IorT[F, A, D]): IorT[F, A, D] = iort.flatMap(f)

  override def tailRecM[B, D](b: B)(f: B => IorT[F, A, Either[B, D]]): IorT[F, A, D] =
    IorT(F0.tailRecM(Tuple2[B, Option[A]](b, None)) {
      case (b0, optionA) =>
        F0.map(f(b0).value) {
          case Ior.Left(aa)           => Right(Ior.Left(Semigroup.maybeCombine(optionA, aa)))
          case Ior.Right(Left(b1))    => Left(b1 -> optionA)
          case Ior.Right(Right(d))    => Right(optionA.fold(Ior.right[A, D](d))(Ior.both(_, d)))
          case Ior.Both(aa, Right(d)) => Right(Ior.both(Semigroup.maybeCombine(optionA, aa), d))
          case Ior.Both(aa, Left(b1)) => Left(b1 -> Some(Semigroup.maybeCombine(optionA, aa)))
        }
    })
}

sealed private[data] trait IorTMonadError[F[_], A] extends MonadError[IorT[F, A, *], A] with IorTMonad[F, A] {
  override def raiseError[B](a: A): IorT[F, A, B] = IorT(F0.pure(Ior.left(a)))

  override def handleErrorWith[B](iort: IorT[F, A, B])(f: A => IorT[F, A, B]): IorT[F, A, B] =
    IorT(F0.flatMap(iort.value) {
      case Ior.Left(a)                         => f(a).value
      case r @ (Ior.Right(_) | Ior.Both(_, _)) => F0.pure(r)
    })
}

sealed private[data] trait IorTMonadErrorF[F[_], A, E] extends MonadError[IorT[F, A, *], E] with IorTMonad[F, A] {
  implicit override def F0: MonadError[F, E]

  override def raiseError[B](e: E): IorT[F, A, B] = IorT(F0.raiseError(e))

  override def handleErrorWith[B](iort: IorT[F, A, B])(f: E => IorT[F, A, B]): IorT[F, A, B] =
    IorT(F0.handleErrorWith(iort.value)(f(_).value))
}

sealed private[data] trait IorTSemigroup[F[_], A, B] extends Semigroup[IorT[F, A, B]] {
  implicit def F0: Semigroup[F[Ior[A, B]]]

  override def combine(x: IorT[F, A, B], y: IorT[F, A, B]): IorT[F, A, B] =
    IorT(F0.combine(x.value, y.value))
}

sealed private[data] trait IorTMonoid[F[_], A, B] extends Monoid[IorT[F, A, B]] with IorTSemigroup[F, A, B] {
  implicit override def F0: Monoid[F[Ior[A, B]]]

  override def empty: IorT[F, A, B] = IorT(F0.empty)
}

sealed private[data] trait IorTFoldable[F[_], A] extends Foldable[IorT[F, A, *]] {
  implicit def F0: Foldable[F]

  override def foldLeft[B, C](iort: IorT[F, A, B], c: C)(f: (C, B) => C): C = iort.foldLeft(c)(f)

  override def foldRight[B, C](iort: IorT[F, A, B], lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
    iort.foldRight(lc)(f)
}

sealed private[data] trait IorTTraverse[F[_], A] extends Traverse[IorT[F, A, *]] with IorTFoldable[F, A] {
  implicit override def F0: Traverse[F]

  override def traverse[G[_]: Applicative, B, D](iort: IorT[F, A, B])(f: B => G[D]): G[IorT[F, A, D]] = iort.traverse(f)
}
// Copyright 2019 Akiomi Kamakura
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cats.nio.file

import java.nio.file.Paths

import scala.collection.JavaConverters._ // TODO: use scala.jdk.CollectionConverters._
import scala.concurrent.ExecutionContext

import cats.effect.{ContextShift, IO}
import org.scalatest.{FunSuite, Matchers}

import cats.nio.file.implicits._

class JavaStreamOpsTests extends FunSuite with Matchers {
  implicit val ec: ExecutionContext = ExecutionContext.global
  implicit val cs: ContextShift[IO] = IO.contextShift(ec)

  test("resource") {
    var closed = false

    Files[IO]
      .find(Paths.get("src"), 100, (path, _) => path.toString.endsWith(".scala"))
      .map(_.onClose(new Runnable {
        def run = {
          closed = true
        }
      })).resource.use { stream =>
        val expected = Vector(
          Paths.get("src/test/scala/cats/nio/file/JavaStreamOpsTests.scala"),
          Paths.get("src/test/scala/cats/nio/file/FilesTests.scala"),
          Paths.get("src/main/scala/cats/nio/file/implicits/package.scala"),
          Paths.get("src/main/scala/cats/nio/file/Files.scala"),
        )

        IO.pure {
          stream.iterator.asScala.toVector should contain theSameElementsAs (expected)
        }
      }.unsafeRunSync

    closed should === (true)
  }
}

package io.circe.cats.data

import io.circe.cats.{Alternative, Applicative, ApplicativeError, Apply, CommutativeMonad, CommutativeFlatMap, Contravariant, ContravariantMonoidal, Defer, Distributive, FlatMap, Functor, FunctorFilter, Id, Monad, MonadError, MonoidK, Parallel, Representable, SemigroupK, Traverse, ~>}
import io.circe.cats.arrow._
import io.circe.cats.kernel.{Monoid, Semigroup}

/**
 * Represents a function `A => F[B]`.
 */
final case class Kleisli[F[_], -A, B](run: A => F[B]) { self =>

  def ap[C, AA <: A](f: Kleisli[F, AA, B => C]) given (F: Apply[F]): Kleisli[F, AA, C] =
    Kleisli(a => F.ap(f.run(a))(run(a)))

  /**
   * Performs [[local]] and [[map]] simultaneously.
   */
  def dimap[C, D](f: C => A)(g: B => D) given (F: Functor[F]): Kleisli[F, C, D] =
    Kleisli(c => F.map(run(f(c)))(g))

  /**
   * Modify the output of the Kleisli function with `f`.
   * {{{
   * scala> import cats.data.Kleisli, cats.implicits._
   * scala> val takeHead = Kleisli[Option, List[Int], Int](_.headOption)
   * scala> takeHead.map(_.toDouble).run(List(1))
   * res0: Option[Double] = Some(1.0)
   * }}}
   */
  def map[C](f: B => C) given (F: Functor[F]): Kleisli[F, A, C] =
    Kleisli(a => F.map(run(a))(f))

  def mapF[N[_], C](f: F[B] => N[C]): Kleisli[N, A, C] =
    Kleisli(run.andThen(f))

  /**
   * Modify the context `F` using transformation `f`.
   */
  def mapK[G[_]](f: F ~> G): Kleisli[G, A, B] =
    Kleisli[G, A, B](run.andThen(f.apply))

  def flatMap[C, AA <: A](f: B => Kleisli[F, AA, C]) given (F: FlatMap[F]): Kleisli[F, AA, C] =
    Kleisli.shift(a => F.flatMap[B, C](run(a))((b: B) => f(b).run(a)))

  def flatMapF[C](f: B => F[C]) given (F: FlatMap[F]): Kleisli[F, A, C] =
    Kleisli.shift(a => F.flatMap(run(a))(f))

  /**
   * Composes [[run]] with a function `B => F[C]` not lifted into Kleisli.
   */
  def andThen[C](f: B => F[C]) given (F: FlatMap[F]): Kleisli[F, A, C] =
    Kleisli.shift(a => F.flatMap(run(a))(f))

  /**
   * Tip to tail Kleisli arrow composition.
   * Creates a function `A => F[C]` from [[run]] (`A => F[B]`) and the given Kleisli of `B => F[C]`.
   * {{{
   * scala> import cats.data.Kleisli, cats.implicits._
   * scala> val takeHead = Kleisli[Option, List[Int], Int](_.headOption)
   * scala> val plusOne = Kleisli[Option, Int, Int](i => Some(i + 1))
   * scala> (takeHead andThen plusOne).run(List(1))
   * res0: Option[Int] = Some(2)
   * }}}
   */
  def andThen[C](k: Kleisli[F, B, C]) given (F: FlatMap[F]): Kleisli[F, A, C] =
    this.andThen(k.run)

  def compose[Z, AA <: A](f: Z => F[AA]) given (F: FlatMap[F]): Kleisli[F, Z, B] =
    Kleisli.shift((z: Z) => F.flatMap(f(z))(run))

  def compose[Z, AA <: A](k: Kleisli[F, Z, AA]) given (F: FlatMap[F]): Kleisli[F, Z, B] =
    this.compose(k.run)

  def traverse[G[_], AA <: A](f: G[AA]) given (F: Applicative[F], G: Traverse[G]): F[G[B]] =
    G.traverse(f)(run)

  def lift[G[_]](implicit G: Applicative[G]): Kleisli[[α] =>> G[F[α]], A, B] =
    Kleisli[[α] =>> G[F[α]], A, B](a => Applicative[G].pure(run(a)))

  /**
   * Contramap the input using `f`, where `f` may modify the input type of the Kleisli arrow.
   * {{{
   * scala> import cats.data.Kleisli, cats.implicits._
   * scala> type ParseResult[A] = Either[Throwable, A]
   * scala> val parseInt = Kleisli[ParseResult, String, Int](s => Either.catchNonFatal(s.toInt))
   * scala> parseInt.local[List[String]](_.combineAll).run(List("1", "2"))
   * res0: ParseResult[Int] = Right(12)
   * }}}
   */
  def local[AA](f: AA => A): Kleisli[F, AA, B] =
    Kleisli(f.andThen(run))

  @deprecated("Use mapK", "1.0.0-RC2")
  def transform[G[_]](f: FunctionK[F, G]): Kleisli[G, A, B] =
    mapK(f)

  def lower given (F: Applicative[F]): Kleisli[F, A, F[B]] =
    Kleisli(a => F.pure(run(a)))

  def first[C] given (F: Functor[F]): Kleisli[F, (A, C), (B, C)] =
    Kleisli { case (a, c) => F.fproduct(run(a))(_ => c) }

  def second[C] given (F: Functor[F]): Kleisli[F, (C, A), (C, B)] =
    Kleisli { case (c, a) => F.map(run(a))(c -> _) }

  /** Discard computed B and yield the input value. */
  def tap[AA <: A] given (F: Functor[F]): Kleisli[F, AA, AA] =
    Kleisli(a => F.as(run(a), a))

  /** Yield computed B combined with input value. */
  def tapWith[C, AA <: A](f: (AA, B) => C) given (F: Functor[F]): Kleisli[F, AA, C] =
    Kleisli(a => F.map(run(a))(b => f(a, b)))

  def tapWithF[C, AA <: A](f: (AA, B) => F[C]) given (F: FlatMap[F]): Kleisli[F, AA, C] =
    Kleisli(a => F.flatMap(run(a))(b => f(a, b)))

  def toReader: Reader[A, F[B]] = Kleisli[Id, A, F[B]](run)

  def apply(a: A): F[B] = run(a)
}

object Kleisli
    extends KleisliInstances
    with KleisliFunctions
    with KleisliFunctionsBinCompat
    with KleisliExplicitInstances {

  /**
   * Internal API — shifts the execution of `run` in the `F` context.
   *
   * Used to build Kleisli values for `F[_]` data types that implement `Monad`,
   * in which case it is safer to trigger the `F[_]` context earlier.
   *
   * The requirement is for `FlatMap` as this will get used in operations
   * that invoke `F.flatMap` (e.g. in `Kleisli#flatMap`). However we are
   * doing discrimination based on inheritance and if we detect an
   * `Applicative`, then we use it to trigger the `F[_]` context earlier.
   *
   * Triggering the `F[_]` context earlier is important to avoid stack
   * safety issues for `F` monads that have a stack safe `flatMap`
   * implementation. For example `Eval` or `IO`. Without this the `Monad`
   * instance is stack unsafe, even if the underlying `F` is stack safe
   * in `flatMap`.
   */
  private[data] def shift[F[_], A, B](run: A => F[B]) given (F: FlatMap[F]): Kleisli[F, A, B] =
    F match {
      case ap: Applicative[F] @unchecked =>
        Kleisli(r => F.flatMap(ap.pure(r))(run))
      case _ =>
        Kleisli(run)
    }

  /**
   * Creates a `FunctionK` that transforms a `Kleisli[F, A, B]` into an `F[B]` by applying the value of type `a:A`.
   * {{{
   * scala> import cats.{~>}, cats.data.{Kleisli, EitherT}
   *
   * scala> def f(i: Int): Option[Either[Char, Char]] = if (i > 0) Some(Right('n')) else if (i < 0) Some(Left('z')) else None
   *
   * scala> type KOI[A] = Kleisli[Option, Int, A]
   * scala> val b: KOI[Either[Char, Char]] = Kleisli[Option, Int, Either[Char, Char]](f _)
   * scala> val nt: Kleisli[Option, Int, *] ~> Option = Kleisli.applyK[Option, Int](1)
   * scala> nt(b)
   * res0: Option[Either[Char, Char]] = Some(Right(n))
   *
   * scala> type EKOIC[A] = EitherT[KOI, Char, A]
   * scala> val c: EKOIC[Char] = EitherT[KOI, Char, Char](b)
   * scala> c.mapK(nt).value
   * res1: Option[Either[Char, Char]] = Some(Right(n))
   *
   * scala> val ntz = Kleisli.applyK[Option, Int](0)
   * scala> c.mapK(ntz).value
   * res2: Option[Either[Char, Char]] = None
   * }}}
   */
  def applyK[F[_], A](a: A): FunctionK[[a] =>> Kleisli[F, A, a], F] =
    new FunctionK[[a] =>> Kleisli[F, A, a], F] {
      def apply[X](x: Kleisli[F, A, X]) = x.apply(a)
    }

}

sealed private[data] trait KleisliFunctions {

  /**
   * Creates a Kleisli that ignores its input `A` and returns the given `F[B]`.
   * {{{
   * scala> import cats.data.Kleisli, cats.implicits._
   * scala> val takeHead = Kleisli((_:List[Int]).headOption)
   * scala> val makeList = Kleisli.liftF[Option, Unit, List[Int]](Some(List(1,2,3)))
   * scala> (makeList andThen takeHead).run(())
   * res0: Option[Int] = Some(1)
   * }}}
   */
  def liftF[F[_], A, B](x: F[B]): Kleisli[F, A, B] =
    Kleisli(_ => x)

  /**
   * Same as [[liftF]], but expressed as a FunctionK for use with mapK
   * {{{
   * scala> import cats._, data._, implicits._
   * scala> val a: OptionT[Eval, Int] = 1.pure[OptionT[Eval, *]]
   * scala> val b: OptionT[Kleisli[Eval, String, *], Int] = a.mapK(Kleisli.liftK)
   * scala> b.value.run("").value
   * res0: Option[Int] = Some(1)
   * }}}
   */
  //def liftK[F[_], A]: F ~> Kleisli[F, A, *] =
  //  λ[F ~> Kleisli[F, A, *]](Kleisli.liftF(_))

  /**
   * Creates a Kleisli arrow ignoring its input and lifting the given `B` into applicative context `F`.
   * {{{
   * scala> import cats.data.Kleisli, cats.implicits._
   * scala> val pureOpt = Kleisli.pure[Option, Unit, String]("beam me up!")
   * scala> pureOpt.run(())
   * res0: Option[String] = Some(beam me up!)
   * }}}
   */
  def pure[F[_], A, B](x: B) given (F: Applicative[F]): Kleisli[F, A, B] =
    Kleisli(_ => F.pure(x))

  /**
   * Creates a Kleisli arrow which can lift an `A` into applicative context `F`.
   * This is distinct from [[pure]] in that the input is what is lifted (and not ignored).
   * {{{
   * scala> Kleisli.ask[Option, Int].run(1)
   * res0: Option[Int]: Some(1)
   * }}}
   */
  def ask[F[_], A] given (F: Applicative[F]): Kleisli[F, A, A] =
    Kleisli(F.pure)

  /**
   * Modifies the input environment with `f`, without changing the input type of the Kleisli.
   * {{{
   * scala> import cats.data.Kleisli
   * scala> val takeHead = Kleisli[Option, List[Int], Int](_.headOption)
   * scala> Kleisli.local[Option, Int, List[Int]](1 :: _)(takeHead).run(List(2,3))
   * res0: Option[Int] = Some(1)
   * }}}
   */
  def local[M[_], A, R](f: R => R)(fa: Kleisli[M, R, A]): Kleisli[M, R, A] =
    Kleisli(f.andThen(fa.run))
}

sealed private[data] trait KleisliFunctionsBinCompat {

  /**
   * Lifts a natural transformation of effects within a Kleisli
   * to a transformation of Kleislis.
   *
   * Equivalent to running `mapK(f) on a Kleisli.
   *
   * {{{
   * scala> import cats._, data._
   * scala> val f: (List ~> Option) = λ[List ~> Option](_.headOption)
   *
   * scala> val k: Kleisli[List, String, Char] = Kleisli(_.toList)
   * scala> k.run("foo")
   * res0: List[Char] = List(f, o, o)
   *
   * scala> val k2: Kleisli[Option, String, Char] = Kleisli.liftFunctionK(f)(k)
   * scala> k2.run("foo")
   * res1: Option[Char] = Some(f)
   * }}}
   * */
  def liftFunctionK[F[_], G[_], A](f: F ~> G): FunctionK[[a] =>> Kleisli[F, A, a], [a] =>> Kleisli[G, A, a]] =
    new FunctionK[[a] =>> Kleisli[F, A, a], [a] =>> Kleisli[G, A, a]] {
      def apply[X](x: Kleisli[F, A, X]) = x.mapK(f)
    }
}

sealed private[data] trait KleisliExplicitInstances {

  def endoSemigroupK[F[_]] given (FM: FlatMap[F]): SemigroupK[[α] =>> Kleisli[F, α, α]] =
    Compose[[a, b] =>> Kleisli[F, a, b]].algebraK

  def endoMonoidK[F[_]](implicit M: Monad[F]): MonoidK[[α] =>> Kleisli[F, α, α]] =
    Category[[a, b] =>> Kleisli[F, a, b]].algebraK
}

sealed abstract private[data] class KleisliInstances extends KleisliInstances0 {
  implicit def catsDataMonadForKleisliId[A]: CommutativeMonad[[a] =>> Kleisli[Id, A, a]] =
    catsDataCommutativeMonadForKleisli[Id, A]

  implicit val catsDataCommutativeArrowForKleisliId: CommutativeArrow[[a, b] =>> Kleisli[Id, a, b]] =
    catsDataCommutativeArrowForKleisli[Id]

  implicit def catsDataDeferForKleisli[F[_], A] given (F: Defer[F]): Defer[[a] =>> Kleisli[F, A, a]] =
    new Defer[[a] =>> Kleisli[F, A, a]] {
      def defer[B](fa: => Kleisli[F, A, B]): Kleisli[F, A, B] = {
        lazy val cacheFa = fa
        Kleisli[F, A, B] { a =>
          F.defer(cacheFa.run(a))
        }
      }
    }

  implicit def catsDataFunctorFilterForKleisli[F[_], A](
    implicit ev: FunctorFilter[F]
  ): FunctorFilter[[a] =>> Kleisli[F, A, a]] =
    new KleisliFunctorFilter[F, A] { val FF = ev }
}

sealed abstract private[data] class KleisliInstances0 extends KleisliInstances0_5 {

  implicit def catsDataCommutativeArrowForKleisli[F[_]](
    implicit M: CommutativeMonad[F]
  ): CommutativeArrow[[a, b] =>> Kleisli[F, a, b]] with ArrowChoice[[a, b] =>> Kleisli[F, a, b]] =
    new KleisliCommutativeArrow[F] { def F: CommutativeMonad[F] = M }

  implicit def catsDataCommutativeMonadForKleisli[F[_], A](
    implicit F0: CommutativeMonad[F]
  ): CommutativeMonad[[a] =>> Kleisli[F, A, a]] =
    new KleisliMonad[F, A] with CommutativeMonad[[a] =>> Kleisli[F, A, a]] {
      implicit def F: Monad[F] = F0
    }

}

sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances1 {
  implicit def catsDataMonoidForKleisli[F[_], A, B] given (FB0: Monoid[F[B]]): Monoid[Kleisli[F, A, B]] =
    new KleisliMonoid[F, A, B] { def FB: Monoid[F[B]] = FB0 }

  implicit def catsDataMonadErrorForKleisli[F[_], A, E](
    implicit ME: MonadError[F, E]
  ): MonadError[[a] =>> Kleisli[F, A, a], E] =
    new KleisliMonadError[F, A, E] { def F: MonadError[F, E] = ME }

  implicit def catsDataArrowChoiceForKleisli[F[_]](implicit M: Monad[F]): ArrowChoice[[a, b] =>> Kleisli[F, a, b]] =
    new KleisliArrowChoice[F] {
      def F: Monad[F] = M
    }

  implicit def catsDataContravariantMonoidalForKleisli[F[_], A](
    implicit F0: ContravariantMonoidal[F]
  ): ContravariantMonoidal[[a] =>> Kleisli[F, A, a]] =
    new KleisliContravariantMonoidal[F, A] { def F: ContravariantMonoidal[F] = F0 }

  /**
   * Witness for: Kleisli[M, E, A] <-> (E, R) => A
   * if M is Representable
   */
  implicit def catsDataRepresentableForKleisli[M[_], R, E](
    implicit
    R: Representable.Aux[M, R],
    FK: Functor[[a] =>> Kleisli[M, E, a]]
  ): Representable.Aux[[a] =>> Kleisli[M, E, a], (E, R)] = new Representable[[a] =>> Kleisli[M, E, a]] {

    override type Representation = (E, R)

    override val F: Functor[[a] =>> Kleisli[M, E, a]] = FK

    def index[A](f: Kleisli[M, E, A]): Representation => A = {
      case (e, r) => R.index(f.run(e))(r)
    }

    def tabulate[A](f: Representation => A): Kleisli[M, E, A] = {
      def curry[X, Y, Z](f: (X, Y) => Z): X => Y => Z = x => y => f(x, y)

      Kleisli[M, E, A](curry(Function.untupled(f)).andThen(R.tabulate))
    }
  }
}

sealed abstract private[data] class KleisliInstances1 extends KleisliInstances2 {
  implicit def catsDataMonadForKleisli[F[_], A](implicit M: Monad[F]): Monad[[a] =>> Kleisli[F, A, a]] =
    new KleisliMonad[F, A] { def F: Monad[F] = M }

  implicit def catsDataParallelForKleisli[F[_], M[_], A](
    implicit P: Parallel[M, F]
  ): Parallel[[a] =>> Kleisli[M, A, a], [a] =>> Kleisli[F, A, a]] = new Parallel[[a] =>> Kleisli[M, A, a], [a] =>> Kleisli[F, A, a]] {
    private[this] implicit val appF: Applicative[F] = P.applicative
    private[this] implicit val monadM: Monad[M] = P.monad
    def applicative: Applicative[[a] =>> Kleisli[F, A, a]] = catsDataApplicativeForKleisli
    def monad: Monad[[a] =>> Kleisli[M, A, a]] = catsDataMonadForKleisli

    def sequential: FunctionK[[a] =>> Kleisli[F, A, a], [a] =>> Kleisli[M, A, a]] =
      new FunctionK[[a] =>> Kleisli[F, A, a], [a] =>> Kleisli[M, A, a]] {
        def apply[X](x: Kleisli[F, A, X]) = x.mapK(P.sequential)
      }

    def parallel: FunctionK[[a] =>> Kleisli[M, A, a], [a] =>> Kleisli[F, A, a]] =
      new FunctionK[[a] =>> Kleisli[M, A, a], [a] =>> Kleisli[F, A, a]] {
        def apply[X](x: Kleisli[M, A, X]) = x.mapK(P.parallel)
      }
  }

  implicit def catsDataContravariantForKleisli[F[_], C]: Contravariant[[a] =>> Kleisli[F, a, C]] =
    new Contravariant[[a] =>> Kleisli[F, a, C]] {
      override def contramap[A, B](fa: Kleisli[F, A, C])(f: B => A): Kleisli[F, B, C] =
        fa.local(f)
    }
}

sealed abstract private[data] class KleisliInstances2 extends KleisliInstances3 {
  implicit def catsDataAlternativeForKleisli[F[_], A] given (F0: Alternative[F]): Alternative[[a] =>> Kleisli[F, A, a]] =
    new KleisliAlternative[F, A] { def F: Alternative[F] = F0 }
}

sealed abstract private[data] class KleisliInstances3 extends KleisliInstances4 {
  implicit def catsDataMonoidKForKleisli[F[_], A] given (F0: MonoidK[F]): MonoidK[[a] =>> Kleisli[F, A, a]] =
    new KleisliMonoidK[F, A] { def F: MonoidK[F] = F0 }

  implicit def catsDataCommutativeFlatMapForKleisli[F[_], A](
    implicit F0: CommutativeFlatMap[F]
  ): CommutativeFlatMap[[a] =>> Kleisli[F, A, a]] =
    new KleisliFlatMap[F, A] with CommutativeFlatMap[[a] =>> Kleisli[F, A, a]] { val F: CommutativeFlatMap[F] = F0 }

  implicit def catsDataChoiceForKleisli[F[_]](implicit M: Monad[F]): Choice[[a, b] =>> Kleisli[F, a, b]] =
    new KleisliChoice[F] { def F: Monad[F] = M }

  implicit val catsDataChoiceForKleisliId: Choice[[a, b] =>> Kleisli[Id, a, b]] =
    catsDataChoiceForKleisli[Id]

  implicit def catsDataComposeForKleisli[F[_]] given (FM: FlatMap[F]): Compose[[a, b] =>> Kleisli[F, a, b]] =
    new KleisliCompose[F] { def F: FlatMap[F] = FM }

  implicit def catsDataStrongForKleisli[F[_]] given (F0: Functor[F]): Strong[[a, b] =>> Kleisli[F, a, b]] =
    new KleisliStrong[F] { def F: Functor[F] = F0 }

  implicit def catsDataSemigroupForKleisli[F[_], A, B] given (FB0: Semigroup[F[B]]): Semigroup[Kleisli[F, A, B]] =
    new KleisliSemigroup[F, A, B] { def FB: Semigroup[F[B]] = FB0 }
}

sealed abstract private[data] class KleisliInstances4 extends KleisliInstances5 {
  implicit def catsDataSemigroupKForKleisli[F[_], A] given (F0: SemigroupK[F]): SemigroupK[[a] =>> Kleisli[F, A, a]] =
    new KleisliSemigroupK[F, A] { def F: SemigroupK[F] = F0 }

  implicit def catsDataFlatMapForKleisli[F[_], A] given (FM: FlatMap[F]): FlatMap[[a] =>> Kleisli[F, A, a]] =
    new KleisliFlatMap[F, A] { def F: FlatMap[F] = FM }

}

sealed abstract private[data] class KleisliInstances5 extends KleisliInstances6 {

  implicit def catsDataApplicativeErrorForKleisli[F[_], E, A](
    implicit F0: ApplicativeError[F, E]
  ): ApplicativeError[[a] =>> Kleisli[F, A, a], E] =
    new KleisliApplicativeError[F, A, E] { def F: ApplicativeError[F, E] = F0 }
}

sealed abstract private[data] class KleisliInstances6 extends KleisliInstances7 {
  implicit def catsDataApplicativeForKleisli[F[_], A](implicit A: Applicative[F]): Applicative[[a] =>> Kleisli[F, A, a]] =
    new KleisliApplicative[F, A] { def F: Applicative[F] = A }
}

sealed abstract private[data] class KleisliInstances7 extends KleisliInstances8 {
  implicit def catsDataApplyForKleisli[F[_], A](implicit A: Apply[F]): Apply[[a] =>> Kleisli[F, A, a]] =
    new KleisliApply[F, A] { def F: Apply[F] = A }
}

sealed abstract private[data] class KleisliInstances8 extends KleisliInstances9 {
  implicit def catsDataDistributiveForKleisli[F[_], R] given (F0: Distributive[F]): Distributive[[a] =>> Kleisli[F, R, a]] =
    new KleisliDistributive[F, R] with KleisliFunctor[F, R] { implicit def F: Distributive[F] = F0 }
}

sealed abstract private[data] class KleisliInstances9 {
  implicit def catsDataFunctorForKleisli[F[_], A] given (F0: Functor[F]): Functor[[a] =>> Kleisli[F, A, a]] =
    new KleisliFunctor[F, A] { def F: Functor[F] = F0 }
}

private[data] trait KleisliCommutativeArrow[F[_]]
    extends CommutativeArrow[[a, b] =>> Kleisli[F, a, b]]
    with KleisliArrowChoice[F] {
  implicit def F: CommutativeMonad[F]
}

private[data] trait KleisliArrowChoice[F[_]]
    extends ArrowChoice[[a, b] =>> Kleisli[F, a, b]]
    with KleisliCategory[F]
    with KleisliStrong[F] {
  implicit def F: Monad[F]

  def lift[A, B](f: A => B): Kleisli[F, A, B] =
    Kleisli(a => F.pure(f(a)))

  override def split[A, B, C, D](f: Kleisli[F, A, B], g: Kleisli[F, C, D]): Kleisli[F, (A, C), (B, D)] =
    Kleisli { case (a, c) => F.flatMap(f.run(a))(b => F.map(g.run(c))(d => (b, d))) }

  def choose[A, B, C, D](f: Kleisli[F, A, C])(g: Kleisli[F, B, D]): Kleisli[F, Either[A, B], Either[C, D]] =
    Kleisli(
      (fe: Either[A, B]) =>
        fe match {
          case Left(a)  => F.map(f(a))(Left.apply _)
          case Right(b) => F.map(g(b))(Right.apply _)
        }
    )
}

private[data] trait KleisliStrong[F[_]] extends Strong[[a, b] =>> Kleisli[F, a, b]] {
  implicit def F: Functor[F]

  override def lmap[A, B, C](fab: Kleisli[F, A, B])(f: C => A): Kleisli[F, C, B] =
    fab.local(f)

  override def rmap[A, B, C](fab: Kleisli[F, A, B])(f: B => C): Kleisli[F, A, C] =
    fab.map(f)

  override def dimap[A, B, C, D](fab: Kleisli[F, A, B])(f: C => A)(g: B => D): Kleisli[F, C, D] =
    fab.dimap(f)(g)

  def first[A, B, C](fa: Kleisli[F, A, B]): Kleisli[F, (A, C), (B, C)] =
    fa.first[C]

  override def second[A, B, C](fa: Kleisli[F, A, B]): Kleisli[F, (C, A), (C, B)] =
    fa.second[C]
}

private[data] trait KleisliChoice[F[_]] extends Choice[[a, b] =>> Kleisli[F, a, b]] with KleisliCategory[F] {
  def choice[A, B, C](f: Kleisli[F, A, C], g: Kleisli[F, B, C]): Kleisli[F, Either[A, B], C] =
    Kleisli(_.fold(f.run, g.run))
}

private[data] trait KleisliCategory[F[_]] extends Category[[a, b] =>> Kleisli[F, a, b]] with KleisliCompose[F] {
  implicit def F: Monad[F]

  override def id[A]: Kleisli[F, A, A] = Kleisli.ask[F, A]
}

private[data] trait KleisliCompose[F[_]] extends Compose[[a, b] =>> Kleisli[F, a, b]] {
  implicit def F: FlatMap[F]

  def compose[A, B, C](f: Kleisli[F, B, C], g: Kleisli[F, A, B]): Kleisli[F, A, C] =
    f.compose(g)
}

private[data] trait KleisliSemigroup[F[_], A, B] extends Semigroup[Kleisli[F, A, B]] {
  implicit def FB: Semigroup[F[B]]

  override def combine(a: Kleisli[F, A, B], b: Kleisli[F, A, B]): Kleisli[F, A, B] =
    Kleisli[F, A, B](x => FB.combine(a.run(x), b.run(x)))
}

private[data] trait KleisliMonoid[F[_], A, B] extends Monoid[Kleisli[F, A, B]] with KleisliSemigroup[F, A, B] {
  implicit def FB: Monoid[F[B]]

  override def empty: Kleisli[F, A, B] = Kleisli[F, A, B](_ => FB.empty)
}

sealed private[data] trait KleisliSemigroupK[F[_], A] extends SemigroupK[[a] =>> Kleisli[F, A, a]] {
  implicit def F: SemigroupK[F]

  override def combineK[B](x: Kleisli[F, A, B], y: Kleisli[F, A, B]): Kleisli[F, A, B] =
    Kleisli(a => F.combineK(x.run(a), y.run(a)))
}

sealed private[data] trait KleisliMonoidK[F[_], A] extends MonoidK[[a] =>> Kleisli[F, A, a]] with KleisliSemigroupK[F, A] {
  implicit def F: MonoidK[F]

  override def empty[B]: Kleisli[F, A, B] = Kleisli.liftF(F.empty[B])
}

private[data] trait KleisliAlternative[F[_], A]
    extends Alternative[[a] =>> Kleisli[F, A, a]]
    with KleisliApplicative[F, A]
    with KleisliMonoidK[F, A] {
  implicit def F: Alternative[F]
}

sealed private[data] trait KleisliContravariantMonoidal[F[_], D] extends ContravariantMonoidal[[a] =>> Kleisli[F, D, a]] {
  implicit def F: ContravariantMonoidal[F]

  override def unit: Kleisli[F, D, Unit] = Kleisli(Function.const(F.unit))

  override def contramap[A, B](fa: Kleisli[F, D, A])(f: B => A): Kleisli[F, D, B] =
    Kleisli(d => F.contramap(fa.run(d))(f))

  override def product[A, B](fa: Kleisli[F, D, A], fb: Kleisli[F, D, B]): Kleisli[F, D, (A, B)] =
    Kleisli(d => F.product(fa.run(d), fb.run(d)))
}

private[data] trait KleisliMonadError[F[_], A, E]
    extends MonadError[[a] =>> Kleisli[F, A, a], E]
    with KleisliApplicativeError[F, A, E]
    with KleisliMonad[F, A] {
  def F: MonadError[F, E]
}

private[data] trait KleisliApplicativeError[F[_], A, E]
    extends ApplicativeError[[a] =>> Kleisli[F, A, a], E]
    with KleisliApplicative[F, A] {
  type K[T] = Kleisli[F, A, T]

  implicit def F: ApplicativeError[F, E]

  def raiseError[B](e: E): K[B] = Kleisli(_ => F.raiseError(e))

  def handleErrorWith[B](kb: K[B])(f: E => K[B]): K[B] = Kleisli { a: A =>
    F.handleErrorWith(kb.run(a))((e: E) => f(e).run(a))
  }
}

private[data] trait KleisliMonad[F[_], A]
    extends Monad[[a] =>> Kleisli[F, A, a]]
    with KleisliFlatMap[F, A]
    with KleisliApplicative[F, A] {
  implicit def F: Monad[F]
}

private[data] trait KleisliFlatMap[F[_], A] extends FlatMap[[a] =>> Kleisli[F, A, a]] with KleisliApply[F, A] {
  implicit def F: FlatMap[F]

  def flatMap[B, C](fa: Kleisli[F, A, B])(f: B => Kleisli[F, A, C]): Kleisli[F, A, C] =
    fa.flatMap(f)

  def tailRecM[B, C](b: B)(f: B => Kleisli[F, A, Either[B, C]]): Kleisli[F, A, C] =
    Kleisli[F, A, C]({ a =>
      F.tailRecM(b) { f(_).run(a) }
    })
}

private[data] trait KleisliApplicative[F[_], A] extends Applicative[[a] =>> Kleisli[F, A, a]] with KleisliApply[F, A] {
  implicit def F: Applicative[F]

  def pure[B](x: B): Kleisli[F, A, B] =
    Kleisli.pure[F, A, B](x)
}

private[data] trait KleisliApply[F[_], A] extends Apply[[a] =>> Kleisli[F, A, a]] with KleisliFunctor[F, A] {
  implicit def F: Apply[F]

  override def ap[B, C](f: Kleisli[F, A, B => C])(fa: Kleisli[F, A, B]): Kleisli[F, A, C] =
    fa.ap(f)

  override def product[B, C](fb: Kleisli[F, A, B], fc: Kleisli[F, A, C]): Kleisli[F, A, (B, C)] =
    Kleisli(a => F.product(fb.run(a), fc.run(a)))
}

private[data] trait KleisliFunctor[F[_], A] extends Functor[[a] =>> Kleisli[F, A, a]] {
  implicit def F: Functor[F]

  override def map[B, C](fa: Kleisli[F, A, B])(f: B => C): Kleisli[F, A, C] =
    fa.map(f)
}

private trait KleisliDistributive[F[_], R] extends Distributive[[a] =>> Kleisli[F, R, a]] {
  implicit def F: Distributive[F]

  override def distribute[G[_]: Functor, A, B](a: G[A])(f: A => Kleisli[F, R, B]): Kleisli[F, R, G[B]] =
    Kleisli(r => F.distribute(a)(f(_).run(r)))

  def map[A, B](fa: Kleisli[F, R, A])(f: A => B): Kleisli[F, R, B] = fa.map(f)
}

private[data] trait KleisliFunctorFilter[F[_], R] extends FunctorFilter[[a] =>> Kleisli[F, R, a]] {

  def FF: FunctorFilter[F]

  def functor: Functor[[a] =>> Kleisli[F, R, a]] = Kleisli.catsDataFunctorForKleisli given FF.functor

  def mapFilter[A, B](fa: Kleisli[F, R, A])(f: A => Option[B]): Kleisli[F, R, B] =
    Kleisli[F, R, B] { r =>
      FF.mapFilter(fa.run(r))(f)
    }
}package scala_with_cats

import cats.implicits._
import scala_with_cats.cat.Cat
import scala_with_cats.functor.Tree
import scala_with_cats.monoid.Order
import scala_with_cats.monoid.SuperAdder
import scala_with_cats.printable.PrintableInstances._
import scala_with_cats.printable.PrintableSyntax._

object Main extends App {
  def break(message: String): Unit = println(s"\n$message")

  break("Testing printing a Cat with Printable:")
  val toby = Cat("Toby", 4, "calico")
  val ralph = Cat("Ralph", 10, "orange")
  ralph.print

  break("Testing printing a Cat with Show:")
  println(ralph.show)

  break("Testing Eq with some Cats:")
  println(ralph === toby)

  break("Testing SuperAdder.add:")
  println(SuperAdder.add(List[Int](1, 2, 3)))
  println(SuperAdder.add(List[Option[Int]](Some(1), Some(2), Some(3))))
  
  break("Testing SuperAdder.add with Orders:")
  val order1 = Order(24.45, 2.0)
  val order2 = Order(13.87, 5.0)
  println(SuperAdder.add(List[Order](order1, order2)))

  break("Testing Tree.map:")
  val tree = Tree.branch(Tree.leaf(2), Tree.leaf(5))
  println(tree.map(_ * 2))
}
package env

import zio.{ test => _, _ }
import zio.test._
import zio.test.Assertion._
import zio.duration._

import zio.cookbook.test.ZIOBaseSpec

import cats.effect.Timer
import zio.interop.catz.{ test => _, _ }
import zio.interop.catz.implicits._
import cats.Eval
// import zio.test.mock.MockConsole.putStrLn

//noinspection TypeAnnotation
object ToTest {
  var callCount: Int = 0;
  val resetCallCount: UIO[Unit] = ZIO.effectTotal {
    callCount = 0; ()
  }
  val getCallCount: UIO[Int] = ZIO.effectTotal(callCount)

  def plainVal: Int = {
    callCount = callCount + 1
    println(s"v1: $callCount")
    callCount
  }

  val scalaVal: Task[Int] = ZIO.effect(plainVal)

  val rand = random.nextString(2)

  val catsNow   = Eval.now(plainVal)
  val catsLater = Eval.later(plainVal)

  val scalaValMemoized = scalaVal.memoize
  val scalaValCached   = scalaVal.cached(10.seconds).flatten

  val scalaValMemoized2: ZIO[Any, Nothing, IO[Throwable, Int]] = scalaVal.memoize
  val testScalaVal = testM("scala val caching") {
    for {
      _    <- resetCallCount
      val1 <- scalaVal
      val2 <- scalaVal
    } yield assert(val1, equalTo(val2))
  }

  val testScalaValMemoized1 = testM("scala val memoized caching [1]") {
    for {
      _    <- resetCallCount
      svm  <- scalaVal.memoize
      val1 <- svm
      val2 <- svm
    } yield assert(val1, equalTo(val2))
  }

  val testScalaValMemoized2 = testM("scala val memoized caching [2]") {
    for {
      _    <- resetCallCount
      val1 <- scalaValMemoized
      val2 <- scalaValMemoized
    } yield assert(val1, equalTo(val2))
  }

  val testScalaValCached1 = testM("scala val caching [1]") {
    for {
      _     <- resetCallCount
      cache <- scalaVal.cached(10.seconds)
      val1  <- cache
      val2  <- cache
    } yield assert(val1, equalTo(val2))
  }
  val testScalaValCached2 = testM("scala val caching [2]") {
    for {
      _    <- resetCallCount
      val1 <- scalaValCached
      val2 <- scalaValCached
    } yield assert(val1, equalTo(val2))
  }

  val t = Task {
    println(s"Compute")
    5
  }
  val test0 = testM("0") {
    for {
      memoized <- t.memoize
      tt1      <- memoized
      tt2      <- memoized
    } yield assert(memoized, equalTo(tt1 + tt2))
  }

  def func(): Int = {
    println(s"Compute")
    5
  }

  // Arrows
  val add1: FunctionIO[Nothing, Int, Int] = FunctionIO.fromFunction(_ + 1)
  val eff1: FunctionIO[Nothing, Int, Int] = FunctionIO.effectTotal(_ => -1)
  val mul2: FunctionIO[Nothing, Int, Int] = FunctionIO.fromFunction(_ * 2)

  val out = -4
  val eff = ZIO.succeed(out)

  import java.util.UUID

  lazy val eff0 = ZIO.effect { println("Hi"); UUID.randomUUID() }
}

import ToTest._

object LazySpec
    extends ZIOBaseSpec(
      suite("ZIO val/def/memoize Specs")(
        testM("arrow compose lifed methods") {
          assertM((add1 >>> mul2 >>> add1).run(1), equalTo(5))
        },
        testM("Cache ext effect") {
          for {
            init <- eff
            v1   <- (add1 >>> add1 >>> add1).run(init)
          } yield assert(v1, equalTo(out + 3))
        },
        // testM("Lazy test") {
        //   for {
        //     v0 <- eff0
        //     v1 <- eff0
        //   } yield assert(v0, equalTo(v1))
        // },
        testM("Cats Lazy eval with ZIO caches a task") {
          for {
            init <- ZIO.effect(Eval.later(plainVal))
            val1 <- Task(init)
            val2 <- Task(init)
          } yield assert(val1.value, equalTo(val2.value))
        },
        testM("Cats Eager eval with ZIO doesn't cache a task") {
          for {
            init <- ZIO.effect(Eval.always(plainVal))
            val1 <- ZIO.effect(init.value)
            val2 <- Task(init.value)
          } yield assert(val1, isLessThan(val2))
        },
        testM("Cats Later must cache values") {
          for {
            val1 <- Task(catsLater)
            val2 <- Task(catsLater)
          } yield assert(val1.value, equalTo(val2.value))
        },
        test("Cats now must NOT cache values") {
          val lval1 = catsLater.value
          val lval2 = catsLater.value
          val val1  = catsNow.value
          val val2  = catsNow.value
          val val3  = catsNow.value
          println(s"val3 = $val3")
          assert(val1, isLessThan(val2)) && assert(lval1, isLessThan(lval2))
        }
      )
    )

object Helper {
  type ATask[A] = A
}
package my.cats.advanced

import my.wrapper.Wrap

object MonadApp {

  def optionsExamples(): Unit ={
    def parseInt(str: String): Option[Int] =
      scala.util.Try(str.toInt).toOption

    def divide(a: Int, b: Int): Option[Int] =
      if(b == 0) None else Some(a / b)

    println(s"""parseInt("1")  = ${parseInt("1")}""")
    //Some(1)
    println(s"""parseInt("2")  = ${parseInt("2")}""")
    //Some(1)
    println(s"""parseInt("-1") = ${parseInt("-1")}""")
    //Some(-1)
    println(s"""parseInt("a")  = ${parseInt("a")}""")
    //None

    println(s"""divide(1, 2)  = ${divide(1, 2)}""")
    //Some(0)
    println(s"""divide(3, 2)  = ${divide(3, 2)}""")
    //Some(1)
    println(s"""divide(0, 2)  = ${divide(0, 2)}""")
    //Some(0)
    println(s"""divide(5, 0)  = ${divide(5, 0)}""")
    //None

    def stringDivideBy(aStr: String, bStr: String): Option[Int] = {
      println(s"stringDivideBy called for aStr = $aStr, bStr = ${bStr}")
      println(s"trying parseInt(aStr = ${aStr})")
      parseInt(aStr).flatMap { aNum => {
        println(s"trying parseInt(bStr = ${bStr})")
        parseInt(bStr).flatMap { bNum => {
          println(s"trying divide(aNum = ${aNum}, bNum=${bNum})")
          divide(aNum, bNum)
        }}
      }}
    }

    //Fail at the last step on divide()
    println(stringDivideBy("1", "0"))
    //stringDivideBy called for aStr = 1, bStr = 0
    //trying parseInt(aStr = 1)
    //trying parseInt(bStr = 0)
    //trying divide(aNum = 1, bNum = 0)
    //None

    //Fail early when trying to parseInt("a")
    println(stringDivideBy("a", "0"))
    //stringDivideBy called for aStr = a, bStr = 0
    //trying parseInt(aStr = a)
    //None

    //Fail early when trying to parseInt("b")
    println(stringDivideBy("1", "b"))
    //stringDivideBy called for aStr = 1, bStr = b
    //trying parseInt(aStr = 1)
    //trying parseInt(bStr = b)
    //None

    /**
     * Every monad is also a functor,
     * so we can rely on both flatMap and map to sequence computations
     * that do and and don’t introduce a new monad.
     *
     * Plus, if we have both flatMap and map we can use for comprehensions
     * to clarify the sequencing behaviour:
     */
    def stringDivideBy2(aStr: String, bStr: String): Option[Int] =
      for {
        aNum <- {println(s"trying parseInt(aStr = ${aStr})"); parseInt(aStr)}
        bNum <- {println(s"trying parseInt(bStr = ${bStr})"); parseInt(bStr)}
        ans  <- {println(s"trying divide(aNum = ${aNum}, bNum = ${bNum})"); divide(aNum, bNum)}
      } yield ans

    println(s"""stringDivideBy2("6", "2") = ${stringDivideBy2("6", "2")}""")
    // trying parseInt(aStr = 6)
    // trying parseInt(bStr = 2)
    // trying divide(aNum = 6, bNum = 2)
    // stringDivideBy2("6", "2") = Some(3)

    println(s"""stringDivideBy2("6", "0") = ${stringDivideBy2("6", "0")}""")
    // trying parseInt(aStr = 6)
    // trying parseInt(bStr = 0)
    // trying divide(aNum = 6, bNum = 0)
    // stringDivideBy2("6", "0") = None

    //Fail early
    println(s"""stringDivideBy2("6", "foo") = ${stringDivideBy2("6", "foo")}""")
    // trying parseInt(aStr = 6)
    // trying parseInt(bStr = foo)
    // stringDivideBy2("6", "foo") = None

    //Fail early
    println(s"""stringDivideBy2("bar", "2") = ${stringDivideBy2("bar", "2")}""")
    // trying parseInt(aStr = bar)
    // stringDivideBy2("bar", "2") = None
  }

  def listMonads(): Unit = {
    /**
     * New mental model of `flatMap`
     *
     * function that return Lists === function with multiple return values
     *   => flatMap becomes a construct that calculates results
     *      from permutations ons and combinations of intermediate values.
     **/
    def numbersBetween(min: Int, max: Int): List[Int] =
      (min to max).toList

    /**
     * New mental model of `flatMap` cont'd:
     *
     * For example, in the for comprehension above, there are three possible
     * values of x and two possible values of y.
     * This means there are six possible values of the overall expression.
     * flatMap is genera ng these combinations from our code,
     * which simply says “get x from here and y from over there”.
     */
    val a = for {
      x <- numbersBetween(1, 3) //3 possible values (List elements) of x
      y <- numbersBetween(4, 5) //2 possible values (List elements) of y
    } yield (x, y)

    println(a)
    //List((1,4), (1,5), (2,4), (2,5), (3,4), (3,5))
  }

  def futureMonads(): Unit = {
    import scala.concurrent.Future
    import scala.concurrent.ExecutionContext.Implicits.global
    import scala.concurrent.duration._

    def getTrafficFromHost(hostname: String): Future[Int] =
      ??? // grab traffic information using a network client

    def getTrafficFromAllHosts: Future[Int] =
      for {
        traffic1 <- getTrafficFromHost("host1")
        traffic2 <- getTrafficFromHost("host2")
        traffic3 <- getTrafficFromHost("host3")
      } yield traffic1 + traffic2 + traffic3

    def getTrafficFromAllHostsFlatMap: Future[Int] =
      getTrafficFromHost("host1").flatMap { traffic1 =>
        getTrafficFromHost("host2").flatMap { traffic2 =>
          getTrafficFromHost("host3").map { traffic3 =>
            traffic1 + traffic2 + traffic3
          }
        } }
  }

  def monadTypeClasses(): Unit ={
    import cats.Monad
    import cats.instances.option._
    import cats.instances.list._

    val opt1 = Monad[Option].pure(3)
    // opt1: Option[Int] = Some(3)

    val opt2 = Monad[Option].flatMap(opt1)(a => Some(a + 2))
    // opt2: Option[Int] = Some(5)

    val opt3 = Monad[Option].map(opt2)(a => 100 * a)
    // opt3: Option[Int] = Some(500)

    val list1 = Monad[List].pure(3)
    // list1: List[Int] = List(3)

    val list2 = Monad[List].
      flatMap(List(1, 2, 3))(x => List(x, x*10))
    // list2: List[Int] = List(1, 10, 2, 20, 3, 30)

    val list3 = Monad[List].map(list2)(_ + 123)
    // list3: List[Int] = List(124, 133, 125, 143, 126, 153)
  }

  def defaultInstances(): Unit = {
    import cats.Monad
    import cats.instances.option._

    Monad[Option].flatMap(Option(1))(x => Option(x*2))
    // res0: Option[Int] = Some(2)

    import cats.instances.list._
    Monad[List].flatMap(List(1, 2, 3))(x => List(x, x*10))
    // res1: List[Int] = List(1, 10, 2, 20, 3, 30)
    /**
     * With the new mental model
     * For possible values x = 1, 2, 3
     * There are 3 possible values y = x, x*10
     * So in total, there are 6 values flattened
     */

    import cats.instances.vector._
    Monad[Vector].flatMap(Vector(1, 2, 3))(x => Vector(x, x*10))
    // res2: Vector[Int] = Vector(1, 10, 2, 20, 3, 30)

    import cats.instances.future._
    import scala.concurrent._
    import scala.concurrent.duration._

    // val fm = Monad[Future]
    // <console>:37: error: could not find implicit value for
    // parameter instance: cats.Monad[scala.concurrent.Future]
    // val fm = Monad[Future]
    // ^

    import scala.concurrent.ExecutionContext.Implicits.global
    val fm = Monad[Future]
    // fm: cats.Monad[scala.concurrent.Future] = cats.instances.
    // FutureInstances$$anon$1@1c54d4ad

    /**
     * The below 3 forms are equivalent:
     */
    val result = Await.result(
      fm.flatMap(fm.pure(1)) { x =>
        fm.pure(x + 2)
      },
      1.second
    )
    println(result)

    val result2 = Await.result(
      fm.flatMap(Future(1)) { x => //it is like Future(1).flatMap( x => ...
        Future(x + 2)
      },
      1.second
    )
    println(result2)

    val result3 = Await.result(
      for {
        x <- fm.pure(1)
        y <- fm.pure(x + 2)
      } yield y,
      1.second
    )
    println(result3)
  }

  def monadSyntax(): Unit = {
    import cats.syntax.applicative._
    import cats.instances.option._
    import cats.instances.list._

    1.pure[Option]
    // res4: Option[Int] = Some(1)

    1.pure[List]
    // res5: List[Int] = List(1)

    import scala.language.higherKinds
    import cats.Monad
    import cats.syntax.functor._
    import cats.syntax.flatMap._

    def sumSquare[M[_] : Monad](a: M[Int], b: M[Int]): M[Int] =
      a.flatMap(x => b.map(y => x*x + y*y))

    import cats.instances.option._
    import cats.instances.list._

    sumSquare(Option(3), Option(4))
    // res8: Option[Int] = Some(25)

    sumSquare(List(1, 2, 3), List(4, 5))
    // res9: List[Int] = List(17, 26, 20, 29, 25, 34)

    /**
     *  We can rewrite this code using for comprehensions.
     */
    def sumSquareFor[M[_] : Monad](a: M[Int], b: M[Int]): M[Int] =
      for {
        x <- a
        y <- b
      } yield x*x + y*y

    sumSquareFor(Option(3), Option(4))
    // res10: Option[Int] = Some(25)

    sumSquare(List(1, 2, 3), List(4, 5))
    // res11: List[Int] = List(17, 26, 20, 29, 25, 34)
  }

  def identityMonad(): Unit = {
    import scala.language.higherKinds
    import cats.Monad
    import cats.syntax.functor._
    import cats.syntax.flatMap._

    def sumSquare[M[_] : Monad](a: M[Int], b: M[Int]): M[Int] =
      for {
        x <- a
        y <- b
      } yield x*x + y*y

    /**
     * This method works well on Options and Lists but we can’t call it
     * passing in plain values:
     */
    //sumSquare(3, 4)
    // <console>:22: error: no type parameters for method sumSquare:
    // (a: M[Int], b: M[Int])(implicit evidence$1: cats.Monad[M])M
    //   [Int] exist so that it can be applied to arguments (Int, Int
    // )
    // --- because ---
    // argument expression's type is not compatible with formal
    // parameter type;
    // found : Int
    // required: ?M[Int]
    // sumSquare(3, 4)
    // ^
    // <console>:22: error: type mismatch;
    // found : Int(3)
    // required: M[Int]
    // sumSquare(3, 4)
    // ^
    // <console>:22: error: type mismatch;
    // found : Int(4)
    // required: M[Int]
    // sumSquare(3, 4)
    // ^

    /**
     * It would be incredibly useful if we could use sumSquare with a
     * combination of monadic and non-monadic parameters.
     */
    type Id[A] = A
    println(sumSquare(3 : Id[Int], 4 : Id[Int]))
    // res2: cats.Id[Int] = 25

    val a = "Dave" : Id[String]
    println(a)
    // res3: cats.Id[String] = Dave

    val b = 123 : Id[Int]
    println(b)
    // res4: cats.Id[Int] = 123

    val c = List(1, 2, 3) : Id[List[Int]]
    println(c)
    // res5: cats.Id[List[Int]] = List(1, 2, 3)

    val aa = Monad[Id].pure(3)
    // a: cats.Id[Int] = 3
    val bb = Monad[Id].flatMap(aa)(_ + 1)
    // b: cats.Id[Int] = 4

    import cats.syntax.flatMap._
    import cats.syntax.functor._

    for {
      x <- aa
      y <- bb
    } yield x + y
    // res6: cats.Id[Int] = 7

    /**
     * The main use for Id is to write generic methods like sumSquare
     * that operate on monadic and non-monadic data types. For example,
     * we can run code asynchronously in production using Future and
     * synchronously in test using Id:
     */
    import scala.concurrent._
    import scala.concurrent.duration._
    import scala.concurrent.ExecutionContext.Implicits.global
    import cats.instances.future._
    // In production: async
    Await.result(sumSquare(Future(3), Future(4)), 1.second)
    // res8: Int = 25

    // In test: sync
    sumSquare(aa, bb)
    // res10: cats.Id[Int] = 25
  }

  def identityExercises(): Unit ={
    import cats.Id
    def pure[A](value: A): Id[A] =
      value

    pure(123)
    // res14: cats.Id[Int] = 123

    def map[A, B](initial: Id[A])(func: A => B): Id[B] =
      func(initial)

    map(123)(_ * 2)
    // res15: cats.Id[Int] = 246

    def flatMap[A, B](initial: Id[A])(func: A => Id[B]): Id[B] =
      func(initial)
    // flatMap: [A, B](initial: cats.Id[A])(func: A => cats.Id[B])
    // cats.Id[B]

    flatMap(123)(_ * 2)
    // res16: cats.Id[Int] = 246

    import cats.Monad
    import cats.syntax.flatMap._
    import cats.syntax.functor._
    def sumSquare[M[_] : Monad](a: M[Int], b: M[Int]): M[Int] =
      for {
        x <- a
        y <- b
      } yield x*x + y*y

    sumSquare(3 : Id[Int], 4 : Id[Int])
  }

  def either(): Unit ={
    /**
     * In Scala 2.11, Either was unbiased. It had no map or flatMap method:
     * Scala 2.11 example (Hm? it compiles in 2.12)
     */
    Right(123).flatMap(x => Right(x * 2))
    // In Scala 2.11
    // <console>:12: error: value flatMap is not a member
    // of scala.util.Right[Nothing, Int]
    // Right(123).flatMap(x => Right(x * 2))
    // ^

    /**
     * Valid in Scala 2.11 and Scala 2.12
     * Instead of calling map or flatMap directly, we had to decide which side
     *  we wanted to be the “correct” side by taking a left- or right-projection
     */
    val either1: Either[String, Int] = Right(123)
    // either1: Either[String,Int] = Right(123)

    val either2: Either[String, Int] = Right(321)
    // either2: Either[String,Int] = Right(321)

    println(either1.right.flatMap(x => Right(x * 2)))
    // res2: scala.util.Either[String,Int] = Right(246)

    println(either2.left.flatMap(x => Left(x + "!!!")))
    // res3: scala.util.Either[String,Int] = Right(321)
    /**
     * This made the Scala 2.11 version of Either incovenient to use as a
     * monad. If we wanted to use for comprehensions, for example, we had
     * to insert calls to .right in every generator clause:
     */

    for {
      a <- either1.right
      b <- either2.right
    } yield a + b
    // res4: scala.util.Either[String,Int] = Right(444)

    /**
     * In Scala 2.12, Either was redesigned.
     * Either can be used as Monad
     */
    for {
      a <- either1
      b <- either2
    } yield a + b
    // res5: scala.util.Either[String,Int] = Right(444)

    import cats.syntax.either._
    val a = 3.asRight[String]
    // a: Either[String,Int] = Right(3)
    val b = 4.asRight[String]
    // b: Either[String,Int] = Right(4)
    val result = for {
      x <- a
      y <- b
    } yield x*x + y*y
    // res6: scala.util.Either[String,Int] = Right(25)

    println(result)

    /**
     * The asLeft and asRight methods have advantages over
     * Left.apply and Right.apply in terms of type inference. The
     * following code provides an example:
     **
     *def countPositive(nums: List[Int]) =
     *nums.foldLeft(Right(0)) { (accumulator, num) =>
     *if(num > 0) {
     *accumulator.map(_ + 1)
     *} else {
     *Left("Negative. Stopping!")
     *}
     * }
     **
     *1. the type of the accumulator ends up being Right instead of Either;
     *2. we didn’t specify type parameters for Right.apply so the compiler
     *infers the left parameter as Nothing
    */
    // <console>:18: error: type mismatch;
    // found   : scala.util.Either[Nothing,Int]
    // required: scala.util.Right[Nothing,Int]
    // accumulator.map(_ + 1)
    // ^
    // <console>:20: error: type mismatch;
    // found   : scala.util.Left[String,Nothing]
    // required: scala.util.Right[Nothing,Int]
    // Left("Negative. Stopping!")
    // ^

    def countPositive(nums: List[Int]) =
      // difference: 0.asRight - Switching to asRight avoids both of these problems.
      // It as a return type of Either
      nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
        if(num > 0) {
          accumulator.map(_ + 1)
        } else {
          Left("Negative. Stopping!")
        }
      }

    countPositive(List(1, 2, 3))
    // res7: Either[String,Int] = Right(3)
    countPositive(List(1, -2, 3))
    // res8: Either[String,Int] = Left(Negative. Stopping!)

    println(Either.catchOnly[NumberFormatException]("foo".toInt))
    // Left(java.lang.NumberFormatException: For input string: "foo")

    println(Either.catchNonFatal(sys.error("Badness")))
    // Left(java.lang.RuntimeException: Badness)

    println(Either.fromTry(scala.util.Try("foo".toInt)))
    // Left(java.lang.NumberFormatException: For input string: "foo")

    println(Either.fromOption[String, Int](None, "Badness"))
    // Left(Badness)

    /**
     * 4.4.3 Transforming Eithers
     */

    import cats.syntax.either._

    "Error".asLeft[Int].getOrElse(0)
    // res9: Int = 0

    "Error".asLeft[Int].orElse(2.asRight[String])
    // res10: Either[String,Int] = Right(2)

    -1.asRight[String].ensure("Must be non-negative!")(_ > 0)
    // res11: Either[String,Int] = Left(Must be non-negative!)

    val t1 = "error".asLeft[String] recover {
      case str: String =>
        "Recovered from " + str
    }
    println(s""""error".asLeft[String] = ${"error".asLeft[String]}""")
    println(s"t1: $t1")
    // res12: Either[String,String] = Right(Recovered from error)

    val t2 = "error".asLeft[String] recoverWith {
      case str: String =>
        Right("Recovered from " + str)
    }
    println(s"t2: $t2")
    // res13: Either[String,String] = Right(Recovered from error)

    "foo".asLeft[Int].leftMap(_.reverse)
    // res14: Either[String,Int] = Left(oof)

    6.asRight[String].bimap(_.reverse, _ * 7)
    // res15: Either[String,Int] = Right(42)

    "bar".asLeft[Int].bimap(_.reverse, _ * 7)
    // res16: Either[String,Int] = Left(rab)

    123.asRight[String]
    // res17: Either[String,Int] = Right(123)

    123.asRight[String].swap
    // res18: scala.util.Either[Int,String] = Left(123)


    /**
     * Fail-Fast Error Handling
     *  Either is typically used to implement fail-fast error handling.
     */
    for {
      a <- 1.asRight[String]
      b <- 0.asRight[String]
      c <- if(b == 0) "DIV0".asLeft[Int] else (a / b).asRight[String
        ]
    } yield c * 100
    // res19: scala.util.Either[String,Int] = Left(DIV0)

    /**
     * 4.4.5 Representing Errors
     */
    sealed trait LoginError extends Product with Serializable
    final case class UserNotFound(
      username: String
    ) extends LoginError

    final case class PasswordIncorrect(
      username: String
    ) extends LoginError

    case object UnexpectedError extends LoginError
    case class  User(username: String, password: String)

    type LoginResult = Either[LoginError, User]

    // Choose error-handling behaviour based on type:
    def handleError(error: LoginError): Unit =
      error match {
        case UserNotFound(u) =>
          println(s"User not found: $u")
        case PasswordIncorrect(u) =>
          println(s"Password incorrect: $u")
        case UnexpectedError =>
          println(s"Unexpected error")
      }
    val result1: LoginResult = User("dave", "passw0rd").asRight
    // result1: LoginResult = Right(User(dave,passw0rd))

    val result2: LoginResult = UserNotFound("dave").asLeft
    // result2: LoginResult = Left(UserNotFound(dave))

    result1.fold(handleError, println)
    // User(dave,passw0rd)

    result2.fold(handleError, println)
    // User not found: dave
  }

  def eitherTransform(): Unit ={
    import cats.syntax.either._

    /**
     * cats.syntax.either adds a number of useful methods to Either.
     * We can use orElse and getOrElse to extract values from the right side:
     *   the right value or return a default:
     */
    //def asLeft[B]: Either[A, B] = Left(obj)
    //    asLeft[RightType]
    println("Errrrror".asLeft[Int].getOrElse(0))
    // res9: Int = 0

    //def asRight[B]: Either[B, A] = Right(obj)
    //    asRight[LeftType]
    println("Errrrror".asRight[Int].getOrElse(0))
    //Errrrror

    println("Errrrror".asLeft[Int])
    //Left("Errrror") : Either[String, Int]

    println(2.asRight[String])
    //Right(2) : Either[String, Int]

    println("Errrrror".asLeft[Int].orElse(2.asRight[String]))
    //Right(2) : Either[String,Int]

    //The ensure method allows us to check whether a wrapped value satisfies a predicate:
    //  def ensure[AA >: A](onFailure: => AA)(f: B => Boolean): Either[AA, B]
    println(-1.asRight[String].ensure("Must be non-negative!")(_ > 0))
    // res11: Either[String,Int] = Left(Must be non-negative!)

    "error".asLeft[String] recover {
      case str: String =>
      "Recovered from " + str
    }
    // res12: Either[String,String] = Right(Recovered from error)

    "error".asLeft[String] recoverWith {
    case str: String =>
    Right("Recovered from " + str)
    }
    // res13: Either[String,String] = Right(Recovered from error)

    "foo".asLeft[Int].leftMap(_.reverse)
    // res14: Either[String,Int] = Left(oof)

    6.asRight[String].bimap(_.reverse, _ * 7)
    // res15: Either[String,Int] = Right(42)

    "bar".asLeft[Int].bimap(_.reverse, _ * 7)
    // res16: Either[String,Int] = Left(rab)

    123.asRight[String]
    // res17: Either[String,Int] = Right(123)

    123.asRight[String].swap
    // res18: scala.util.Either[Int,String] = Left(123)
  }

  def evalMonad(): Unit = {
    println("val ---- ")
    val x = {
      println("Computing X");
      1 + 1
    }
    // Computing X
    // x: Int = 2

    println("let's go!")
    println(x)  // first access
    // res0: Int = 2

    println(x) // second access
    // res1: Int = 2

    println("def ---- ")

    def y = {
      println("Computing Y")
      1 + 1
    }

    // y: Int

    println("let's go 2")
    println(y) // first access
    // Computing Y
    // res2: Int = 2

    println(y)  // second access
    // Computing Y
    // res3: Int = 2

    println("lazy ---- ")
    lazy val z = {
      println("Computing Z")
      1 + 1
    }
    // z: Int = <lazy>

    println("let's go 2")
    println(z)  // first access
    // Computing Z
    // res4: Int = 2
    println(z)  // second access
    // res5: Int = 2

    /**
     * Eval has three subtypes: Eval.Now, Eval.Later, and Eval.Always.
     */
    import cats.Eval
    // import cats.Eval
    val now = Eval.now(1 + 2)
    // now: cats.Eval[Int] = Now(3)

    val later = Eval.later(3 + 4)
    // later: cats.Eval[Int] = cats.Later@49373f5e

    val always = Eval.always(5 + 6)
    // always: cats.Eval[Int] = cats.Always@53dd8e4b

    println(now.value)
    // res6: Int = 3

    println(later.value)
    // res7: Int = 7

    println(always.value)
    // res8: Int = 11
  }

  def evalMonad2(): Unit = {
    import cats.Eval

    println("\nEval.now --- ")
    val x = Eval.now {
      println("Computing X")
      1+1
    }
    // Computing X

    println("first access")
    // x: cats.Eval[Int] = Now(2)
    x.value // first access
    // res9: Int = 2

    println("second access")
    x.value // second access
    // res10: Int = 2

    println("\nEval.always --- ")
    val y = Eval.always {
      println("Computing Y")
      1+1
    }
    // y: cats.Eval[Int] = cats.Always@253eef84

    println("first access")
    y.value // first access
    // Computing Y
    // res11: Int = 2

    println("second access")
    y.value // second access
    // Computing Y
    // res12: Int = 2

    println("\nEval.later --- ")
    val z = Eval.later {
      println("Computing Z")
      1+1
    }
    // z: cats.Eval[Int] = cats.Later@a81d4d5

    println("first access")
    z.value // first access
    // Computing Z
    // res13: Int = 2

    println("second access")
    z.value // second access
    // res14: Int = 2

    println("\ngreeting ---------")
    val greeting = Eval.always {
      println("Step 1")
      "Hello"
    }.map { str =>
      println("Step 2")
      str + " world"
    }
    // greeting: cats.Eval[String] = cats.Eval$$anon$8@3c88d726

    println("First Access")
    greeting.value
    // Step 1
    // Step 2
    // res15: String = Hello world
    println("Second Access")
    greeting.value
    println("Thrid Access")
    greeting.value


    println("\nfor comprehension ---- ")
    val ans = for {
      a <- Eval.now    { println("Calculating A") ; 40 }
      b <- Eval.always { println("Calculating B") ; 2  }
    } yield {
      println("Adding A and B")
      a+b
    }
    // Calculating A
    // ans: cats.Eval[Int] = cats.Eval$$anon$8@9284e40

    println("first access")
    ans.value // first access
    // Calculating B
    // Adding A and B
    // res16: Int = 42

    println("second access")
    ans.value // second access
    // Calculating B
    // Adding A and B
    // res17: Int = 42

    println("\nmemoize --------")
    val saying = Eval.always {
      println("Step 1")
      "The cat"
    }.map { str =>
      println("Step 2")
      s"$str sat on"
    }.memoize.map { str =>
      println("Step 3")
      s"$str the mat"
    }

    // saying: cats.Eval[String] = cats.Eval$$anon$8@397aee40
    saying.value // first access
    // Step 1
    // Step 2
    // Step 3
    // res18: String = The cat sat on the mat

    //Though you used Eval.always, Step 1 and 2 are memoized
    saying.value // second access
    // Step 3
    // res19: String = The cat sat on the mat
  }

  def stackOverFlow(): Unit ={
    def factorial(n: BigInt): BigInt =
      if(n == 1) n else n * factorial(n - 1)

    factorial(50000)
    // java.lang.StackOverflowError
    //   ...
  }

  def stillStackOverFlow(): Unit ={
    import cats.Eval

    def factorial(n: BigInt): Eval[BigInt] =
      if(n == 1) Eval.now(n) else factorial(n - 1).map(_ * n)

    factorial(50000).value
    // java.lang.StackOverflowError
    //   ...
  }

  def trampoline(): Unit ={
    import cats.Eval

    def factorial(n: BigInt): Eval[BigInt] =
      if(n == 1) {
        Eval.now(n)
      } else {
        Eval.defer(factorial(n - 1).map(_ * n))
      }

    (factorial(50000).value)
  }

  def exercise1(): Unit = {
    def foldRight[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
      as match {
        case head :: tail =>
          fn(head, foldRight(tail, acc)(fn))
        case Nil =>
          acc
      }
    foldRight2((1 to 100000).toList, 0)(_ + _)

    import cats.Eval

    //See the difference in the signatures
    //  def foldRight[A, B](as: List[A], acc: B      )(fn: (A, B)       => B      ): B =
    def foldRightEval[A, B](as: List[A], acc: Eval[B])(fn: (A, Eval[B]) => Eval[B]): Eval[B] =
      //Inside the match expression, implementation is the same:
      as match {
        case head :: tail =>
          Eval.defer(fn(head, foldRightEval(tail, acc)(fn)))
        case Nil =>
          acc }

    //To make the signature in line
    //def foldRight[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
    def foldRight2[A, B](as: List[A], acc: B)(fn: (A, B) => B): B =
      foldRightEval(as, Eval.now(acc)) { (a, b) =>
        b.map(fn(a, _))
      }.value

    foldRight2((1 to 100000).toList, 0)(_ + _)
    // res22: Int = 705082704
  }

  def writerMonad(): Unit ={
    import cats.data.Writer
    import cats.instances.vector._

    println(
      Writer(Vector(
        "It was the best of times",
        "It was the worst of times"
      ), 123)
    )
    // res0: cats.data.WriterT[cats.Id,scala.collection.immutable.
    // Vector[String],Int] = WriterT((Vector(It was the best of times, It was the worst of times),123))

    /**
     * A Writer[W, A] carries two values: a log of type W and a result of type
     * In the spirit of code reuse, Cats implements Writer in terms of another type, WriterT.
     */
    //type Writer[W, A] = WriterT[Id, W, A]

    import cats.syntax.applicative._ // `pure` method
    type Logged[A] = Writer[Vector[String], A]

    println(123.pure[Logged])
    // res2: Logged[Int] = WriterT((Vector(),123))

    /**
     * If we have a log and no result, we can create a Writer[Unit] using the tell syntax
     */
    import cats.syntax.writer._
    Vector("msg1", "msg2", "msg3").tell
    // res3: cats.data.Writer[scala.collection.immutable.Vector[String],Unit] = WriterT((Vector(msg1, msg2, msg3),()))
    //                                                                                        Unit, no result -> ^()

    import cats.syntax.writer._
    val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
    // a:    cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(msg1, msg2, msg3),123))

    val b = 123.writer(Vector("msg1", "msg2", "msg3"))
    // b:    cats.data.Writer[scala.collection.immutable.Vector[String],Int] = WriterT((Vector(msg1, msg2, msg3),123))


    /**
     * We can extract the result and log from a Writer using the
     *   * `value` and
     *   * `written`
     * methods respectively:
     */
    a.value
    // res4: cats.Id[Int] = 123
    a.written
    // res5: cats.Id[scala.collection.immutable.Vector[String]] = Vector(msg1, msg2, msg3)

    /**
     * Or we can extract log and result at the same  me using the run method:
     */
    val (log, result) = b.run
    // log: scala.collection.immutable.Vector[String] = Vector(msg1,msg2, msg3)
    // result: Int = 123
  }

  def writerMonadTransform(): Unit ={
    import cats.data.{Writer}
    import cats.syntax.applicative._ // `pure` method
    import cats.syntax.writer._      // `writer` method
    import cats.instances.vector._

    type Logged[A] = Writer[Vector[String], A]

    //def pure[F[_]](implicit F: Applicative[F]): F[A] = F.pure(a)
    println(10.pure[Logged])
    //WriterT((Vector(),10))

    println(Vector("a", "b", "c").tell)
    //WriterT((Vector(a, b, c),())) <- tell has no result

    println(32.writer(Vector("x", "y", "z")))
    //WriterT((Vector(x, y, z),32))

    /**
     * flatMap actually appends the logs from the source Writer and the re- sult of the user’s sequencing func on.
     */
    val writer1 = for {
      a <- 10.pure[Logged]
      _ <- Vector("a", "b", "c").tell
      b <- 32.writer(Vector("x", "y", "z"))
    } yield a + b
    // writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))
    println("writer1")
    println(writer1.run)
    // res6: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z),42)

    /**
     * In addition to transforming the result with map and flatMap,
     * we can transform the log in a Writer with the mapWritten method:
     */
    val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
      // writer2: cats.data.WriterT[cats.Id,scala.collection.immutabl.Vector[String],Int]
      // = WriterT((Vector(A, B, C, X, Y, Z),42))

    println("writer2")
    println(writer2.run)
    // res7: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(A, B, C, X, Y, Z),42)

    /**
     * We can tranform both log and result simultaneously using bimap or mapBoth.
     */
    val writer3 = writer1.bimap(
      log    => log.map(_.toUpperCase),
      result => result * 100
    )
    // writer3: cats.data.WriterT[cats.Id,scala.collection.immutable
    //.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),4200))

    println("writer3")
    println(writer3.run)
    // res8: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(A, B, C, X, Y, Z),4200)

    val writer4 = writer1.mapBoth { (log, result) =>
      val log2    = log.map(_ + "!")
      val result2 = result * 1000
      (log2, result2)
    }
    // writer4: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int]
    // = WriterT((Vector(a!, b!, c!, x!, y!, z!),42000))

    println("writer4")
    println(writer4.run)
    // res9: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(a!, b!, c!, x!, y!, z!),42000)

    /**
     * Finally, we can clear the log with the reset method and swap log and result with the swap method:
     */
    val writer5 = writer1.reset
    // writer5: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(),42))

    println("writer5")
    println(writer5.run)
    // res10: cats.Id[(Vector[String], Int)] = (Vector(),42)
    val writer6 = writer1.swap
    // writer6: cats.data.WriterT[cats.Id,Int,Vector[String]] = WriterT((42,Vector(a, b, c, x, y, z)))

    println("writer6")
    println(writer6.run)
    // res11: cats.Id[(Int, Vector[String])] = (42,Vector(a, b, c, x, y, z))
  }

  def exerciseWriterMonad(): Unit ={
    def slowly[A](body: => A) =
      try body finally Thread.sleep(100)

    def factorial(n: Int): Int = {
      val ans = slowly(if(n == 0) 1 else n * factorial(n - 1))
      println(s"fact $n $ans")
      ans
    }

    factorial(5)
    // fact 0 1
    // fact 1 1
    // fact 2 2
    // fact 3 6
    // fact 4 24
    // fact 5 120
    // res13: Int = 120


    import scala.concurrent._
    import scala.concurrent.ExecutionContext.Implicits.global
    import scala.concurrent.duration._

    /**
     * Let's do this parallely!
     *  -> Interleaving log messages from two future executions
     */
    println()
    Await.result(Future.sequence(Vector(
      Future(factorial(3)),
      Future(factorial(3))
    )), 5.seconds)
    // fact 0 1
    // fact 0 1
    // fact 1 1
    // fact 1 1
    // fact 2 2
    // fact 2 2
    // fact 3 6
    // fact 3 6
    // res14: scala.collection.immutable.Vector[Int] =
    //   Vector(120, 120)

    /**
     * Solution
     */
    println()
    //We’ll start by defining a type alias for Writer so we can use it with pure syntax:
    import cats.data.Writer
    import cats.syntax.applicative._ // `pure` method
    import cats.instances.vector._

    type Logged[A] = Writer[Vector[String], A]
    42.pure[Logged]

    //We’ll import the tell syntax as well:
    import cats.syntax.writer._
    Vector("Message").tell
    // res16: cats.data.Writer[scala.collection.immutable.Vector[String],Unit] = WriterT((Vector(Message),()))

    //Finally, we’ll import the Semigroup instance for Vector. We need this to map and flatMap over Logged:
    import cats.instances.vector._
    41.pure[Logged].map(_ + 1)
    // res17: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(),42))

    def factorial2(n: Int): Logged[Int] =
      for {
        ans <- if(n == 0) {
          1.pure[Logged]
        } else {
          slowly(factorial2(n - 1).map(_ * n))
        }
        _   <- Vector(s"fact $n $ans").tell
      } yield ans

    val (log, result) = factorial2(5).run
    // log: Vector[String] = Vector(fact 0 1, fact 1 1, fact 2 2, fact 3 6, fact 4 24, fact 5 120)
    // result: Int = 120

    val Vector((logA, ansA), (logB, ansB)) =
      Await.result(Future.sequence(Vector(
        Future(factorial2(5).run),
        Future(factorial2(5).run)
      )), 5.seconds)
    println(logA)
    // logA: Vector[String] = Vector(fact 0 1, fact 1 1, fact 2 2, fact 3 6, fact 4 24, fact 5 120)
    // ansA: Int = 120
    println(logB)
    // logB: Vector[String] = Vector(fact 0 1, fact 1 1, fact 2 2, fact 3 6, fact 4 24, fact 5 120)
    // ansB: Int = 120
  }

  def stateMonad(): Unit = {
    import cats.data.State
    val a = State[Int, String] { state =>
      (state, s"The state is $state")
    }
    println(a)
    // a: cats.data.State[Int,String] = cats.data.StateT@ad944e3

    // Get the state and the result:
    val (state1, result1) = a.run(10).value
    // state: Int = 10
    // result: String = The state is 10

    // Get the state, ignore the result:
    val state2 = a.runS(10).value
    // state: Int = 10

    // Get the result, ignore the state:
    val result2 = a.runA(10).value

    println(state1)
    println(state2)
    println(result1)
    println(result2)

    /**
     * Composing and transforming state
     */
    val step1 = State[Int, String] { num =>
      val ans = num + 1
      (ans, s"Result of step1: $ans")
    }
    // step1: cats.data.State[Int,String] = cats.data.StateT@e680f25
    println(s"step1: ${step1}")

    val step2 = State[Int, String] { num =>
      val ans = num * 2
      (ans, s"Result of step2: $ans")
    }
    println(s"step2: ${step2}")
    // step2: cats.data.State[Int,String] = cats.data.StateT@1119acde

    val both = for {
      a <- step1
      b <- step2
    } yield (b, a)

    /**
     * Hmmmm why the tuple becomes cats.data.StateT ... ?
     */
    println(s"both: ${both}")
    // both: cats.data.StateT[cats.Eval,Int,(String, String)] = cats.data.StateT@2d4d4ff3

    val (state3, result3) = both.run(20).value
    // state: Int = 42
    // result: (String, String) = (Result of step1: 21,Result of step2: 42)

    println(s"state3: ${state3}")
    println(s"result3: ${result3}")

    /**
     * Using flatMap & map intead of for comprehension.
     * Hmmmm why the tuple becomes cats.data.StateT ... ?
     */
    val bothequivalent = step1.flatMap {
      a => step2.map(b => (a, b))
    }
    println(s"bothequivalent: ${bothequivalent}")
    //bothequivalent: cats.data.StateT@31b0f1a8

    val (state4, result4) = bothequivalent.run(20).value
    println(s"state4: ${state4}")
    println(s"result4: ${result4}")
  }

  def stateProgram(): Unit =  {
    import cats.data.State

    val getDemo = State.get[Int]
    // getDemo: cats.data.State[Int,Int] = cats.data.StateT@26c929b1
    getDemo.run(10).value
    // res3: (Int, Int) = (10,10)
    val setDemo = State.set[Int](30)
    // setDemo: cats.data.State[Int,Unit] = cats.data.StateT@1748341a
    setDemo.run(10).value
    // res4: (Int, Unit) = (30,())
    val pureDemo = State.pure[Int, String]("Result")
    // pureDemo: cats.data.State[Int,String] = cats.data.StateT@1826901
    pureDemo.run(10).value
    // res5: (Int, String) = (10,Result)
    val inspectDemo = State.inspect[Int, String](_ + "!")
    // inspectDemo: cats.data.State[Int,String] = cats.data.StateT@77e7bb7e
      inspectDemo.run(10).value
    // res6: (Int, String) = (10,10!)

    val modifyDemo = State.modify[Int](_ + 1)
    // modifyDemo: cats.data.State[Int,Unit] = cats.data.StateT@56cf32b8
    modifyDemo.run(10).value
    // res7: (Int, Unit) = (11,())

    import State._
    val program: State[Int, (Int, Int, Int)] = for {
      a <- get[Int]
      _ <- set[Int](a + 1)
      b <- get[Int]
      _ <- modify[Int](_ + 1)
      c <- inspect[Int, Int](_ * 1000)
    } yield (a, b, c)
    // program: cats.data.State[Int,(Int, Int, Int)] = cats.data.StateT@4996bc50
    val (state, result) = program.run(1).value
    // state: Int = 3
    // result: (Int, Int, Int) = (1,2,3000)
    println(state)
    println(result)
  }

  def main(args: Array[String]): Unit = {
    Wrap("optionsExamples")(optionsExamples)
    Wrap("listMonads")(listMonads)
    Wrap("defaultInstances")(defaultInstances)
    Wrap("identityMonad")(identityMonad)
    Wrap("either")(either)
    Wrap("eitherTransform")(eitherTransform)
    Wrap("evalMonad")(evalMonad)
    Wrap("evalMonad2")(evalMonad2)
    //Wrap("stackOverFlow")(stackOverFlow)
    Wrap("trampoline")(trampoline)
    Wrap("exercise1")(exercise1)
    Wrap("writerMonad")(writerMonad)
    Wrap("writerMonadTransform")(writerMonadTransform)
    Wrap("exerciseWriterMonad")(exerciseWriterMonad)
    Wrap("stateMonad")(stateMonad)
    Wrap("stateProgram")(stateProgram)
  }
}
/*
 * Copyright (c) 2018 Luka Jacobowitz
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cats
package data

import cats.instances.sortedSet._
import cats.kernel._

import scala.collection.immutable._


private[data] object NonEmptySetImpl extends NonEmptySetInstances with Newtype {

  private[cats] def create[A](s: SortedSet[A]): Type[A] =
    s.asInstanceOf[Type[A]]

  private[cats] def unwrap[A](s: Type[A]): SortedSet[A] =
    s.asInstanceOf[SortedSet[A]]


  def fromSet[A](as: SortedSet[A]): Option[NonEmptySet[A]] =
    if (as.nonEmpty) Option(create(as)) else None

  def fromSetUnsafe[A](set: SortedSet[A]): NonEmptySet[A] =
    if (set.nonEmpty) create(set)
    else throw new IllegalArgumentException("Cannot create NonEmptySet from empty set")


  def of[A](a: A, as: A*)(implicit A: Order[A]): NonEmptySet[A] =
    create(SortedSet(a +: as: _*)(A.toOrdering))
  def apply[A](head: A, tail: SortedSet[A])(implicit A: Order[A]): NonEmptySet[A] =
    create(SortedSet(head)(A.toOrdering) ++ tail)
  def one[A](a: A)(implicit A: Order[A]): NonEmptySet[A] = create(SortedSet(a)(A.toOrdering))

  implicit def catsNonEmptySetOps[A](value: NonEmptySet[A]): NonEmptySetOps[A] =
    new NonEmptySetOps(value)
}


sealed class NonEmptySetOps[A](val value: NonEmptySet[A]) {

  private implicit val ordering: Ordering[A] = toSortedSet.ordering
  private implicit val order: Order[A] = Order.fromOrdering

  /**
    * Converts this set to a `SortedSet`
    */
  def toSortedSet: SortedSet[A] = NonEmptySetImpl.unwrap(value)


  /**
    * Adds an element to this set, returning a new `NonEmptySet`
    */
  def add(a: A): NonEmptySet[A] = NonEmptySet.create(toSortedSet + a)

  /**
    * Alias for [[union]]
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 4, 5)
    * scala> nes ++ NonEmptySet.of(1, 2, 7)
    * res0: cats.data.NonEmptySet[Int] = TreeSet(1, 2, 4, 5, 7)
    * }}}
    */
  def ++(as: NonEmptySet[A]): NonEmptySet[A] = union(as)

  /**
    * Alias for [[union]]
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 4, 5)
    * scala> nes | NonEmptySet.of(1, 2, 7)
    * res0: cats.data.NonEmptySet[Int] = TreeSet(1, 2, 4, 5, 7)
    * }}}
    */
  def | (as: NonEmptySet[A]): NonEmptySet[A] = union(as)

  /**
    * Alias for [[diff]]
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 4, 5)
    * scala> nes -- NonEmptySet.of(1, 2, 7)
    * res0: scala.collection.immutable.SortedSet[Int] = TreeSet(4, 5)
    * }}}
    */
  def --(as: NonEmptySet[A]): SortedSet[A] = diff(as)

  /**
    * Alias for [[diff]]
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 4, 5)
    * scala> nes &~ NonEmptySet.of(1, 2, 7)
    * res0: scala.collection.immutable.SortedSet[Int] = TreeSet(4, 5)
    * }}}
    */
  def &~(as: NonEmptySet[A]): SortedSet[A] = diff(as)

  /**
    * Alias for [[intersect]]
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 4, 5)
    * scala> nes & NonEmptySet.of(1, 2, 7)
    * res0: scala.collection.immutable.SortedSet[Int] = TreeSet(1, 2)
    * }}}
    */
  def &(as: NonEmptySet[A]): SortedSet[A] = intersect(as)


  /**
    * Removes a key from this set, returning a new `SortedSet`.
    */
  def -(a: A): SortedSet[A] = toSortedSet - a

  /**
    * Applies f to all the elements
    */
  def map[B](f: A => B)(implicit B: Order[B]): NonEmptySet[B] = {
    implicit val bOrdering = B.toOrdering
    NonEmptySetImpl.create(toSortedSet.map(f))
  }


  /**
    * Converts this set to a `NonEmptyList`.
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 3, 4, 5)
    * scala> nes.toNonEmptyList
    * res0: cats.data.NonEmptyList[Int] = NonEmptyList(1, 2, 3, 4, 5)
    * }}}
    */
  def toNonEmptyList: NonEmptyList[A] = NonEmptyList.fromListUnsafe(toSortedSet.toList)

  /**
    * Returns the first element of this set.
    */
  def head: A = toSortedSet.head

  /**
    * Returns all but the first element of this set.
    */
  def tail: SortedSet[A] = toSortedSet.tail

  /**
    * Returns the last element of this set.
    */
  def last: A = toSortedSet.last

  /**
    * Alias for [[contains]]
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 3, 4, 5)
    * scala> nes(3)
    * res0: Boolean = true
    * scala> nes(7)
    * res1: Boolean = false
    * }}}
    */
  def apply(a: A): Boolean = contains(a)

  /**
    * Tests if some element is contained in this set.
    */
  def contains(a: A): Boolean = toSortedSet(a)

  /**
    * Computes the difference of this set and another set.
    */
  def diff(as: NonEmptySet[A]): SortedSet[A] = toSortedSet -- as.toSortedSet

  /**
    * Computes the union between this NES and another NES.
    */
  def union(as: NonEmptySet[A]): NonEmptySet[A] = NonEmptySetImpl.create(toSortedSet ++ as.toSortedSet)

  /**
    * Computes the intersection between this set and another set.
    */
  def intersect(as: NonEmptySet[A]): SortedSet[A] = toSortedSet.filter(as.apply)

  /**
    * Tests whether a predicate holds for all elements of this set.
    */
  def forall(p: A ⇒ Boolean): Boolean = toSortedSet.forall(p)

  /**
    * Tests whether a predicate holds for at least one element of this set.
    */
  def exists(f: A ⇒ Boolean): Boolean = toSortedSet.exists(f)

  /**
    * Returns the first value that matches the given predicate.
    */
  def find(f: A ⇒ Boolean): Option[A] = toSortedSet.find(f)

  /**
    * Returns a new `SortedSet` containing all elements where the result of `pf` is defined.
    */
  def collect[B](pf: PartialFunction[A, B])(implicit B: Order[B]): SortedSet[B] = {
    implicit val ordering = B.toOrdering
    toSortedSet.collect(pf)
  }

  /**
    * Filters all elements of this set that do not satisfy the given predicate.
    */
  def filter(p: A ⇒ Boolean): SortedSet[A] = toSortedSet.filter(p)

  /**
    * Filters all elements of this set that satisfy the given predicate.
    */
  def filterNot(p: A ⇒ Boolean): SortedSet[A] = filter(t => !p(t))


  /**
    * Left-associative fold using f.
    */
  def foldLeft[B](b: B)(f: (B, A) => B): B =
    toSortedSet.foldLeft(b)(f)

  /**
    * Right-associative fold using f.
    */
  def foldRight[B](lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
    Foldable[SortedSet].foldRight(toSortedSet, lb)(f)

  /**
    * Left-associative reduce using f.
    */
  def reduceLeft(f: (A, A) => A): A =
    toSortedSet.reduceLeft(f)

  /**
   * Apply `f` to the "initial element" of this set and lazily combine it
   * with every other value using the given function `g`.
   */
  def reduceLeftTo[B](f: A => B)(g: (B, A) => B): B = {
    tail.foldLeft(f(head))((b, a) => g(b, a))
  }

  /**
    * Left-associative reduce using f.
    */
  def reduceRight(f: (A, Eval[A]) => Eval[A]): Eval[A] =
    reduceRightTo(identity)(f)

  /**
    * Apply `f` to the "initial element" of this set and lazily combine it
    * with every other value using the given function `g`.
    */
  def reduceRightTo[B](f: A => B)(g: (A, Eval[B]) => Eval[B]): Eval[B] =
    Always((head, tail)).flatMap { case (a, ga) =>
      Foldable[SortedSet].reduceRightToOption(ga)(f)(g).flatMap {
        case Some(b) => g(a, Now(b))
        case None => Later(f(a))
      }
    }

  /**
    * Reduce using the Semigroup of A
    */
  def reduce[AA >: A](implicit S: Semigroup[AA]): AA =
    S.combineAllOption(toSortedSet).get

  /**
    * Map a function over all the elements of this set and concatenate the resulting sets into one.
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val nes = NonEmptySet.of(1, 2, 3)
    * scala> nes.concatMap(n => NonEmptySet.of(n, n * 4, n * 5))
    * res0: cats.data.NonEmptySet[Int] = TreeSet(1, 2, 3, 4, 5, 8, 10, 12, 15)
    * }}}
    */
  def concatMap[B](f: A => NonEmptySet[B])(implicit B: Order[B]): NonEmptySet[B] = {
    implicit val ordering = B.toOrdering
    NonEmptySetImpl.create(toSortedSet.flatMap(f andThen (_.toSortedSet)))
  }


  /**
    * Typesafe stringification method.
    *
    * This method is similar to .toString except that it stringifies
    * values according to Show[_] instances, rather than using the
    * universal .toString method.
    */
  def show(implicit A: Show[A]): String =
    s"NonEmpty${Show[SortedSet[A]].show(toSortedSet)}"

  /**
    * Typesafe equality operator.
    *
    * This method is similar to == except that it only allows two
    * NonEmptySet[A] values to be compared to each other, and uses
    * equality provided by Eq[_] instances, rather than using the
    * universal equality provided by .equals.
    */
  def ===(that: NonEmptySet[A]): Boolean =
    Eq[SortedSet[A]].eqv(toSortedSet, that.toSortedSet)

  /**
    * Returns the number of elements in this set.
    */
  def length: Int = toSortedSet.size

  /**
    * Zips this `NonEmptySet` with another `NonEmptySet` and applies a function for each pair of elements.
    *
    * {{{
    * scala> import cats.data.NonEmptySet
    * scala> import cats.implicits._
    * scala> val as = NonEmptySet.of(1, 2, 3)
    * scala> val bs = NonEmptySet.of("A", "B", "C")
    * scala> as.zipWith(bs)(_ + _)
    * res0: cats.data.NonEmptySet[String] = TreeSet(1A, 2B, 3C)
    * }}}
    */
  def zipWith[B, C](b: NonEmptySet[B])(f: (A, B) => C)(implicit C: Order[C]): NonEmptySet[C] = {
    implicit val cOrdering = C.toOrdering
    NonEmptySetImpl.create((toSortedSet, b.toSortedSet).zipped.map(f))
  }

  /**
    * Zips this `NonEmptySet` with its index.
    */
  def zipWithIndex: NonEmptySet[(A, Int)] = {
    NonEmptySetImpl.create(cats.compat.SortedSet.zipWithIndex(toSortedSet))
  }

  /**
    * Groups elements inside this `NonEmptySet` according to the `Order`
    * of the keys produced by the given mapping function.
    */
  def groupBy[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptySet[A]] = {
     reduceLeftTo(a => NonEmptyMap.one(f(a), NonEmptySet.one(a))) { (acc, a) =>
       val key = f(a)
       val result = acc.lookup(key) match {
         case Some(nes) => nes.add(a)
         case _ => NonEmptySet.one(a)
       }
       acc.add((key, result))
     }
  }
}

private[data] sealed abstract class NonEmptySetInstances {
  implicit val catsDataInstancesForNonEmptySet: SemigroupK[NonEmptySet] with Reducible[NonEmptySet] =
    new SemigroupK[NonEmptySet] with Reducible[NonEmptySet] {

      def combineK[A](a: NonEmptySet[A], b: NonEmptySet[A]): NonEmptySet[A] =
        a | b

      override def size[A](fa: NonEmptySet[A]): Long = fa.length.toLong

      override def reduceLeft[A](fa: NonEmptySet[A])(f: (A, A) => A): A =
        fa.reduceLeft(f)

      override def reduce[A](fa: NonEmptySet[A])(implicit A: Semigroup[A]): A =
        fa.reduce

      def reduceLeftTo[A, B](fa: NonEmptySet[A])(f: A => B)(g: (B, A) => B): B = fa.reduceLeftTo(f)(g)

      def reduceRightTo[A, B](fa: NonEmptySet[A])(f: A => B)(g: (A, Eval[B]) => Eval[B]): Eval[B] =
        fa.reduceRightTo(f)(g)

      override def foldLeft[A, B](fa: NonEmptySet[A], b: B)(f: (B, A) => B): B =
        fa.foldLeft(b)(f)

      override def foldRight[A, B](fa: NonEmptySet[A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
        fa.foldRight(lb)(f)

      override def foldMap[A, B](fa: NonEmptySet[A])(f: A => B)(implicit B: Monoid[B]): B =
        B.combineAll(fa.toSortedSet.iterator.map(f))

      override def fold[A](fa: NonEmptySet[A])(implicit A: Monoid[A]): A =
        fa.reduce

      override def find[A](fa: NonEmptySet[A])(f: A => Boolean): Option[A] =
        fa.find(f)

      override def forall[A](fa: NonEmptySet[A])(p: A => Boolean): Boolean =
        fa.forall(p)

      override def exists[A](fa: NonEmptySet[A])(p: A => Boolean): Boolean =
        fa.exists(p)

      override def toList[A](fa: NonEmptySet[A]): List[A] = fa.toSortedSet.toList

      override def toNonEmptyList[A](fa: NonEmptySet[A]): NonEmptyList[A] =
        fa.toNonEmptyList
    }

  implicit def catsDataEqForNonEmptySet[A: Order]: Eq[NonEmptySet[A]] =
    new Eq[NonEmptySet[A]]{
      def eqv(x: NonEmptySet[A], y: NonEmptySet[A]): Boolean = x === y
    }

  implicit def catsDataShowForNonEmptySet[A](implicit A: Show[A]): Show[NonEmptySet[A]] =
    Show.show[NonEmptySet[A]](_.show)

  implicit def catsDataSemilatticeForNonEmptySet[A]: Semilattice[NonEmptySet[A]] = new Semilattice[NonEmptySet[A]] {
    def combine(x: NonEmptySet[A], y: NonEmptySet[A]): NonEmptySet[A] = x | y
  }
}

package io.circe.cats

/**
 * NonEmptyTraverse, also known as Traversable1.
 *
 * `NonEmptyTraverse` is like a non-empty `Traverse`. In addition to the traverse and sequence
 * methods it provides nonEmptyTraverse and nonEmptySequence methods which require an `Apply` instance instead of `Applicative`.
 */
trait NonEmptyTraverse[F[_]] extends Traverse[F] with Reducible[F] { self =>

  /**
   * Given a function which returns a G effect, thread this effect
   * through the running of this function on all the values in F,
   * returning an F[B] in a G context.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.data.NonEmptyList
   * scala> def countWords(words: List[String]): Map[String, Int] = words.groupBy(identity).map { case (k, v) => (k, v.length) }
   * scala> NonEmptyList.of(List("How", "do", "you", "fly"), List("What", "do", "you", "do")).nonEmptyTraverse(countWords)
   * res0: Map[String,cats.data.NonEmptyList[Int]] = Map(do -> NonEmptyList(1, 2), you -> NonEmptyList(1, 1))
   * }}}
   */
  def nonEmptyTraverse[G[_], A, B](fa: F[A])(f: A => G[B]) given Apply[G]: G[F[B]]

  /**
   * Thread all the G effects through the F structure to invert the
   * structure from F[G[A]] to G[F[A]].
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.data.NonEmptyList
   * scala> val x = NonEmptyList.of(Map("do" -> 1, "you" -> 1), Map("do" -> 2, "you" -> 1))
   * scala> val y = NonEmptyList.of(Map("How" -> 3, "do" -> 1, "you" -> 1), Map[String,Int]())
   * scala> x.nonEmptySequence
   * res0: Map[String,NonEmptyList[Int]] = Map(do -> NonEmptyList(1, 2), you -> NonEmptyList(1, 1))
   * scala> y.nonEmptySequence
   * res1: Map[String,NonEmptyList[Int]] = Map()
   * }}}
   */
  def nonEmptySequence[G[_], A](fga: F[G[A]]) given Apply[G]: G[F[A]] =
    nonEmptyTraverse(fga)(identity)

  /**
   * A nonEmptyTraverse followed by flattening the inner result.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.data.NonEmptyList
   * scala> val x = NonEmptyList.of(List("How", "do", "you", "fly"), List("What", "do", "you", "do"))
   * scala> x.nonEmptyFlatTraverse(_.groupByNel(identity) : Map[String, NonEmptyList[String]])
   * res0: Map[String,cats.data.NonEmptyList[String]] = Map(do -> NonEmptyList(do, do, do), you -> NonEmptyList(you, you))
   * }}}
   */
  def nonEmptyFlatTraverse[G[_], A, B](fa: F[A])(f: A => G[F[B]]) given (G: Apply[G], F: FlatMap[F]): G[F[B]] =
    G.map(nonEmptyTraverse(fa)(f))(F.flatten)

  /**
   * Thread all the G effects through the F structure and flatten to invert the
   * structure from F[G[F[A]]] to G[F[A]].
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.data.NonEmptyList
   * scala> val x = NonEmptyList.of(Map(0 ->NonEmptyList.of(1, 2)), Map(0 -> NonEmptyList.of(3)))
   * scala> val y: NonEmptyList[Map[Int, NonEmptyList[Int]]] = NonEmptyList.of(Map(), Map(1 -> NonEmptyList.of(3)))
   * scala> x.nonEmptyFlatSequence
   * res0: Map[Int,cats.data.NonEmptyList[Int]] = Map(0 -> NonEmptyList(1, 2, 3))
   * scala> y.nonEmptyFlatSequence
   * res1: Map[Int,cats.data.NonEmptyList[Int]] = Map()
   * }}}
   */
  def nonEmptyFlatSequence[G[_], A](fgfa: F[G[F[A]]]) given (G: Apply[G], F: FlatMap[F]): G[F[A]] =
    G.map(nonEmptyTraverse(fgfa)(identity))(F.flatten)

  override def traverse[G[_], A, B](fa: F[A])(f: (A) => G[B]) given Applicative[G]: G[F[B]] =
    nonEmptyTraverse(fa)(f)

  def compose[G[_]] given NonEmptyTraverse[G]: NonEmptyTraverse[[x] =>> F[G[x]]] =
    new ComposedNonEmptyTraverse[F, G] {
      val F = self
      val G = NonEmptyTraverse[G]
    }

}

object NonEmptyTraverse {
  def apply[F[_]] given (F: NonEmptyTraverse[F]): NonEmptyTraverse[F] = F

  private[cats] trait Ops {
    given [F[_], A] {
      def (fa: F[A]) nonEmptyTraverse[G[_], B](f: A => G[B]) given (F: NonEmptyTraverse[F], G: Apply[G]): G[F[B]] = F.nonEmptyTraverse(fa)(f)
    }
  }
}
package io.circe.cats.syntax

import io.circe.cats.{Applicative, ApplicativeError}
import io.circe.cats.data.{Ior, OptionT, Validated, ValidatedNec, ValidatedNel}
import io.circe.cats.kernel.Monoid

private[syntax] trait OptionOps {
  given [A] {
    /**
     * Wrap a value in `Some`.
     *
     * `3.some` is equivalent to `Some(3)`, but the former will have an inferred
     * return type of `Option[Int]` while the latter will have `Some[Int]`.
     *
     * Example:
     * {{{
     * scala> import cats.implicits._
     * scala> 3.some
     * res0: Option[Int] = Some(3)
     * }}}
     */
    def (a: A) some: Option[A] = Some(a)

    /**
     * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Invalid]].
     * If the `Option` is `None`, return the provided `B` value in a
     * [[cats.data.Validated.Valid]].
     *
     * Example:
     * {{{
     * scala> import cats.data.Validated
     * scala> import cats.implicits._
     *
     * scala> val error1: Option[String] = Some("error!")
     * scala> error1.toInvalid(3)
     * res0: Validated[String, Int] = Invalid(error!)
     *
     * scala> val error2: Option[String] = None
     * scala> error2.toInvalid(3)
     * res1: Validated[String, Int] = Valid(3)
     * }}}
     */
    def (oa: Option[A]) toInvalid[B](b: => B): Validated[A, B] = oa.fold[Validated[A, B]](Validated.Valid(b))(Validated.Invalid(_))

    /**
     * If the `Option` is a `Some`, wrap its value in a [[cats.data.NonEmptyList]]
     * and return it in a [[cats.data.Validated.Invalid]].
     * If the `Option` is `None`, return the provided `B` value in a
     * [[cats.data.Validated.Valid]].
     *
     * Example:
     * {{{
     * scala> import cats.data.ValidatedNel
     * scala> import cats.implicits._
     *
     * scala> val error1: Option[String] = Some("error!")
     * scala> error1.toInvalidNel(3)
     * res0: ValidatedNel[String, Int] = Invalid(NonEmptyList(error!))
     *
     * scala> val error2: Option[String] = None
     * scala> error2.toInvalidNel(3)
     * res1: ValidatedNel[String, Int] = Valid(3)
     * }}}
     */
    def (oa: Option[A]) toInvalidNel[B](b: => B): ValidatedNel[A, B] =
      oa.fold[ValidatedNel[A, B]](Validated.Valid(b))(Validated.invalidNel)

    /**
     * If the `Option` is a `Some`, wrap its value in a [[cats.data.Chain]]
     * and return it in a [[cats.data.Validated.Invalid]].
     * If the `Option` is `None`, return the provided `B` value in a
     * [[cats.data.Validated.Valid]].
     *
     * Example:
     * {{{
     * scala> import cats.data.ValidatedNec
     * scala> import cats.implicits._
     *
     * scala> val error1: Option[String] = Some("error!")
     * scala> error1.toInvalidNec(3)
     * res0: ValidatedNec[String, Int] = Invalid(Chain(error!))
     *
     * scala> val error2: Option[String] = None
     * scala> error2.toInvalidNec(3)
     * res1: ValidatedNec[String, Int] = Valid(3)
     * }}}
     */
    def (oa: Option[A]) toInvalidNec[B](b: => B): ValidatedNec[A, B] =
      oa.fold[ValidatedNec[A, B]](Validated.Valid(b))(Validated.invalidNec)

    /**
     * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Valid]].
     * If the `Option` is `None`, return the provided `B` value in a
     * [[cats.data.Validated.Invalid]].
     *
     * Example:
     * {{{
     * scala> import cats.data.Validated
     * scala> import cats.implicits._
     *
     * scala> val result1: Option[Int] = Some(3)
     * scala> result1.toValid("error!")
     * res0: Validated[String, Int] = Valid(3)
     *
     * scala> val result2: Option[Int] = None
     * scala> result2.toValid("error!")
     * res1: Validated[String, Int] = Invalid(error!)
     * }}}
     */
    def (oa: Option[A]) toValid[B](b: => B): Validated[B, A] = oa.fold[Validated[B, A]](Validated.Invalid(b))(Validated.Valid(_))

    /**
     * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Valid]].
     * If the `Option` is `None`, wrap the provided `B` value in a [[cats.data.NonEmptyList]]
     * and return the result in a [[cats.data.Validated.Invalid]].
     *
     * Example:
     * {{{
     * scala> import cats.data.ValidatedNel
     * scala> import cats.implicits._
     *
     * scala> val result1: Option[Int] = Some(3)
     * scala> result1.toValidNel("error!")
     * res0: ValidatedNel[String, Int] = Valid(3)
     *
     * scala> val result2: Option[Int] = None
     * scala> result2.toValidNel("error!")
     * res1: ValidatedNel[String, Int] = Invalid(NonEmptyList(error!))
     * }}}
     */
    def (oa: Option[A]) toValidNel[B](b: => B): ValidatedNel[B, A] =
      oa.fold[ValidatedNel[B, A]](Validated.invalidNel(b))(Validated.Valid(_))

    /**
     * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Valid]].
     * If the `Option` is `None`, wrap the provided `B` value in a [[cats.data.Chain]]
     * and return the result in a [[cats.data.Validated.Invalid]].
     *
     * Example:
     * {{{
     * scala> import cats.data.ValidatedNec
     * scala> import cats.implicits._
     *
     * scala> val result1: Option[Int] = Some(3)
     * scala> result1.toValidNec("error!")
     * res0: ValidatedNec[String, Int] = Valid(3)
     *
     * scala> val result2: Option[Int] = None
     * scala> result2.toValidNec("error!")
     * res1: ValidatedNec[String, Int] = Invalid(Chain(error!))
     * }}}
     */
    def (oa: Option[A]) toValidNec[B](b: => B): ValidatedNec[B, A] =
      oa.fold[ValidatedNec[B, A]](Validated.invalidNec(b))(Validated.Valid(_))

    /**
     * If the `Option` is a `Some`, return its value in a [[cats.data.Ior.Right]].
     * If the `Option` is `None`, wrap the provided `B` value in a [[cats.data.Ior.Left]]
     *
     * Example:
     * {{{
     * scala> import cats.data.Ior
     * scala> import cats.implicits._
     *
     * scala> val result1: Option[Int] = Some(3)
     * scala> result1.toRightIor("error!")
     * res0: Ior[String, Int] = Right(3)
     *
     * scala> val result2: Option[Int] = None
     * scala> result2.toRightIor("error!")
     * res1: Ior[String, Int] = Left(error!)
     * }}}
     */
    def (oa: Option[A]) toRightIor[B](b: => B): Ior[B, A] = oa.fold[Ior[B, A]](Ior.Left(b))(Ior.Right(_))

    /**
     * If the `Option` is a `Some`, return its value in a [[cats.data.Ior.Left]].
     * If the `Option` is `None`, wrap the provided `B` value in a [[cats.data.Ior.Right]]
     *
     * Example:
     * {{{
     * scala> import cats.data.Ior
     * scala> import cats.implicits._
     *
     * scala> val result1: Option[String] = Some("error!")
     * scala> result1.toLeftIor(3)
     * res0: Ior[String, Int] = Left(error!)
     *
     * scala> val result2: Option[String] = None
     * scala> result2.toLeftIor(3)
     * res1: Ior[String, Int] = Right(3)
     * }}}
     */
    def (oa: Option[A]) toLeftIor[B](b: => B): Ior[A, B] = oa.fold[Ior[A, B]](Ior.Right(b))(Ior.Left(_))

    /**
     * If the `Option` is a `Some`, return its value. If the `Option` is `None`,
     * return the `empty` value for `Monoid[A]`.
     *
     * Example:
     * {{{
     * scala> import cats.implicits._
     *
     * scala> val someString: Option[String] = Some("hello")
     * scala> someString.orEmpty
     * res0: String = hello
     *
     * scala> val noneString: Option[String] = None
     * scala> noneString.orEmpty
     * res1: String = ""
     * }}}
     */
    def (oa: Option[A]) orEmpty given (A: Monoid[A]): A = oa.getOrElse(A.empty)

    final private[syntax] class LiftToPartiallyApplied[F[_], A](oa: Option[A]) {
      def apply[E](ifEmpty: => E) given (F: ApplicativeError[F, _ >: E]): F[A] =
        ApplicativeError.liftFromOption(oa, ifEmpty)
    }

    /**
     * Lift to a F[A] as long as it has an ApplicativeError[F] instance
     *
     * Example:
     * {{{
     * scala> import cats.implicits._
     * scala> Some(1).liftTo[Either[CharSequence, *]]("Empty")
     * res0: scala.Either[CharSequence, Int] = Right(1)
     *
     * scala> Option.empty[Int].liftTo[Either[CharSequence, *]]("Empty")
     * res1: scala.Either[CharSequence, Int] = Left(Empty)
     * }}}
     */
    def (oa: Option[A]) liftTo[F[_]]: LiftToPartiallyApplied[F, A] = new LiftToPartiallyApplied(oa)

    /**
     * Transform the `Option` into a [[cats.data.OptionT]] while lifting it into the specified Applicative.
     *
     * {{{
     * scala> import cats.implicits._
     * scala> val op: Option[Int] = Some(3)
     * scala> op.toOptionT[List]
     * res0: cats.data.OptionT[List, Int] = OptionT(List(Some(3)))
     * }}}
     */
    def (oa: Option[A]) toOptionT[F[_]: Applicative]: OptionT[F, A] = OptionT.fromOption(oa)
  }
}package ru.d10xa.jadd.inserts

import coursier.core.Version
import ru.d10xa.jadd.Artifact
import ru.d10xa.jadd.GroupId
import ru.d10xa.jadd.ScalaVersion
import ru.d10xa.jadd.testkit.TestBase

class SbtFileInsertsTest extends TestBase {

  def add(content: String, artifacts: Artifact*): String =
    new SbtFileInserts().appendAll(content, artifacts)

  test("sbt insert dependency successfully") {
    val content =
      """import Dependencies._
        |libraryDependencies += scalaTest % Test
        |""".stripMargin

    val result = add(
      content,
      Artifact(
        groupId = GroupId("ch.qos.logback"),
        artifactId = "logback-classic",
        maybeVersion = Some(Version("1.2.3")))
    )

    result.trim shouldEqual
      """import Dependencies._
        |libraryDependencies += scalaTest % Test
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin.trim
  }

  test("add dependency to sbt and resolve scala version") {
    val content =
      """import Dependencies._
        |libraryDependencies += scalaTest % Test""".stripMargin

    val result = add(
      content,
      Artifact(
        groupId = GroupId("org.typelevel"),
        artifactId = "cats-core%%",
        shortcut = Some("cats-core"),
        maybeVersion = Some(Version("1.1.0")),
        maybeScalaVersion = Some(ScalaVersion.fromString("2.12"))
      )
    )

    result shouldEqual
      """import Dependencies._
        |libraryDependencies += scalaTest % Test
        |libraryDependencies += "org.typelevel" %% "cats-core" % "1.1.0"
        |""".stripMargin
  }

  test("update dependency version with implicit scala version") {
    val content =
      """import Dependencies._
        |libraryDependencies += scalaTest % Test
        |libraryDependencies += "org.typelevel" %% "cats-core" % "1.0.1"
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin

    val result = add(
      content,
      Artifact(
        groupId = GroupId("org.typelevel"),
        artifactId = "cats-core%%",
        maybeVersion = Some(Version("1.1.0")),
        maybeScalaVersion = Some(ScalaVersion.fromString("2.12"))
      )
    )

    result shouldEqual
      """import Dependencies._
        |libraryDependencies += scalaTest % Test
        |libraryDependencies += "org.typelevel" %% "cats-core" % "1.1.0"
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin
  }

  test("update explicit scala version to explicit") {
    val content =
      """
        |libraryDependencies += "org.typelevel" % "cats-core_2.11" % "1.0.1"
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin

    val artifact = Artifact(
      groupId = GroupId("org.typelevel"),
      artifactId = "cats-core%%",
      maybeVersion = Some(Version("1.1.0")),
      maybeScalaVersion = Some(ScalaVersion.fromString("2.11"))
    )

    val result = add(content, artifact.copy(explicitScalaVersion = true))
    result shouldEqual
      """
        |libraryDependencies += "org.typelevel" % "cats-core_2.11" % "1.1.0"
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin

  }

  // TODO this is not desired behavior
  test("update explicit scala version to implicit") {
    val content =
      """
        |libraryDependencies += "org.typelevel" % "cats-core_2.11" % "1.0.1"
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin

    val artifact = Artifact(
      groupId = GroupId("org.typelevel"),
      artifactId = "cats-core%%",
      maybeVersion = Some(Version("1.1.0")),
      maybeScalaVersion = Some(ScalaVersion.fromString("2.11"))
    )

    val result = add(content, artifact.copy(explicitScalaVersion = false))

    result shouldEqual
      """
        |libraryDependencies += "org.typelevel" %% "cats-core" % "1.1.0"
        |libraryDependencies += "ch.qos.logback" % "logback-classic" % "1.2.3"
        |""".stripMargin
  }

  test("update implicit scala version") {
    val content =
      """
        |libraryDependencies += "org.typelevel" %% "cats-core" % "1.1.0"
        |""".stripMargin

    val artifact =
      art("org.typelevel:cats-core_2.12:1.6.0")

    val result = add(content, artifact.copy(explicitScalaVersion = false))

    result shouldEqual
      """
        |libraryDependencies += "org.typelevel" %% "cats-core" % "1.6.0"
        |""".stripMargin
  }

  test("sbt libraryDependencies add sequence") {
    // TODO add comment before sequence //libraryDependencies += "com.typesafe.scala-logging" % "scala-logging_2.12" % "3.8.0"
    val content =
      s"""
         |libraryDependencies ++= Seq(
         |  "ch.qos.logback" % "logback-classic" % "1.2.3",
         |  "com.typesafe.scala-logging" %% "scala-logging" % "3.8.0",
         |  "io.circe" %% "circe-parser" % "0.9.3"
         |)
         |
         |//libraryDependencies += "com.typesafe.scala-logging" % "scala-logging_2.12" % "3.8.0"
         |""".stripMargin

    val artifact = Artifact(
      groupId = GroupId("com.typesafe.scala-logging"),
      artifactId = "scala-logging%%",
      maybeVersion = Some(Version("3.9.0")),
      maybeScalaVersion = Some(ScalaVersion.fromString("2.12")),
      inSequence = true
    )

    val result = add(content, artifact)

    result shouldEqual
      s"""
         |libraryDependencies ++= Seq(
         |  "ch.qos.logback" % "logback-classic" % "1.2.3",
         |  "com.typesafe.scala-logging" %% "scala-logging" % "3.9.0",
         |  "io.circe" %% "circe-parser" % "0.9.3"
         |)
         |
         |//libraryDependencies += "com.typesafe.scala-logging" % "scala-logging_2.12" % "3.8.0"
         |""".stripMargin

  }

  test("update seq and standalone") {
    val content =
      s"""
           |libraryDependencies += "com.typesafe.scala-logging" %% "scala-logging" % "3.8.0"
           |libraryDependencies ++= Seq(
           |  "ch.qos.logback" % "logback-classic" % "1.2.2"
           |)
           |""".stripMargin

    val a1 = Artifact(
      groupId = GroupId("com.typesafe.scala-logging"),
      artifactId = "scala-logging%%",
      maybeVersion = Some(Version("3.9.0")),
      maybeScalaVersion = Some(ScalaVersion.fromString("2.12"))
    )

    val a2 = Artifact(
      groupId = GroupId("ch.qos.logback"),
      artifactId = "logback-classic",
      maybeVersion = Some(Version("1.2.3")),
      inSequence = true
    )

    add(content, a1, a2) shouldEqual
      s"""
           |libraryDependencies += "com.typesafe.scala-logging" %% "scala-logging" % "3.9.0"
           |libraryDependencies ++= Seq(
           |  "ch.qos.logback" % "logback-classic" % "1.2.3"
           |)
           |""".stripMargin

  }

}
package io.circe.cats.kernel

import io.circe.cats.kernel.instances.TupleCommutativeGroupInstances
import scala.collection.immutable.{BitSet, Queue, SortedMap, SortedSet}
import scala.concurrent.duration.{Duration, FiniteDuration}
import scala.annotation.tailrec

/**
 * A semigroup is any set `A` with an associative operation (`combine`).
 */
trait Semigroup[@specialized(Int, Long, Float, Double) A] extends Any with Serializable {

  /**
   * Associative operation which combines two values.
   *
   * Example:
   * {{{
   * scala> import cats.kernel.instances.string._
   * scala> import cats.kernel.instances.int._
   * scala> import cats.kernel.instances.option._
   *
   * scala> Semigroup[String].combine("Hello ", "World!")
   * res0: String = Hello World!
   *
   * scala> Semigroup[Option[Int]].combine(None, Some(1))
   * res1: Option[Int] = Some(1)
   * }}}
   */
  def combine(x: A, y: A): A

  /**
   * Return `a` combined with itself `n` times.
   *
   * Example:
   * {{{
   * scala> import cats.kernel.instances.int._
   * scala> import cats.kernel.instances.string._
   *
   * scala> Semigroup[Int].combineN(1, 10)
   * res0: Int = 10
   *
   * scala> Semigroup[String].combineN("ha", 3)
   * res1: String = hahaha
   * }}}
   */
  def combineN(a: A, n: Int): A =
    if (n <= 0) throw new IllegalArgumentException("Repeated combining for semigroups must have n > 0")
    else repeatedCombineN(a, n)

  /**
   * Return `a` combined with itself more than once.
   */
  protected[this] def repeatedCombineN(a: A, n: Int): A = {
    @tailrec def loop(b: A, k: Int, extra: A): A =
      if (k == 1) combine(b, extra)
      else {
        val x = if ((k & 1) == 1) combine(b, extra) else extra
        loop(combine(b, b), k >>> 1, x)
      }
    if (n == 1) a else loop(a, n - 1, a)
  }

  /**
   * Given a sequence of `as`, combine them and return the total.
   *
   * If the sequence is empty, returns None. Otherwise, returns Some(total).
   *
   * Example:
   * {{{
   * scala> import cats.kernel.instances.string._
   *
   * scala> Semigroup[String].combineAllOption(List("One ", "Two ", "Three"))
   * res0: Option[String] = Some(One Two Three)
   *
   * scala> Semigroup[String].combineAllOption(List.empty)
   * res1: Option[String] = None
   * }}}
   */
  def combineAllOption(as: TraversableOnce[A]): Option[A] =
    as.reduceOption(combine)
}

private[kernel] trait SemigroupFunctions[S[T] <: Semigroup[T]] {
  def combine[@specialized(Int, Long, Float, Double) A](x: A, y: A) given (A: S[A]): A =
    A.combine(x, y)

  def maybeCombine[@specialized(Int, Long, Float, Double) A](ox: Option[A], y: A) given (A: S[A]): A =
    ox match {
      case Some(x) => A.combine(x, y)
      case None    => y
    }

  def maybeCombine[@specialized(Int, Long, Float, Double) A](x: A, oy: Option[A]) given (A: S[A]): A =
    oy match {
      case Some(y) => A.combine(x, y)
      case None    => x
    }

  def combineN[@specialized(Int, Long, Float, Double) A](a: A, n: Int) given (A: S[A]): A =
    A.combineN(a, n)

  def combineAllOption[A](as: TraversableOnce[A]) given (A: S[A]): Option[A] =
    A.combineAllOption(as)
}

object Semigroup extends TupleCommutativeGroupInstances with SemilatticeInstances with SemigroupFunctions[Semigroup] {

  /**
   * Access a given `Semigroup[A]`.
   */
  def apply[A] given (A: Semigroup[A]): Semigroup[A] = A

  /**
   * Create a `Semigroup` instance from the given function.
   */
  def instance[A](cmb: (A, A) => A): Semigroup[A] = new Semigroup[A] {
    def combine(x: A, y: A): A = cmb(x, y)
  }

  given as (CommutativeGroup[Unit] & BoundedSemilattice[Unit]) = io.circe.cats.kernel.instances.UnitInstance
  given as CommutativeGroup[Byte] = io.circe.cats.kernel.instances.ByteInstance
  given as CommutativeGroup[Int] = io.circe.cats.kernel.instances.IntInstance
  given as CommutativeGroup[Short] = io.circe.cats.kernel.instances.ShortInstance
  given as CommutativeGroup[Long] = io.circe.cats.kernel.instances.LongInstance
  given as CommutativeGroup[BigInt] = io.circe.cats.kernel.instances.BigIntInstance
  given as CommutativeGroup[BigDecimal] = io.circe.cats.kernel.instances.BigDecimalInstance
  given as CommutativeGroup[Duration] = io.circe.cats.kernel.instances.DurationInstance
  given as CommutativeGroup[FiniteDuration] = io.circe.cats.kernel.instances.FiniteDurationInstance
  given as CommutativeGroup[Double] = io.circe.cats.kernel.instances.DoubleInstance
  given as CommutativeGroup[Float] = io.circe.cats.kernel.instances.FloatInstance

  given as Monoid[String] = io.circe.cats.kernel.instances.StringInstance
  given [A] as Monoid[Option[A]] given Semigroup[A] = io.circe.cats.kernel.instances.OptionMonoid[A]
  given [A] as Monoid[List[A]] = io.circe.cats.kernel.instances.ListMonoid[A]
  given [A] as Monoid[Vector[A]] = io.circe.cats.kernel.instances.VectorMonoid[A]
  given [A] as Monoid[Stream[A]] = io.circe.cats.kernel.instances.StreamMonoid[A]
  given [A] as Monoid[Queue[A]] = io.circe.cats.kernel.instances.QueueMonoid[A]

  given [A] as BoundedSemilattice[Set[A]] = io.circe.cats.kernel.instances.SetBoundedSemilattice[A]
  given as BoundedSemilattice[BitSet] = io.circe.cats.kernel.instances.BitSetInstance
  given [A] as BoundedSemilattice[SortedSet[A]] given Order[A] = io.circe.cats.kernel.instances.SortedSetBoundedSemilattice[A]

  given [A] as Group[() => A] given Group[A] = io.circe.cats.kernel.instances.Function0Group[A]
  given [A, B] as Group[A => B] given Group[B] = io.circe.cats.kernel.instances.Function1Group[A, B]

  given [K, V] as CommutativeMonoid[Map[K, V]] given Semigroup[V] = io.circe.cats.kernel.instances.MapCommutativeMonoid[K, V]
  given [K, V] as CommutativeMonoid[SortedMap[K, V]] given Order[K], CommutativeSemigroup[V] = io.circe.cats.kernel.instances.SortedMapCommutativeMonoid[K, V]
}

private trait SemilatticeInstances extends MonoidInstances {
  given [A] as Semilattice[() => A] given Semilattice[A] = io.circe.cats.kernel.instances.Function0Semilattice[A]
  given [A, B] as Semilattice[A => B] given Semilattice[B] = io.circe.cats.kernel.instances.Function1Semilattice[A, B]
}

private trait MonoidInstances extends CommutativeSemigroupInstances  {
  given [A] as Monoid[() => A] given Monoid[A] = io.circe.cats.kernel.instances.Function0Monoid[A]
  given [K, V] as Monoid[SortedMap[K, V]] given Order[K], Semigroup[V] = io.circe.cats.kernel.instances.SortedMapMonoid[K, V]
}

private trait CommutativeSemigroupInstances extends BandInstances {
  given [A] as CommutativeSemigroup[() => A] given CommutativeSemigroup[A] = io.circe.cats.kernel.instances.Function0CommutativeSemigroup[A]
}

private trait BandInstances extends SemigroupInstances {
  given [A] as Band[() => A] given Band[A] = io.circe.cats.kernel.instances.Function0Band[A]
}

private trait SemigroupInstances {
  given [A] as Semigroup[() => A] given Semigroup[A] = io.circe.cats.kernel.instances.Function0Semigroup[A]
  given [A, B] as Semigroup[A => B] given Semigroup[B] = io.circe.cats.kernel.instances.Function1Semigroup[A, B]
}
package io.circe.cats

import io.circe.cats.arrow.Category
import io.circe.cats.data.AndThen
import io.circe.cats.kernel.Semigroup

/**
 * SemigroupK is a universal semigroup which operates on kinds.
 *
 * This type class is useful when its type parameter F[_] has a
 * structure that can be combined for any particular type. Thus,
 * SemigroupK is like a Semigroup for kinds (i.e. parametrized
 * types).
 *
 * A SemigroupK[F] can produce a Semigroup[F[A]] for any type A.
 *
 * Here's how to distinguish Semigroup and SemigroupK:
 *
 *  - Semigroup[A] allows two A values to be combined.
 *
 *  - SemigroupK[F] allows two F[A] values to be combined, for any A.
 *    The combination operation just depends on the structure of F,
 *    but not the structure of A.
 */
trait SemigroupK[F[_]] extends Serializable { self =>

  /**
   * Combine two F[A] values.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> SemigroupK[List].combineK(List(1, 2), List(3, 4))
   * res0: List[Int] = List(1, 2, 3, 4)
   * }}}
   */
  def combineK[A](x: F[A], y: F[A]): F[A]

  /**
   * Given a type A, create a concrete Semigroup[F[A]].
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> val s: Semigroup[List[Int]] = SemigroupK[List].algebra[Int]
   * }}}
   */
  def algebra[A]: Semigroup[F[A]] =
    new Semigroup[F[A]] {
      def combine(x: F[A], y: F[A]): F[A] = self.combineK(x, y)
    }

  /**
   * "Compose" with a `G[_]` type to form a `SemigroupK` for `λ[α => F[G[α]]]`.
   * Note that this universally works for any `G`, because the "inner" structure
   * isn't considered when combining two instances.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> type ListOption[A] = List[Option[A]]
   * scala> val s: SemigroupK[ListOption] = SemigroupK[List].compose[Option]
   * scala> s.combineK(List(Some(1), None, Some(2)), List(Some(3), None))
   * res0: List[Option[Int]] = List(Some(1), None, Some(2), Some(3), None)
   * }}}
   */
  def compose[G[_]]: SemigroupK[[α] =>> F[G[α]]] =
    new ComposedSemigroupK[F, G] {
      val F = self
    }
}

object SemigroupK {
  def apply[F[_]] given (F: SemigroupK[F]): SemigroupK[F] = F

  given as MonoidK[Option] = io.circe.cats.instances.OptionInstance
  given as MonoidK[List] = io.circe.cats.instances.ListInstance
  given as MonoidK[Vector] = io.circe.cats.instances.VectorInstance
  given as MonoidK[Stream] = io.circe.cats.instances.StreamInstance
  given as MonoidK[Set] = io.circe.cats.instances.SetInstance

  given as MonoidK[Endo] {
    val category: Category[Function1] = the[Category[Function1]]

    override def empty[A]: Endo[A] = category.id

    override def combineK[A](x: Endo[A], y: Endo[A]): Endo[A] =
      AndThen(category.compose(x, y))
  }

  given [A] as SemigroupK[[x] =>> Either[A, x]] = io.circe.cats.instances.EitherInstance[A]
}package chapter02

import cats.{Show => CatsShow}
import cats.data._
import cats.implicits._

case class A(name: String)
case class B(name: String)

object Show extends App {

  // Scala standard
  // https://github.com/scala/scala/blob/2.12.x/src/library-aux/scala/Any.scala#L78
  println(3.toString)
  println("hello".toString)
  
  // Cats standard
  // https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Show.scala#L15
  println(3.show)
  println("hello".show)

  implicit val aShow = CatsShow.show[A](_.name)
  implicit val bShow = CatsShow.fromToString[B]

  println(A("a").show)
  println(B("b"))
}
package cats.part4

/*
 * This covers the exercise of section 4.7 of the
 * Scala with cats book.
 * https://underscore.io/books/scala-with-cats/
 */

import cats.Eval
import cats.data.Writer

import scala.concurrent.{Await, Future}
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
import cats.syntax.writer._
import cats.syntax.applicative._
import cats.instances.vector._


object ShowYourWorking extends App {
  def slowly[A](body: => A) =
    try body finally Thread.sleep(100)

  def factorial(n: Int): Int = {
    val ans = slowly(if(n == 0) 1 else n * factorial(n - 1))
    println(s"fact $n $ans")
    ans
  }

  Await.result(Future.sequence(Vector(
    Future(factorial(3)),
    Future(factorial(3))
  )), 5.seconds)

  println(s"factorial 5 = ${factorial(5)}")

  type Logged[A] = Writer[Vector[String], A]

  def factorialWriter(n: Int): Logged[Int] =
    for {
      ans <- if(n == 0) {
        1.pure[Logged]
      } else {
        slowly(factorialWriter(n - 1).map(_ * n))
      }
      _   <- Vector(s"fact $n $ans").tell
    } yield ans
  val (log, res) = factorialWriter(5).run
  println(s"result $log -> $res")

}package io.circe.cats.arrow

/**
 * Must obey the laws defined in cats.laws.StrongLaws.
 */
trait Strong[F[_, _]] extends Profunctor[F] {

  /**
   * Create a new `F` that takes two inputs, but only modifies the first input
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.arrow.Strong
   * scala> val f: Int => Int = _ * 2
   * scala> val fab = Strong[Function1].first[Int,Int,Int](f)
   * scala> fab((2,3))
   * res0: (Int, Int) = (4,3)
   * }}}
   */
  def first[A, B, C](fa: F[A, B]): F[(A, C), (B, C)]

  /**
   * Create a new `F` that takes two inputs, but only modifies the second input
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.arrow.Strong
   * scala> val f: Int => Int = _ * 2
   * scala> val fab = Strong[Function1].second[Int,Int,Int](f)
   * scala> fab((2,3))
   * res0: (Int, Int) = (2,6)
   * }}}
   */
  def second[A, B, C](fa: F[A, B]): F[(C, A), (C, B)]
}

object Strong {
  def apply[F[_, _]] given (F: Strong[F]): Strong[F] = F

  private[cats] trait Ops {
    given [F[_, _], A, B] {
      def (fab: F[A, B]) first[C] given (F: Strong[F]): F[(A, C), (B, C)] = F.first(fab)
      def (fab: F[A, B]) second[C] given (F: Strong[F]): F[(C, A), (C, B)] = F.second(fab)
    }
  }
}package io.circe.cats

import io.circe.cats.data.State
import io.circe.cats.data.StateT
import io.circe.cats.kernel.Order
import scala.collection.immutable.SortedMap

/**
 * Traverse, also known as Traversable.
 *
 * Traversal over a structure with an effect.
 *
 * Traversing with the [[cats.Id]] effect is equivalent to [[cats.Functor]]#map.
 * Traversing with the [[cats.data.Const]] effect where the first type parameter has
 * a [[cats.Monoid]] instance is equivalent to [[cats.Foldable]]#fold.
 *
 * See: [[https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf The Essence of the Iterator Pattern]]
 */
trait Traverse[F[_]] extends Functor[F] with Foldable[F] with UnorderedTraverse[F] { self =>

  /**
   * Given a function which returns a G effect, thread this effect
   * through the running of this function on all the values in F,
   * returning an F[B] in a G context.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> def parseInt(s: String): Option[Int] = Either.catchOnly[NumberFormatException](s.toInt).toOption
   * scala> List("1", "2", "3").traverse(parseInt)
   * res0: Option[List[Int]] = Some(List(1, 2, 3))
   * scala> List("1", "two", "3").traverse(parseInt)
   * res1: Option[List[Int]] = None
   * }}}
   */
  def traverse[G[_], A, B](fa: F[A])(f: A => G[B]) given Applicative[G]: G[F[B]]

  /**
   * A traverse followed by flattening the inner result.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> def parseInt(s: String): Option[Int] = Either.catchOnly[NumberFormatException](s.toInt).toOption
   * scala> val x = Option(List("1", "two", "3"))
   * scala> x.flatTraverse(_.map(parseInt))
   * res0: List[Option[Int]] = List(Some(1), None, Some(3))
   * }}}
   */
  def flatTraverse[G[_], A, B](fa: F[A])(f: A => G[F[B]]) given (G: Applicative[G], F: FlatMap[F]): G[F[B]] =
    G.map(traverse(fa)(f))(F.flatten)

  /**
   * Thread all the G effects through the F structure to invert the
   * structure from F[G[A]] to G[F[A]].
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> val x: List[Option[Int]] = List(Some(1), Some(2))
   * scala> val y: List[Option[Int]] = List(None, Some(2))
   * scala> x.sequence
   * res0: Option[List[Int]] = Some(List(1, 2))
   * scala> y.sequence
   * res1: Option[List[Int]] = None
   * }}}
   */
  def sequence[G[_], A](fga: F[G[A]]) given Applicative[G]: G[F[A]] =
    traverse(fga)(ga => ga)

  /**
   * Thread all the G effects through the F structure and flatten to invert the
   * structure from F[G[F[A]]] to G[F[A]].
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> val x: List[Option[List[Int]]] = List(Some(List(1, 2)), Some(List(3)))
   * scala> val y: List[Option[List[Int]]] = List(None, Some(List(3)))
   * scala> x.flatSequence
   * res0: Option[List[Int]] = Some(List(1, 2, 3))
   * scala> y.flatSequence
   * res1: Option[List[Int]] = None
   * }}}
   */
  def flatSequence[G[_], A](fgfa: F[G[F[A]]]) given (G: Applicative[G], F: FlatMap[F]): G[F[A]] =
    G.map(sequence(fgfa))(F.flatten)

  def compose[G[_]] given Traverse[G]: Traverse[[x] =>> F[G[x]]] =
    new ComposedTraverse[F, G] {
      val F = self
      val G = the[Traverse[G]]
    }

  override def map[A, B](fa: F[A])(f: A => B): F[B] =
    traverse[Id, A, B](fa)(f)

  /**
   * Akin to [[map]], but also provides the value's index in structure
   * F when calling the function.
   */
  def mapWithIndex[A, B](fa: F[A])(f: (A, Int) => B): F[B] =
    traverse(fa)(a => State((s: Int) => (s + 1, f(a, s)))).runA(0).value

  /**
   * Akin to [[traverse]], but also provides the value's index in
   * structure F when calling the function.
   *
   * This performs the traversal in a single pass but requires that
   * effect G is monadic. An applicative traversal can be performed in
   * two passes using [[zipWithIndex]] followed by [[traverse]].
   */
  def traverseWithIndexM[G[_], A, B](fa: F[A])(f: (A, Int) => G[B]) given (G: Monad[G]): G[F[B]] =
    traverse(fa)(a => StateT((s: Int) => G.map(f(a, s))(b => (s + 1, b)))).runA(0)

  /**
   * Traverses through the structure F, pairing the values with
   * assigned indices.
   *
   * The behavior is consistent with the Scala collection library's
   * `zipWithIndex` for collections such as `List`.
   */
  def zipWithIndex[A](fa: F[A]): F[(A, Int)] =
    mapWithIndex(fa)((a, i) => (a, i))

  override def unorderedTraverse[G[_], A, B](sa: F[A])(f: (A) => G[B]) given CommutativeApplicative[G]: G[F[B]] =
    traverse(sa)(f)

  override def unorderedSequence[G[_], A](fga: F[G[A]]) given CommutativeApplicative[G]: G[F[A]] =
    sequence(fga)
}

object Traverse {
  def apply[F[_]] given (F: Traverse[F]): Traverse[F] = F

  given [A] as Traverse[[x] =>> Either[A, x]] = io.circe.cats.instances.EitherInstance[A]
  given [K] as Traverse[[x] =>> SortedMap[K, x]] given Order[K] = io.circe.cats.instances.SortedMapInstance[K]

  private[cats] trait Ops {
    given [F[_], A] {
      def (fa: F[A]) traverse[G[_], B](f: A => G[B]) given (F: Traverse[F], G: Applicative[G]): G[F[B]] = F.traverse(fa)(f)
      def (fa: F[A]) flatTraverse[G[_], B](f: A => G[F[B]]) given Traverse[F], Applicative[G], FlatMap[F]: G[F[B]] =
        the[Traverse[F]].flatTraverse(fa)(f)
      def (fa: F[A]) traverseWithIndexM[G[_], B](f: (A, Int) => G[B]) given (F: Traverse[F], G: Monad[G]): G[F[B]] =
        F.traverseWithIndexM(fa)(f)
      def (fa: F[A]) zipWithIndex given (F: Traverse[F]): F[(A, Int)] = F.zipWithIndex(fa)
    }
  }
}
import PresentationUtil.{slide, _}
import japgolly.scalajs.react.ScalaComponent
import japgolly.scalajs.react.vdom.html_<^._
import org.scalajs.dom

import scala.scalajs.js.JSApp
import scala.scalajs.js.annotation.JSExport

object TypeClassesIncarnationsLecture extends JSApp {
  import Enumeration._

  val overview = chapter(
    chapterSlide(
      <.h1("Type Class Incarnations")
    ),

    slide(
      "What we will learn in this lecture",
      Enumeration(
        Item.stable("Categorical Programming"),
        Item.fadeIn("Typelevel Cats"),
        Item.fadeIn("Cats Kernel"),
        Item.fadeIn("Cats Core"),
        Item.fadeIn("Monad Transformers"),
        Item.fadeIn("Monad Instances")
      )
    ),

    noHeaderSlide(
      <.h2("You have a question?"),
      <.h3("Ask it right away!")
    )
  )

  val categorical = chapter(
    chapterSlide(
      <.h2("Categorical Programming")
    ),

    slide(
      "Categorical Programming",
      <.p("Using mathematical concepts from Category Theory to enhance our FP toolbox."),
      <.p(
        ^.cls := "fragment fade-in",
        "But what does that mean in practice?"
      )
    ),

    noHeaderSlide(
      <.h3("Let's have an example"),
      <.br,
      <.h4("Equality")
    ),

    slide(
      "Categorical FP: equality",
      <.p("Scala comes already with an equality method build into its objects. But that allows us to write the following:"),
      <.br,
      scalaC("""
        // equality between different types
        "hello" == 1

        // wrong inequality
        class Person(name: String)

        // yields `false`
        new Person("Gandalf") == new Person("Gandalf")
      """)
    ),

    slide(
      "Categorical FP: equality",
      <.p("We want an equality proof which is strict in its parameter types and tests value equality."),
      <.br,
      scalaC("""
        def eqv[A](a: A, b: A): Boolean
      """)
    ),

    slide(
      "Categorical FP: equality",
      <.p("We want that to be a polymorphic property."),
      <.br,
      scalaC("""
        trait Eq[A] {

          def eqv(a: A, b: A): Boolean
        }
      """)
    ),

    slide(
      "Categorical FP: equality",
      scalaC("""
        implicit val strEq = new Eq[String] {
          def eqv(a: String, b: String): Boolean = a == b
        }

        // doesn't compile
        implicitly[Eq[String]].eqv("hello", 1)
      """),
    ),

    slide(
      "Categorical FP: equality",
      scalaC("""
        implicit val personEq = new Eq[Person] {
          def eqv(a: Person, b: Person): Boolean = a.name == b.name
        }

        // yields `true`
        implicitly[Eq[Person]].eqv(
          new Person("Gandalf"), 
          new Person("Gandalf")
        )
      """)
    ),

    slide(
      "Categorical FP: equality",
      scalaC("""
        // add properties to type parameter
        def isFixedPoint[A: Eq](a: A)(f: A => A): Boolean = {
          implicitly[Eq[A]].eqv(a, f(a))
        }
      """)
    ),

    noHeaderSlide(
      <.h3("You know what?"),
      <.br,
      <.h5("There is a library with usefull type classes already available")
    )
  )

  val catsLibrary = chapter(
    chapterSlide(
      <.h2("Typelevel Cats")
    ),

    slide(
      "Cats",
      <.img(
        ^.alt   := "Cats Logo",
        ^.src   := "./img/cats-logo.png",
        ^.width := "40%"
      )
    ),

    slide(
      "Cats",
      <.p("Cats, short for ", <.strong("Cat"), "egorie", <.strong("s")),
      <.br,
      <.a(
        ^.href := "https://typelevel.org/cats",
        "https://typelevel.org/cats/"
      )
    ),

    slide(
      "Cats",
      Enumeration(
        Item.stable("a set of useful abstractions"),
        Item.fadeIn("syntax to use type classes more conveniently"),
        Item.fadeIn("additional tooling to scrap boilderplate and scrutinize instances")
      )
    ),

    noHeaderSlide(
      <.h3("Let's have a look into the project")
    )
  )

  val catsKernel = chapter(
    chapterSlide(
      <.h2("Cats Kernel")
    ),

    slide(
      "Cats Kernel",
      <.a(
        ^.href := "https://github.com/typelevel/cats/tree/master/kernel/src/main/scala/cats/kernel",
        "cats/kernel"
      )
    ),

    noHeaderSlide(
      <.h3("Equality")
    ),

    slide(
      "Cats Kernel: Eq",
      <.p("Equality is already build into the library."),
      <.br,
      scalaC("""
        trait Eq[A] {

          def eqv(x: A, y: A): Boolean

          def neqv(x: A, y: A): Boolean = !eqv(x, v)
        }
      """),
      scalaCFragment("""
        object Eq {

          // resolve instance for type `A`
          def apply[A](implicit ev: Eq[A]): Eq[A] = ev
        }
      """)
    ),

    slide(
      "Cats Kernel: Eq",
      scalaC("""
        import cats.kernel.Eq
        import cats.implicits._

        Eq[Int].eqv(1, 2) == Eq.apply[Int].eqv(1, 2)
                          == intEq.eqv(1, 2)
                          == false
      """),
      scalaCFragment("""
        // doesn't compile
        Eq[Int].eqv("hello", 2) 
      """)
    ),

    slide(
      "Cats Kernel: Eq",
      scalaC("""
        // Cats also comes with some convenient syntax
        1 === 2

        // equal to
        Eq[Int].eqv(1, 2)
      """)
    ),

    slide(
      "Cats Kernel: Eq",
      <.p("There are instances for all primitive types and many collections like List, Set, etc."),
      <.br,
      <.p(
        ^.cls := "fragment fade-in",
        "That is true for all Kernel type classes."
      )
    ),

    noHeaderSlide(
      <.h3("After equality follows order")
    ),

    slide(
      "Cats Kernel: Order",
      scalaC("""
        trait Order[A] extends Eq[A] {

          /** Result of comparing `x` with `y`. Returns an Int whose sign is:
            *  - negative iff `x < y`
            *  - zero     iff `x = y`
            *  - positive iff `x > y`
            */
          def compare(x: A, y: A): Int

          ...
        }
      """)
    ),

    slide(
      "Cats Kernel: Order",
      scalaC("""
        import cats.kernel.Order

        Order[Int].compare(1, 2) === -1


        import cats.kernel.Comparison.LessThan

        Order[Int].comparison(1, 2) === LessThan
      """)
    ),

    slide(
      "Cats Kernel: Order",
      scalaC("""
        def largestToStr[A: Order](x: A, b: A): String = 
          Order[A].comparison(x, y) match {
            case GreaterThan => s"x: $x"
            case EqualTo     => s"x and y are equal: $x"
            case LessThan    => s"y: $y"
          }


        largestToStr(2, 1) === "x: 2"
      """)
    ),

    noHeaderSlide(
      <.h3("We compared - now we combine"),
      <.br,
      <.h4("Semigroup")
    ),

    slide(
      "Cats Kernel: Semigroup",
      scalaC("""
        trait Semigroup[A] {

          def combine(x: A, y: A): A

          ...
        }
      """)
    ),

    slide(
      "Cats Kernel: Semigroup",
      scalaC("""
        import cats.kernel.Semigroup

        Semigroup[Int].combine(1, 2) === 3


        // again we have some convenient syntax
        1 |+| 2 === 3
      """)
    ),

    slide(
      "Cats Kernel: Semigroup",
      scalaC("""
        def largeEnough[A: Semigroup: Order](threshold: A)
                                            (x: A, y: A): Boolean =
          Order[A].gt(Semigroup[A].combine(x, y), threshold)


        val le = largeEnough(5)

        le(1, 2) === false
      """)
    ),

    noHeaderSlide(
      <.h3("But wait, there is more"),
      <.br,
      <.h4("Semigroup follows some laws")
    ),

    slide(
      "Cats Kernel: Semigroup laws",
      scalaC("""
        // associativity
        a |+| (b |+| c) == (a |+| b) |+| c
      """)
    ),

    slide(
      "Cats Kernel: laws",
      <.p("Kernel laws are checked with a special test suit in kernel-laws.")
    ),

    exerciseSlide(
      "Let's Code: Kernel",
      bash("""
        sbt> project typeclasses-incarnations-exercises
        sbt> test:testOnly exercise5.Kernel
      """)
    ),

    noHeaderSlide(
      <.h3("We had type classes for simple types"),
      <.br,
      <.h4("Let's continue with higher order types")
    )
  )

  val catsCore = chapter(
    chapterSlide(
      <.h2("Cats Core")
    ),

    slide(
      "Cats Core",
      <.a(
        ^.href := "https://github.com/typelevel/cats/tree/master/core/src/main/scala/cats",
        "cats/core"
      )
    ),

    slide(
      "Cats Core",
      <.p("Imagine the following situation:"),
      <.br,
      scalaC("""
        case class Person(name: String)

        def names(persons: List[Person]): List[String] = 
          persons.map(_.name)
      """)
    ),

    slide(
      "Cats Core",
      <.p("But what if the context is unknown aka you  make this function generic in `F[_]`?")
    ),

    slide(
      "Cats Core",
      <.p("`F[_]` is too generic. No operations are attached."),
      <.br,
      scalaC("""
        def names[F[_]](persons: F[Person]): F[String] = ???
      """)
    ),

    noHeaderSlide(
      <.h3("Functor")
    ),

    slide(
      "Cats Core: Functor",
      scalaC("""
        trait Functor[F[_]] {

          def map[A, B](fa: F[A])(f: A => B): F[B]
 
          ...
        }
      """)
    ),

    slide(
      "Cats Core: Functor",
      scalaC("""
        import cats.Functor
        import cats.implicits._

        Functor[List].map(List(1, 2))(_ + 1) === List(2, 3)
      """)
    ),

    slide(
      "Cats Core: Functor",
      scalaC("""
        // it comes again with some convenient syntax
        // `fmap` is from Cats
        List(1, 2).fmap(_ + 1) === List(2, 3)

        // `map` is build into `List`
        List(1, 2).map(_ + 1)  === List(2, 3)
      """)
    ),

    slide(
      "Cats Core: Functor",
      scalaC("""
        def names[F[_]: Functor](persons: F[Person]): F[String] = 
          Functor[F].map(persons)(_.name)


        names(List(Person("Gandalf"))) === List("Gandalf")
        names(Some(Person("Gandalf"))) === Some("Gandalf")
      """)
    ),

    noHeaderSlide(
      <.h3("We have laws against")
    ),

    slide(
      "Cats Core: Functor laws",
      scalaC("""
        // composition
        f.map(g).map(h) == f.map(g.compose(h))

        // identity
        f.map(identity) == f
      """)
    ),

    slide(
      "Cats Core: Functor composition",
      <.p("We can compose Functors as needed."),
      <.br,
      scalaC("""
        implicit val listOpt = Functor[List].compose[Option]

        List(Some(1))).fmap(_ + 1) === List(Some(2))
      """),
      scalaCFragment("""
        names(List(Some(Person("Gandalf")))) === List(Some("Gandalf"))
      """)
    ),

    slide(
      "Cats Core: Functor instances",
      <.p("There are instances for many Scala collections like Option, Either, List, etc.")
    ),

    noHeaderSlide(
      <.h3("But I have a mapping function with more than one parameter!"),
      <.br,
      <.h3(
        ^.cls := "fragment fade-in",
        "Applicative"
      )
    ),

    slide(
      "Cats Core: Applicative",
      scalaC("""
        val combine: Int => Int => Int = a => b => a + b

        // only allows functions with arity 1
        Some(1).fmap(combine) === Some(b => 1 + b)
      """)
    ),

    slide(
      "Cats Core: Applicative",
      scalaC("""
        trait Applicative[F] extends Functor[F] {

          def pure[A](a: A): F[A]

          def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

          ...
        }
      """)
    ),

    slide(
      "Cats Core: Applicative",
      scalaC("""
        import cats.Applicative

        // lift a value
        Applicative[Option].pure(1) === Some(1)

        // apply a function in context `F[_]`
        Applicative[Option].ap[Int, Int](Some(_ + 1))(Some(1)) === Some(2)
      """)
    ),

    slide(
      "Cats Core: Applicative",
      scalaC("""
        val combine: Int => Int => Int = a => b => a + b

        // only allows functions with arity 1
        Some(1).fmap(combine) === Some(b => 1 + b)

        // apply remaining parameters
        Some(1).fmap(combine).ap(Some(2)) === Some(3)
      """),
      scalaCFragment("""
        // convenient syntax
        Some(1).fmap(combine) <*> Some(2) === Some(3)
      """)
    ),

    slide(
      "Cats Core: Applicative laws",
      scalaC("""
        // homomorphism
        pure(f) <*> pure(x) === pure(f(x))

        // interchange
        ff <*> pure(x) === pure(g => g(x)) <*> ff
      """)
    ),

    slide(
      "Cats Core: Applicative laws",
      scalaC("""
        // composition
        pure(compose) <*> g <*> f <*> x === {
          g <*> f <*> x
        }

        // identity
        pure(identity) <*> x === x
      """)
    ),

    slide(
      "Cats Core: Applicative",
      <.p("It is a Functor, therefore, you can compose it."),
      <.br,
      scalaC("""
        implicit val listOpt = Applicative[List].compose[Option]

        listOpt.ap[Int, Int](List(Some(_ + 1)))(List(Some(1))) === {
          List(Some(2))
        }
      """)
    ),

    noHeaderSlide(
      <.h3("But I need to apply effectful functions to my values"),
      <.br,
      <.h4("Monad")
    ),

    slide(
      "Cats Core: Monad",
      scalaC("""
        def getLine[F[_]](from: String): F[String] = ???

        def parse[F[_]](line: String): F[Person] = ???


        def load[F[_]: Functor](from: String): F[Person] = 
          getLine(from).fmap(a: F[String] => ???)
      """)
    ),

    slide(
      "Cats Core: Monad",
      scalaC("""
        trait Monad[F[_]] extends Applicative[F] {

          def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]

          ...
        }
      """)
    ),

    slide(
      "Cats Core: Monad",
      scalaC("""
        def getLine[F[_]](from: String): F[String] = ???

        def parse[F[_]](line: String): F[Person] = ???


        def load[F[_]: Monad](from: String): F[Person] = 
          getLine(from).flatMap(a => parse(a))
      """)
    ),

    slide(
      "Cats Core: Monad laws",
      scalaC("""
        // left identity
        pure(a).flatMap(f) == pure(f(a))

        // right identity
        fa.flatMap(pure) === fa

        // associativity
        (pure(a).flatMap(f)).flatMap(g) === {
          pure(a).flatMap(a => f(a).flatMap(g))
        }
      """)
    ),

    exerciseSlide(
      "Let's Code: Core",
      bash("""
        sbt> project typeclasses-incarnations-exercises
        sbt> test:testOnly exercise5.CoreSpec
      """)
    ),

    noHeaderSlide(
      <.h3("What is with Monad composition?"),
      <.br,
      <.h4(
        ^.cls := "fragment fade-in",
        "They aren't composable"
      )
    )
  )

  val monadTransformers = chapter(
    chapterSlide(
      <.h2("Monad Transformers")
    ),

    slide(
      "Monad Transformers",
      <.p("By using Monad Transformers we are able to simulate composition.")
    ),

    slide(
      "Monad Transformers",
      scalaC("""
        // doesn't work
        implicit val listOpt = Monad[List].compose[Option]
      """),
      scalaCFragment("""
        // but
        type ListOpt[A] = List[Option[A]]

        implicit val listOpt = new Monad[ListOpt]] {

          def flatMap[B](f: A => ListOpt[B]]): ListOpt[B]] = 
            value.flatMap { 
              case Some(v) => f(v)
              case None    => List(None)
            }
        }
      """)
    ),

    slide(
      "Monad Transformers",
      <.p("But now we have to implement every combination, which sucks.")
    ),

    slide(
      "Monad Transformers",
      scalaC("""
        type OptionT[F[_], A] = F[Option[A]]

        implicit def optionT[F[_]: Monad] = 
          new Monad[OptionT[F, ?]] {

            def flatMap[A, B](fa: OptionT[F, A])
                             (f: A => OptionT[F, B]): OptionT[F, B] = 
              Monad[F].flatMap(fa) { 
                case Some(v) => f(v)
                case None    => Monad[F].pure(None)
              }
          }
      """)
    ),

    slide(
      "Monad Transformers: kind-projector",
      <.h3("Kind-Projector"),
      <.br,
      scalaC("""
        // OptionT expects two type parameter (F[_, _]), Monad expects F[_]
        // using `?` fixes the type constructor shape
        OptionT[F, ?] ~ ({ type O[A] = OptionT[F, A] })#O
      """)
    ),

    slide(
      "Monad Transformers",
      <.p("Cats provides some data types which can be used as Monad Transformers."),
      <.br,
      <.a(
        ^.href := "https://github.com/typelevel/cats/tree/master/core/src/main/scala/cats/data",
        "cats/core/data"
      )
    ),

    slide(
      "Monad Tranformers",
      scalaC("""
        // our code becomes
        case class OptionT[F, A](value: F[Option[A]]) {

          def flatMap[B](f: A => F[Option[B]])
                        (implicit M: Monad[F]): F[Option[B]] = 
            M.flatMap(value) { 
              case Some(v) => f(v)
              case None    => M.pure(None)
            }

          ...
        }
      """)
    ),

    exerciseSlide(
      "Let's Code: MonadTransformers",
      bash("""
        sbt> project typeclasses-incarnations-exercises
        sbt> test:testOnly exercise5.MonadTransformersSpec
      """)
    ),

    noHeaderSlide(
      <.h3("Last step, some useful Monads")
    )
  )

  val monadIncarnations = chapter(
    chapterSlide(
      <.h2("Monad Incarnations")
    ),

    noHeaderSlide(
      <.h3("Reader Monad")
    ),

    slide(
      "Monads: Reader",
      <.p("Imagine you have some context you have to carry around."),
      <.br,
      scalaC("""
        case class GameConfig(maxMoves: Int)

        def move(dir: Direction, 
                 current: Pos,
                 moveCount: Int,
                 conf: GameConfig): Either[String, Pos] = 
          if (moveCount < conf.maxMoves)
            dir match { ??? }
          else
            Left("No moves left over")
      """)
    ),

    slide(
      "Monads: Reader",
      <.p("But now every function calling `move` has to provide the static `GameConfig`."),
      <.br,
      scalaC("""
        def moveUp(..., conf: GameConfig): Either[String, Pos] = 
          move(Up, current, moveCount, conf)

        ...

        def parse(dirRaw: String, ..., conf: GameConfig): Either[String, Pos] =
          dirRaw.toLowerCase match {
            case "up" => moveUp(current, moveCount, conf)
            ...
          }
      """)
    ),

    slide(
      "Monads: Reader",
      <.p("What if we could store such information in the background?")
    ),

    slide(
      "Monads: Reader",
      scalaC("""
        case class Reader[E, A](run: E => A)

        implicit def readerM[E] = new Monad[Reader[E, ?]] {

          def flatMap[A, B](fa: Reader[E, A])
                           (f: A => Reader[E, B]): Reader[E, B] = {
            Reader { env =>
              val reader = f(fa.run(env))

              reader.run
            }
        }
      """)
    ),

    slide(
      "Monads: Reader",
      scalaC("""
        object Reader {

          // get the context
          def ask[E]: Reader[E, E] = Reader(identity)

          // update context
          def local[E, A](f: E => E)(fa: Reader[E, A]): Reader[E, A] =
            Reader { env =>
              fa.run(f(env))
            }
        }
      """)
    ),

    slide(
      "Monads: Reader",
      scalaC("""
        type ConfR[A] = Reader[GameConfig, A]

        def move(dir: Direction, 
                 current: Pos,
                 moveCount: Int): ConfR[Either[String, Pos]] = 
          Reader.ask[GameConfig].map { conf =>
            if (moveCount < conf.maxMoves)
              dir match { ??? }
            else
              Left("No moves left over")
          }
      """)
    ),

    slide(
      "Monads: Reader",
      scalaC("""
        def moveUp(current: Pos, moveCount: Int): ConfR[Either[String, Pos]] = 
          move(Up, current, moveCount)

        ...

        parse("up", Pos(0, 0), 0).run(GameConfig(5)) === Right(Pos(1, 0))
      """)
    ),

    noHeaderSlide(
      <.h3("What about writing information?")
    ),

    slide(
      "Monads: Writer",
      scalaC("""
        // let's modify the old `moveUp` to log moves
        def moveUp(current: Pos,
                   moveCount: Int,
                   conf: GameConfig,
                   moves: List[String]): Either[String, (List[String], Pos)] =
          moves(Up, current, moveCount, conf)
            .map(pos => ("up" :: moves, pos))
      """)
    ),

    slide(
      "Monads: Writer",
      <.p("But now we carry a list around to store log entries.")
    ),

    slide(
      "Monads: Writer",
      scalaC("""
        case class Writer[E, A](run: (E, A))

        implicit def writerM[E: Semigroup] = new Monad[Writer[E, ?]] {

          def flatMap[B](fa: Writer[E, A])
                        (f: A => Writer[E, B]): Writer[E, B] = {
            val writer = f(fa.run._2)

            (writer.run._1 |+| fa.run._1, writer.run._2)
          }
        }
      """)
    ),

    slide(
      "Monads: Writer",
      scalaC("""
        object Writer {

          // store some information
          def tell[E: Semigroup, A](e: E): Writer[E, A] = 
            Writer { case (before, value) =>
              (e |+| before, value)
            }
        }
      """)
    ),

    slide(
      "Monads: Writer",
      scalaC("""
        type GameW[A] = Writer[List[String], A]

        def moveUp(current: Pos,
                   moveCount: Int,
                   conf: GameConfig): GameW[Either[String, Pos]] =
          for {
            pos <- pure(moves(Up, current, moveCount, conf))
            _   <- Writer.tell(List("up"))
          } yield pos
      """)
    ),

    slide(
      "Monads: Writer",
      scalaC("""
        val (logs, value) = parse("up", Pos(0, 0), 0, GameConfig(5)).run

        logs  === List("up")
        value === Pos(1, 0)
      """)
    ),

    noHeaderSlide(
      <.h3("Can I ask and tell?")
    ),

    slide(
      "Monads: State",
      scalaC("""
        case class State[S, A](run: S => (S, A))

        implicit def stateM[S: Semigroup] = new Monad[State[S, ?]] {

          def flatMap[B](fa: State[S, A])
                        (f: A => State[S, B]): State[S, B] =
            State { state =>
              val (state0, value0) = fa(state)
              val (state1, value1) = f(value0)

              (state1 |+| state0, value1)
            }
        }
      """)
    ),

    slide(
      "Monads: State",
      scalaC("""
        case class GameState(current: Pos, 
                             moveCount: Int)

        type GameS[A] = State[GameState, A]
      """)
    ),

    slide(
      "Monads: State",
      scalaC("""
        def move(dir: Direction, conf: GameConfig): GameS[Either[String, Unit]] = 
          for {
            state  <- State.ask[GameState]
            result <- {
              if (state.moveCount < conf.maxMoves)
                dir match {
                  case Up => State.tell(GameState(Pos(1, 0), 1))
                  ...
                }
              else
                pure(Left("No moves left over"))
            }
          } yield result
      """)
    ),

    slide(
      "Monads: State",
      scalaC("""
        val (state, _) = parse("up", GameConf(5)).run(GameState(Pos(0, 0), 0))

        state === GameState(Pos(1, 0), 1)
      """)
    ),

    noHeaderSlide(
      <.h3("You can do that and more in Cats"),
      <.br,
      <.a(
        ^.href := "https://github.com/typelevel/cats/tree/master/core/src/main/scala/cats/data",
        "cats/core/data"
      )
    )
  )

  val summary = chapter(
    chapterSlide(
      <.h2("Summary")
    ),

    slide(
      "Kernel, Core and Data",
      <.p("We saw useful type classes from Cats kernel, core and data package like:"),
      <.br,
      Enumeration(
        Item.stable("Eq, Order, Semigroup"),
        Item.fadeIn("Functor, Applicative, Monad"),
        Item.fadeIn("Monad Transformers"),
        Item.fadeIn("useful Monad incarnations")
      )
    ),

    noHeaderSlide(
      <.h2("Next Topic"),
      <.br,
      <.h3("Side Effects and IO")
    )
  )

  val Show = ScalaComponent
    .builder[Unit]("Slideshow")
    .renderStatic(
      <.div(
        ^.cls := "reveal",
        <.div(
          ^.cls := "slides",
          overview,
          categorical,
          catsLibrary,
          catsKernel,
          catsCore,
          monadTransformers,
          monadIncarnations,
          summary
        )
      )
    )
    .build

  @JSExport
  override def main(): Unit = {
    Show().renderIntoDOM(dom.document.body)
  }
}
package Chapter4_Monads

import cats.syntax.writer._ // for writer
import cats.instances.vector._ // for Monoid
import cats.syntax.applicative._ // for pure
import cats.data.Writer
import cats.instances.vector._ // for Monoid s

object WriterMonad {
  type Logged[A] = Writer[Vector[String], A]

  val writer1 = for {
    a <- 10.pure[Logged]
    _ <- Vector("a", "b", "c").tell
    b <- 32.writer(Vector("x", "y", "z"))
  } yield a + b
  // writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))
  val poep = writer1.run
  // res4: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z),42)

  val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
  // writer2: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))
  val poep2 = writer2.run
  // res5: cats.Id[(scala.collection.

  val writer3 = writer1.bimap(
    log => log.map(_.toUpperCase),
    res => res * 100
  )
  // writer3: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),4200))
  val poep3 = writer3.run
  // res6: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(A, B, C, X, Y, Z),4200)
  val writer4 = writer1.mapBoth { (log, res) =>
    val log2 = log.map(_ + "!")
    val res2 = res * 1000
    (log2, res2)
  }
  // writer4: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(a!, b!, c!, x!, y!, z!),42000))
  val poep4 = writer4.run
  // res7: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(a!, b!, c!, x!, y!, z!),42000)
}package cats
package syntax

import cats.data.Validated.{Invalid, Valid}
import cats.data.{EitherT, Validated}

trait ApplicativeErrorSyntax {
  implicit final def catsSyntaxApplicativeErrorId[E](e: E): ApplicativeErrorIdOps[E] =
    new ApplicativeErrorIdOps(e)

  implicit final def catsSyntaxApplicativeError[F[_], E, A](fa: F[A])(implicit F: ApplicativeError[F, E]): ApplicativeErrorOps[F, E, A] =
    new ApplicativeErrorOps[F, E, A](fa)
}

/**
  * Extension to ApplicativeError in a binary compat way
  */
trait ApplicativeErrorExtension {
  implicit final def catsSyntaxApplicativeErrorExtension[F[_], E](F: ApplicativeError[F, E]):
    ApplicativeErrorExtensionOps[F, E] =
      new ApplicativeErrorExtensionOps(F)
}

final class ApplicativeErrorExtensionOps[F[_], E](F: ApplicativeError[F, E]) {


  /**
    * Convert from scala.Option
    *
    * Example:
    * {{{
    * scala> import cats.implicits._
    * scala> import cats.ApplicativeError
    * scala> val F = ApplicativeError[Either[String, ?], String]
    *
    * scala> F.fromOption(Some(1), "Empty")
    * res0: scala.Either[String, Int] = Right(1)
    *
    * scala> F.fromOption(Option.empty[Int], "Empty")
    * res1: scala.Either[String, Int] = Left(Empty)
    * }}}
    */
  def fromOption[A](oa: Option[A], ifEmpty: => E): F[A] =
    ApplicativeError.liftFromOption(oa, ifEmpty)(F)

  /**
   * Convert from cats.data.Validated
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> import cats.ApplicativeError
   *
   * scala> ApplicativeError[Option, Unit].fromValidated(1.valid[Unit])
   * res0: scala.Option[Int] = Some(1)
   *
   * scala> ApplicativeError[Option, Unit].fromValidated(().invalid[Int])
   * res1: scala.Option[Int] = None
   * }}}
   */
  def fromValidated[A](x: Validated[E, A]): F[A] =
    x match {
      case Invalid(e) => F.raiseError(e)
      case Valid(a) => F.pure(a)
    }

}

final class ApplicativeErrorIdOps[E](val e: E) extends AnyVal {
  def raiseError[F[_], A](implicit F: ApplicativeError[F, E]): F[A] =
    F.raiseError(e)
}

final class ApplicativeErrorOps[F[_], E, A](val fa: F[A]) extends AnyVal {
  def handleError(f: E => A)(implicit F: ApplicativeError[F, E]): F[A] =
    F.handleError(fa)(f)

  def handleErrorWith(f: E => F[A])(implicit F: ApplicativeError[F, E]): F[A] =
    F.handleErrorWith(fa)(f)

  def attempt(implicit F: ApplicativeError[F, E]): F[Either[E, A]] =
    F.attempt(fa)

  def attemptT(implicit F: ApplicativeError[F, E]): EitherT[F, E, A] =
    F.attemptT(fa)

  def recover(pf: PartialFunction[E, A])(implicit F: ApplicativeError[F, E]): F[A] =
    F.recover(fa)(pf)

  def recoverWith(pf: PartialFunction[E, F[A]])(implicit F: ApplicativeError[F, E]): F[A] =
    F.recoverWith(fa)(pf)

  def onError(pf: PartialFunction[E, F[Unit]])(implicit F: ApplicativeError[F, E]): F[A] =
    F.onError(fa)(pf)

  def orElse(other: => F[A])(implicit F: ApplicativeError[F, E]): F[A] =
    F.handleErrorWith(fa)(_ => other)
}
import cats.implicits._
import cats.Semigroupal
import cats.Monoid
import scala.concurrent._
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
import cats.Monad
import cats.data.Validated
import cats.Functor


object chapter6 {
  def parseInt(str: String): Either[String, Int] =
    Either.catchOnly[NumberFormatException](str.toInt).
      leftMap(ex => s"Couldn't read ${str}")
  // for {
  //   a <- parseInt("a")
  //   b <- parseInt("b")
  //   c <- parseInt("c")
  // } yield (a + b + c)
  // scala> res25: scala.util.Either[String,Int] = Left(Couldn't read a)
  object chapter6_1 {
    // trait Semigroupal[F[_]] {
    //   def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = ???
    // }
    // Semigroupal[Option].product(Some(123), Some("abc"))

    // scala> Semigroupal[Option].product(Some(123), Some("abc"))
    // res27: Option[(Int, String)] = Some((123,abc))

    // scala> Semigroupal[Option].product(None, Some("abc"))
    // res28: Option[(Nothing, String)] = None

    // scala> Semigroupal[Option].product(Some(123), None)
    // res29: Option[(Int, Nothing)] = None


    // scala> Semigroupal.tuple3(Option(1), Option(2), Option(3))
    // res30: Option[(Int, Int, Int)] = Some((1,2,3))

    // scala> Semigroupal.tuple3(Option(1), Option(2), Option.empty[Int])
    // res31: Option[(Int, Int, Int)] = None

    // scala> Semigroupal.map3(Option(1), Option(2), Option(3))(_ + _ + _)
    // res32: Option[Int] = Some(6)

    // scala> Semigroupal.map2(Option(1), Option.empty[Int])(_ + _)
    // res33: Option[Int] = None
  }

  object chapter6_2 {

    // scala> (Option(123), Option("abc")).tupled
    // res34: Option[(Int, String)] = Some((123,abc))

    // scala> (Option(123), Option("abc"),Option(true)).tupled
    // res35: Option[(Int, String, Boolean)] = Some((123,abc,true))

    case class Cat(name: String, born: Int, color: String)
    val g = (Option("Garfield"), Option(1978), Option("Orange & black")).mapN(Cat.apply)
    // res36: Option[chapter6.chapter6_2.Cat] = Some(Cat(Garfield,1978,Orange & black))
    val add: (Int, Int) => Int = (a, b) => a + b
    // (Option(1), Option(2), Option(3)).mapN(add)
    // <console>:101: error: type mismatch;
    // found   : (Int, Int) => Int
    // required: (Int, Int, Int) => ?

    // (Option("cats"), Option(true)).mapN(add)
    // <console>:101: error: type mismatch;
    // found   : (Int, Int) => Int
    // required: (String, Boolean) => ?

  }
  object chapter6_2_1 {
    case class Cat(
      name: String,
      yearOfBirth: Int,
      favoriteFoods: List[String]
    )

    val tupleToCat: (String, Int, List[String]) => Cat = Cat.apply _
    val catToTuple: Cat => (String, Int, List[String]) =
      cat => (cat.name, cat.yearOfBirth, cat.favoriteFoods)

    implicit val catMonoid: Monoid[Cat] = (
      Monoid[String],
      Monoid[Int],
      Monoid[List[String]]
    ).imapN(tupleToCat)(catToTuple)

    val garfield = Cat("Garfield", 1978, List("Lasagne"))
    val heathcliff = Cat("Heathcliff", 1988, List("Junk Food"))
    val combined = garfield |+| heathcliff
    // res40: chapter6.chapter6_2_1.Cat = Cat(GarfieldHeathcliff,3966,List(Lasagne, Junk Food))
  }

  object chapter6_3 {
    val futurePair: Future[(String, Int)] =
      Semigroupal[Future].product(Future("Hello"), Future(123))
    case class Cat(
      name: String,
      yearOfBirth: Int,
      favoriteFoods: List[String]
    )

    val futureCat: Future[Cat] = (
      Future("Garfield"),
      Future(1978),
      Future(List("Lasagne"))
    ).mapN(Cat.apply)

    // scala> Semigroupal[List].product(List(1,2), List(3, 4))
    // res46: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
    List(1, 2).zip(List(3, 4))

    type ErrorOr[A] = Either[Vector[String], A]
    Semigroupal[ErrorOr].product(Left(Vector("Error 1")), Left(Vector("Error 2")))
    // res1: ErrorOr[(Nothing, Nothing)] = Left(Vector(Error 1))

    def product[M[_]: Monad, A, B](x: M[A], y: M[B]): M[(A, B)] =
      x.flatMap(a => y.map(b => (a, b)))
  }
}

object chapter6_4 {
  type AllErrorsOr[A] = Validated[List[String], A]
  val error = Semigroupal[AllErrorsOr].product(Validated.invalid(List("Error 1")), Validated.invalid(List("Error 2")))

  // val v = Validated.Valid(123)
  // res3: cats.data.Validated.Valid[Int] = Valid(123)

  // it is often easier to use the `valid` and `invalid` smart constructors,
  // which siden the return type to Validated
  val v = Validated.valid[List[String], Int](123)
  // v: cats.data.Validated[List[String],Int] = Valid(123)

  // val i = Validated.Invalid(List("Badness"))
  // res4: cats.data.Validated.Invalid[List[String]] = Invalid(List(Badness))
  val i = Validated.invalid[List[String], Int](List("Badness"))
  // i: cats.data.Validated[List[String],Int] = Invalid(List(Badness))

  // we can use `valid` and `invalid` extension methods by importing `cats.syntax.validated`
  // scala> 123.valid[List[String]]
  // res5: cats.data.Validated[List[String],Int] = Valid(123)

  // scala> List("Badness").invalid[Int]
  // res6: cats.data.Validated[List[String],Int] = Invalid(List(Badness))

  type ErrorsOr[A] = Validated[List[String], A]
  // use `pure` in `cats.syntax.applicative._`
  // scala> 123.pure[ErrorsOr]
  // res8: chapter6_4.ErrorsOr[Int] = Valid(123)
  // use `raiseError` from `cats.syntax.applicativeError._`
  // scala> List("Badness").raiseError[ErrorsOr, Int]
  // res11: chapter6_4.ErrorsOr[Int] = Invalid(List(Badness))

  Validated.catchOnly[NumberFormatException]("foo".toInt)
  // res12: cats.data.Validated[NumberFormatException,Int] = Invalid(java.lang.NumberFormatException: For input string: "foo")

  Validated.catchNonFatal(sys.error("Badness"))
  // res13: cats.data.Validated[Throwable,Nothing] = Invalid(java.lang.RuntimeException: Badness)

  Validated.fromTry(scala.util.Try("foo".toInt))
  // res14: cats.data.Validated[Throwable,Int] = Invalid(java.lang.NumberFormatException: For input string: "foo")

  Validated.fromEither[String, Int](Left("Badness"))
  // res15: cats.data.Validated[String,Int] = Invalid(Badness)

  Validated.fromOption[String, Int](None, "Badness")
  // res16: cats.data.Validated[String,Int] = Invalid(Badness)
}

object chapter6_4_2 {
  type AllErrorsOr[A] = Validated[String, A]
  // Semigroupal[AllErrorsOr]
  // res17: cats.Semigroupal[chapter6_4_2.AllErrorsOr] = cats.data.ValidatedInstances$$anon$1@8dce4ca

  (
    "Error 1".invalid[Int],
    "Error 2".invalid[Int]
  ).tupled
  // res21: cats.data.Validated[String,(Int, Int)] = Invalid(Error 1Error 2)

  (Vector(404).invalid[Int], Vector(500).invalid[Int]).tupled
  // res22: cats.data.Validated[scala.collection.immutable.Vector[Int],(Int, Int)] = Invalid(Vector(404, 500))


  // scala> 123.valid.map(_ * 100)
  // res23: cats.data.Validated[Nothing,Int] = Valid(12300)

  // scala> "?".invalid.leftMap(_.toString)
  // res24: cats.data.Validated[String,Nothing] = Invalid(?)

  // 123.valid[String].bimap(_ + "!", _ * 100)
  // res25: cats.data.Validated[String,Int] = Valid(12300)

  // scala> "?".invalid[Int].bimap(_ + "!", _ * 100)
  // res26: cats.data.Validated[String,Int] = Invalid(?!)

  // Validated isn't a Monad, we can't flatMap
  // scala> "Badness".invalid[Int].flatMap(a => a)
  // <console>:90: error: value flatMap is not a member of cats.data.Validated[String,Int]
  //        "Badness".invalid[Int].flatMap(a => a)

  // We can convert back and forth between Validated and Either using `toEither` and `toValidated` methods
  // scala> "Badness".invalid[Int].toEither
  // res31: Either[String,Int] = Left(Badness)
  // scala> "Badness".invalid[Int].toEither.toValidated
  // res34: cats.data.Validated[String,Int] = Invalid(Badness)

  // We can use `withEither` method to temporarily convert to an Either and convert back again immediately
  // scala> 41.valid[String].withEither(_.flatMap(n => Right(n + 1)))
  // res35: cats.data.Validated[String,Int] = Valid(42)

  // scala> "fail".invalid[Int].getOrElse(0)
  // res38: Int = 0

  // scala> "fail".invalid[Int].fold(_ + "!!!", _.toString)
  // res39: String = fail!!!
}

object chapter6_4_4 {
  type Name = String
  type Age = Int
  case class User(name: Name, age: Age)
  type ErrorsOrUser = Validated[List[String], User]
  type Input = Map[String, String]

  def getValue(input: Input, key: String): Either[List[String], String] = {
    input.get(key).toRight(List(s"${key} field not specified"))
  }

  def nonBlank(name: String)(str: String): Either[List[String], String] = {
    Right(str).ensure(List(s"${name} must not blank"))(_.nonEmpty)
  }

  def readName(input: Input): Either[List[String], Name] = {
    getValue(input, "name").flatMap(nonBlank("name")(_))
  }

  def parseInt(name: String)(input: String): Either[List[String], Int] = {
    Either.catchOnly[NumberFormatException](input.toInt).
      leftMap(_ => List(s"${name} must be integer"))
  }

  def nonNegative(name: String)(int: Int): Either[List[String], Int] = {
    Right(int).ensure(List(s"${name} must not negative"))(_ >= 0)
  }

  def readAge(input: Input): Either[List[String], Age] = {
    getValue(input, "age").flatMap(ageStr => {
      parseInt("age")(ageStr).flatMap(nonNegative("age"))
    })
  }

  def readUser(input: Input): Validated[List[String], User] = {
    (
      readName(input).toValidated,
      readAge(input).toValidated
    ).mapN(User.apply)
  }
}

object chapter6_5 {
  trait Apply[F[_]] extends Semigroupal[F] with Functor[F] {
    // applies `fa` to `ff` within a context F[_]
    def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

    def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = {
      val ff: F[B => (A, B)] = map(fa)(a => (b: B) => (a, b))
      ap(ff)(fb)
    }
  }

  trait Applicative[F[_]] extends Apply[F] {
    def pure[A](a: A): F[A]
  }
}

object chapter6_5_1 {
  // The Hierarchy of Type Class
  // https://github.com/tpolecat/cats-infographic
}
import sbt._
import Keys._

object versions {

  val scala = "2.11.12"

  val scalaCheck = "1.13.5"
  val discipline = "0.9.0"

  val scalaMacrosParadise = "2.1.0"
  val kindProjector = "0.9.9"
  val simulacrum = "0.13.0"
  val machinist = "0.6.5" // #todo add examples

  val tagsoup = "1.2"

  val shapeless = "2.3.3"

  val scalaz = "7.2.27"

  val cats = "1.6.0"
  val catsEffect = "1.2.0"
  val catsMtl = "0.4.0"
  val catsMouse = "0.17"

  val fs2 = "1.0.3"
  val fs2cats = "0.5.0"
  val fs2scalaz = "0.3.0"

  val frameless = "0.6.1"

  val monocle = "1.5.0"

  val doobie = "0.5.0-M6"

  val monix = "3.0.0-RC1" // newer than "3.0.0-8084549"

  val spark = "2.3.1"

  /**
    * from @etorreborre: "The problem comes from the fact that I think you are checking laws with scalaz-scalacheck-bindings
    * which depends on scalacheck 1.12.5 only.
    * One alternative would be to use cats only and the typelevel discipline project to check laws."
    */
  val specs2 = "4.3.3"
}

object depends {

  lazy val specs2Version = settingKey[String]("defines the current specs2 version")
  // lazy val scalazVersion = settingKey[String]("defines the current scalaz version")

  //lazy val classycle = Seq("org.specs2" % "classycle" % "1.4.3")

  //def compiler(scalaVersion: String) = Seq("org.scala-lang" % "scala-compiler" % scalaVersion)

  def reflect(scalaVersion: String) = Seq("org.scala-lang" % "scala-reflect" % scalaVersion)

  //  def scalaParser(scalaVersion: String) =
//    PartialFunction.condOpt(CrossVersion.partialVersion(scalaVersion)){
//      case Some((2, scalaMajor)) if scalaMajor >= 11 =>
//        "org.scala-lang.modules" %% "scala-parser-combinators" % "1.0.4"
//    }.toList

//  def scalaXML(scalaVersion: String) =
//    PartialFunction.condOpt(CrossVersion.partialVersion(scalaVersion)){
//      case Some((2, scalaMajor)) if scalaMajor >= 11 =>
//        "org.scala-lang.modules" %% "scala-xml" % "1.0.5"
//    }.toList

  def kindp(scalaVersion: String) =
    if (scalaVersion startsWith "2.12.0-M4")
      "org.spire-math" % "kind-projector" % versions.kindProjector
    else
      "org.spire-math" % "kind-projector" % versions.kindProjector cross CrossVersion.binary

  def simulacrum(scalaVersion: String) =
    Seq("com.github.mpilquist" %% "simulacrum" % versions.simulacrum)

  def shapeless(scalaVersion: String) =
    Seq("com.chuusai" %% "shapeless" % versions.shapeless)

  def cats() =
    Seq("org.typelevel" %% "cats-kernel",
        "org.typelevel" %% "cats-macros",
        "org.typelevel" %% "cats-core",
        "org.typelevel" %% "cats-laws",
        "org.typelevel" %% "cats-free",
        "org.typelevel" %% "cats-testkit").map(_ % versions.cats) ++
    Seq("org.typelevel" %% "cats-effect").map(_ % versions.catsEffect)
    Seq("org.typelevel" %% "cats-mtl-core").map(_ % versions.catsMtl)
    Seq("org.typelevel" %% "mouse").map(_ % versions.catsMouse)

  def monocle() : Seq[ModuleID] =
    Seq("com.github.julien-truffaut"  %%  "monocle-core",
        "com.github.julien-truffaut"  %%  "monocle-generic",
        "com.github.julien-truffaut"  %%  "monocle-macro",
        "com.github.julien-truffaut"  %%  "monocle-state",
        "com.github.julien-truffaut"  %%  "monocle-refined").map(_ % versions.monocle) ++
    Seq("com.github.julien-truffaut"  %%  "monocle-law").map(_ % versions.monocle % Test)

 def scalaz(/*scalazVersion: String*/) : Seq[ModuleID] =
    Seq("org.scalaz"    %% "scalaz-core",
        "org.scalaz"    %% "scalaz-effect",
        "org.scalaz"    %% "scalaz-concurrent").map(_ % versions.scalaz) ++
    Seq("org.scalaz"    %% "scalaz-scalacheck-binding").map(_ % (versions.scalaz + "-scalacheck-1.14") % Test)

  def fs2() =
    Seq("co.fs2" %% "fs2-core" % versions.fs2,
        "co.fs2" %% "fs2-io" % versions.fs2,
        "co.fs2" %% "fs2-cats" % versions.fs2cats,
        "co.fs2" %% "fs2-scalaz" % versions.fs2scalaz)

  def spark() =
    Seq(
      "org.apache.spark" %% "spark-core",
      "org.apache.spark" %% "spark-sql",
      "org.apache.spark" %% "spark-streaming",
      "org.apache.spark" %% "spark-hive"
    ).map(_ % versions.spark)

  def frameless() =
    Seq("org.typelevel" %% "frameless-core",
        "org.typelevel" %% "frameless-dataset",
        "org.typelevel" %% "frameless-cats").map(_ % versions.frameless)

    def monix() = Seq(
      "io.monix" %% "monix-eval" % versions.monix,
      "io.monix" %% "monix-execution" % versions.monix,
      "io.monix" %% "monix-reactive" % versions.monix
    )

//  lazy val pegdown = Seq("org.pegdown" % "pegdown" % "1.2.1")

//  lazy val testInterface = Seq("org.scala-sbt"  % "test-interface" % "1.0")

  lazy val tagsoup = "org.ccil.cowan.tagsoup" % "tagsoup" % versions.tagsoup

  def paradise(scalaVersion: String) =
    /*if (scalaVersion.startsWith("2.11") || scalaVersion.startsWith("2.12"))
       Nil
    else  */
    Seq(compilerPlugin("org.scalamacros" %% "paradise"    % versions.scalaMacrosParadise cross CrossVersion.full)/*,
                       "org.scalamacros" %% "quasiquotes" % versions.scalaMacrosParadise*/)

  def scalacheck(scalaVersion: String) =
    Seq("org.scalacheck" %% "scalacheck"    % versions.scalaCheck)

  def discipline(scalaVersion: String) =
    Seq(  "org.typelevel" %% "discipline" % versions.discipline)

  //lazy val mockito       = Seq("org.mockito"    %  "mockito-core"  % "1.9.5")
  //lazy val junit         = Seq("junit"          %  "junit"         % "4.12")
  //lazy val hamcrest      = Seq("org.hamcrest"   %  "hamcrest-core" % "1.3")

  def specs2(specs2Version: String) =
    Seq("org.specs2"        %% "specs2-core",
        "org.specs2"        %% "specs2-form",
        "org.specs2"        %% "specs2-html",
        "org.specs2"        %% "specs2-markdown",
        "org.specs2"        %% "specs2-scalacheck").map(_ % specs2Version)

  lazy val resolvers =
    Seq(updateOptions := updateOptions.value.withCachedResolution(true)) ++ {
      sbt.Keys.resolvers ++=
      Seq(
        Resolver.sonatypeRepo("releases"),
        Resolver.sonatypeRepo("snapshots"),
        Resolver.typesafeIvyRepo("releases"),
        "scalaz-bintray" at "https://dl.bintray.com/scalaz/releases")
    }
}
package cats
package syntax

trait FoldableSyntax extends Foldable.ToFoldableOps with UnorderedFoldable.ToUnorderedFoldableOps {

  implicit final def catsSyntaxNestedFoldable[F[_]: Foldable, G[_], A](fga: F[G[A]]): NestedFoldableOps[F, G, A] =
    new NestedFoldableOps[F, G, A](fga)

  implicit final def catsSyntaxFoldOps[F[_]: Foldable, A](fa: F[A]): FoldableOps[F, A] =
    new FoldableOps[F, A](fa)
}

private[syntax] trait FoldableSyntaxBinCompat0 {
  implicit final def catsSyntaxFoldableOps0[F[_], A](fa: F[A]): FoldableOps0[F, A] =
    new FoldableOps0[F, A](fa)
}

private[syntax] trait FoldableSyntaxBinCompat1 {
  @deprecated("Use methods on Foldable", "2.1.0-RC1")
  final def catsSyntaxFoldableBinCompat0[F[_]](fa: Foldable[F]): FoldableOps1[F] =
    new FoldableOps1(fa)
}

final class NestedFoldableOps[F[_], G[_], A](private val fga: F[G[A]]) extends AnyVal {
  def sequence_(implicit F: Foldable[F], G: Applicative[G]): G[Unit] = F.sequence_(fga)

  /**
   * @see [[Foldable.foldK]].
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val l: List[Set[Int]] = List(Set(1, 2), Set(2, 3), Set(3, 4))
   * scala> l.foldK
   * res0: Set[Int] = Set(1, 2, 3, 4)
   * }}}
   */
  def foldK(implicit F: Foldable[F], G: MonoidK[G]): G[A] = F.foldK(fga)
}

final class FoldableOps[F[_], A](private val fa: F[A]) extends AnyVal {
  def foldl[B](b: B)(f: (B, A) => B)(implicit F: Foldable[F]): B =
    F.foldLeft(fa, b)(f)

  def foldr[B](b: Eval[B])(f: (A, Eval[B]) => Eval[B])(implicit F: Foldable[F]): Eval[B] =
    F.foldRight(fa, b)(f)

  def foldA[G[_], B](implicit F: Foldable[F], ev: A <:< G[B], G: Applicative[G], B: Monoid[B]): G[B] =
    F.foldA[G, B](fa.asInstanceOf[F[G[B]]])

  /**
   * test if `F[A]` contains an `A`, named contains_ to avoid conflict with existing contains which uses universal equality
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val l: List[Int] = List(1, 2, 3, 4)
   * scala> l.contains_(1)
   * res0: Boolean = true
   * scala> l.contains_(5)
   * res1: Boolean = false
   * }}}
   */
  def contains_(v: A)(implicit ev: Eq[A], F: Foldable[F]): Boolean =
    F.exists(fa)(ev.eqv(_, v))

  /**
   * Intercalate with a prefix and a suffix
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val l: List[String] = List("1", "2", "3")
   * scala> l.foldSmash("List(", ",", ")")
   * res0: String = List(1,2,3)
   * }}}
   */
  def foldSmash(prefix: A, delim: A, suffix: A)(implicit A: Monoid[A], F: Foldable[F]): A =
    A.combine(prefix, A.combine(F.intercalate(fa, delim), suffix))

  /**
   * Make a string using `Show`, prefix, delimiter, and suffix.
   *
   * Named as `mkString_` to avoid conflict.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val l: List[Int] = List(1, 2, 3)
   * scala> l.mkString_("L[", ";", "]")
   * res0: String = L[1;2;3]
   * scala> val el: List[Int] = List()
   * scala> el.mkString_("L[", ";", "]")
   * res1: String = L[]
   * }}}
   */
  def mkString_(prefix: String, delim: String, suffix: String)(implicit A: Show[A], F: Foldable[F]): String = {
    val b = F.foldLeft(fa, new StringBuilder) { (builder, a) =>
      builder.append(A.show(a)).append(delim)
    }
    prefix + {
      if (b.isEmpty)
        ""
      else
        b.toString.dropRight(delim.length)
    } + suffix
  }

  /**
   * Monadic version of `collectFirstSome`.
   *
   * If there are no elements, the result is `None`. `collectFirstSomeM` short-circuits,
   * i.e. once a Some element is found, no further effects are produced.
   *
   * For example:
   * {{{
   * scala> import cats.implicits._
   * scala> def parseInt(s: String): Either[String, Int] = Either.catchOnly[NumberFormatException](s.toInt).leftMap(_.getMessage)
   * scala> val keys1 = List("1", "2", "4", "5")
   * scala> val map1 = Map(4 -> "Four", 5 -> "Five")
   * scala> keys1.collectFirstSomeM(parseInt(_) map map1.get)
   * res0: scala.util.Either[String,Option[String]] = Right(Some(Four))
   *
   * scala> val map2 = Map(6 -> "Six", 7 -> "Seven")
   * scala> keys1.collectFirstSomeM(parseInt(_) map map2.get)
   * res1: scala.util.Either[String,Option[String]] = Right(None)
   *
   * scala> val keys2 = List("1", "x", "4", "5")
   * scala> keys2.collectFirstSomeM(parseInt(_) map map1.get)
   * res2: scala.util.Either[String,Option[String]] = Left(For input string: "x")
   *
   * scala> val keys3 = List("1", "2", "4", "x")
   * scala> keys3.collectFirstSomeM(parseInt(_) map map1.get)
   * res3: scala.util.Either[String,Option[String]] = Right(Some(Four))
   * }}}
   */
  def collectFirstSomeM[G[_], B](f: A => G[Option[B]])(implicit F: Foldable[F], G: Monad[G]): G[Option[B]] =
    F.collectFirstSomeM[G, A, B](fa)(f)

  /**
   * Find the first element matching the effectful predicate, if one exists.
   *
   * If there are no elements, the result is `None`. `findM` short-circuits,
   * i.e. once an element is found, no further effects are produced.
   *
   * For example:
   * {{{
   * scala> import cats.implicits._
   * scala> val list = List(1,2,3,4)
   * scala> list.findM(n => (n >= 2).asRight[String])
   * res0: Either[String,Option[Int]] = Right(Some(2))
   *
   * scala> list.findM(n => (n > 4).asRight[String])
   * res1: Either[String,Option[Int]] = Right(None)
   *
   * scala> list.findM(n => Either.cond(n < 3, n >= 2, "error"))
   * res2: Either[String,Option[Int]] = Right(Some(2))
   *
   * scala> list.findM(n => Either.cond(n < 3, false, "error"))
   * res3: Either[String,Option[Int]] = Left(error)
   * }}}
   */
  def findM[G[_]](p: A => G[Boolean])(implicit F: Foldable[F], G: Monad[G]): G[Option[A]] = F.findM[G, A](fa)(p)

  /**
   * Tear down a subset of this structure using a `PartialFunction`.
   *{{{
   * scala> import cats.implicits._
   * scala> val xs = List(1, 2, 3, 4)
   * scala> xs.collectFold { case n if n % 2 == 0 => n }
   * res0: Int = 6
   *}}}
   */
  def collectFold[M](f: PartialFunction[A, M])(implicit F: Foldable[F], M: Monoid[M]): M = F.collectFold[A, M](fa)(f)

  /**
   * Tear down a subset of this structure using a `A => Option[M]`.
   *{{{
   * scala> import cats.implicits._
   * scala> val xs = List(1, 2, 3, 4)
   * scala> def f(n: Int): Option[Int] = if (n % 2 == 0) Some(n) else None
   * scala> xs.collectFoldSome(f)
   * res0: Int = 6
   *}}}
   */
  @deprecated("Use collectFoldSome", "2.1.0-RC1")
  def collectSomeFold[M](f: A => Option[M])(implicit F: Foldable[F], M: Monoid[M]): M = F.collectFoldSome[A, M](fa)(f)
}

final class FoldableOps0[F[_], A](private val fa: F[A]) extends AnyVal {

  /**
   * Make a string using `Show` and delimiter.
   *
   * Named as `mkString_` to avoid conflict.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val l: List[Int] = List(1, 2, 3)
   * scala> l.mkString_(",")
   * res0: String = 1,2,3
   * scala> val el: List[Int] = List()
   * scala> el.mkString_(",")
   * res1: String =
   * }}}
   */
  def mkString_(delim: String)(implicit A: Show[A], F: Foldable[F]): String =
    new FoldableOps(fa).mkString_("", delim, "")

  /**
   * Fold implemented by mapping `A` values into `B` in a context `G` and then
   * combining them using the `MonoidK[G]` instance.
   *
   * {{{
   * scala> import cats._, cats.implicits._
   * scala> val f: Int => Endo[String] = i => (s => s + i)
   * scala> val x: Endo[String] = List(1, 2, 3).foldMapK(f)
   * scala> val a = x("foo")
   * a: String = "foo321"
   * }}}
   * */
  def foldMapK[G[_], B](f: A => G[B])(implicit F: Foldable[F], G: MonoidK[G]): G[B] = F.foldMapK(fa)(f)

  /**
   * Separate this Foldable into a Tuple by an effectful separating function `A => H[B, C]` for some `Bifoldable[H]`
   * Equivalent to `Functor#map` over `Alternative#separate`
   *
   * {{{
   * scala> import cats.implicits._, cats.data.Const
   * scala> val list = List(1,2,3,4)
   * scala> list.partitionBifold(a => (a, "value " + a.toString))
   * res0: (List[Int], List[String]) = (List(1, 2, 3, 4),List(value 1, value 2, value 3, value 4))
   * `Const`'s second parameter is never instantiated, so we can use an impossible type:
   * scala> list.partitionBifold(a => Const[Int, Nothing with Any](a))
   * res1: (List[Int], List[Nothing with Any]) = (List(1, 2, 3, 4),List())
   * }}}
   */
  def partitionBifold[H[_, _], B, C](
    f: A => H[B, C]
  )(implicit A: Alternative[F], F: Foldable[F], H: Bifoldable[H]): (F[B], F[C]) =
    F.partitionBifold[H, A, B, C](fa)(f)(A, H)

  /**
   * Separate this Foldable into a Tuple by an effectful separating function `A => G[H[B, C]]` for some `Bifoldable[H]`
   * Equivalent to `Traverse#traverse` over `Alternative#separate`
   *
   * {{{
   * scala> import cats.implicits._, cats.data.Const
   * scala> val list = List(1,2,3,4)
   * `Const`'s second parameter is never instantiated, so we can use an impossible type:
   * scala> list.partitionBifoldM(a => Option(Const[Int, Nothing with Any](a)))
   * res0: Option[(List[Int], List[Nothing with Any])] = Some((List(1, 2, 3, 4),List()))
   * }}}
   */
  def partitionBifoldM[G[_], H[_, _], B, C](
    f: A => G[H[B, C]]
  )(implicit A: Alternative[F], F: Foldable[F], M: Monad[G], H: Bifoldable[H]): G[(F[B], F[C])] =
    F.partitionBifoldM[G, H, A, B, C](fa)(f)(A, M, H)

  /**
   * Separate this Foldable into a Tuple by an effectful separating function `A => G[Either[B, C]]`
   * Equivalent to `Traverse#traverse` over `Alternative#separate`
   *
   * {{{
   * scala> import cats.implicits._, cats.Eval
   * scala> val list = List(1,2,3,4)
   * scala> val partitioned1 = list.partitionEitherM(a => if (a % 2 == 0) Eval.now(Either.left[String, Int](a.toString)) else Eval.now(Either.right[String, Int](a)))
   * Since `Eval.now` yields a lazy computation, we need to force it to inspect the result:
   * scala> partitioned1.value
   * res0: (List[String], List[Int]) = (List(2, 4),List(1, 3))
   * scala> val partitioned2 = list.partitionEitherM(a => Eval.later(Either.right(a * 4)))
   * scala> partitioned2.value
   * res1: (List[Nothing], List[Int]) = (List(),List(4, 8, 12, 16))
   * }}}
   */
  def partitionEitherM[G[_], B, C](
    f: A => G[Either[B, C]]
  )(implicit A: Alternative[F], F: Foldable[F], M: Monad[G]): G[(F[B], F[C])] =
    F.partitionEitherM[G, A, B, C](fa)(f)(A, M)
}

@deprecated("Use methods on Foldable", "2.1.0-RC1")
final private[syntax] class FoldableOps1[F[_]](private val F: Foldable[F]) extends AnyVal {

  @deprecated("Use partitionBifold on Foldable", "2.1.0-RC1")
  def partitionBifold[H[_, _], A, B, C](fa: F[A])(f: A => H[B, C])(implicit A: Alternative[F],
                                                                   H: Bifoldable[H]): (F[B], F[C]) =
    F.partitionBifold[H, A, B, C](fa)(f)

  @deprecated("Use partitionBifoldM on Foldable", "2.1.0-RC1")
  def partitionBifoldM[G[_], H[_, _], A, B, C](
    fa: F[A]
  )(f: A => G[H[B, C]])(implicit A: Alternative[F], M: Monad[G], H: Bifoldable[H]): G[(F[B], F[C])] =
    F.partitionBifoldM[G, H, A, B, C](fa)(f)

  @deprecated("Use partitionEitherM on Foldable", "2.1.0-RC1")
  def partitionEitherM[G[_], A, B, C](fa: F[A])(f: A => G[Either[B, C]])(implicit A: Alternative[F],
                                                                         M: Monad[G]): G[(F[B], F[C])] =
    F.partitionEitherM[G, A, B, C](fa)(f)
}
package cats
package syntax

import cats.data.{ Xor, Validated, ValidatedNel }

trait OptionSyntax {
  final def none[A]: Option[A] = Option.empty[A]
  implicit final def catsSyntaxOptionId[A](a: A): OptionIdOps[A] = new OptionIdOps(a)
  implicit final def catsSyntaxOption[A](oa: Option[A]): OptionOps[A] = new OptionOps(oa)
}

final class OptionIdOps[A](val a: A) extends AnyVal {
  /**
   * Wrap a value in `Some`.
   *
   * `3.some` is equivalent to `Some(3)`, but the former will have an inferred
   * return type of `Option[Int]` while the latter will have `Some[Int]`.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   * scala> 3.some
   * res0: Option[Int] = Some(3)
   * }}}
   */
  def some: Option[A] = Some(a)
}

final class OptionOps[A](val oa: Option[A]) extends AnyVal {
  /**
   * If the `Option` is a `Some`, return its value in a [[cats.data.Xor.Left]].
   * If the `Option` is `None`, return the provided `B` value in a
   * [[cats.data.Xor.Right]].
   *
   * Example:
   * {{{
   * scala> import cats.data.Xor
   * scala> import cats.implicits._
   *
   * scala> val error1: Option[String] = Some("error!")
   * scala> error1.toLeftXor(3)
   * res0: String Xor Int = Left(error!)
   *
   * scala> val error2: Option[String] = None
   * scala> error2.toLeftXor(3)
   * res1: String Xor Int = Right(3)
   * }}}
   */
  def toLeftXor[B](b: => B): A Xor B = oa.fold[A Xor B](Xor.Right(b))(Xor.Left(_))

  /**
   * If the `Option` is a `Some`, return its value in a [[cats.data.Xor.Right]].
   * If the `Option` is `None`, return the provided `B` value in a
   * [[cats.data.Xor.Left]].
   *
   * Example:
   * {{{
   * scala> import cats.data.Xor
   * scala> import cats.implicits._
   *
   * scala> val result1: Option[Int] = Some(3)
   * scala> result1.toRightXor("error!")
   * res0: String Xor Int = Right(3)
   *
   * scala> val result2: Option[Int] = None
   * scala> result2.toRightXor("error!")
   * res1: String Xor Int = Left(error!)
   * }}}
   */
  def toRightXor[B](b: => B): B Xor A = oa.fold[B Xor A](Xor.Left(b))(Xor.Right(_))

  /**
   * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Invalid]].
   * If the `Option` is `None`, return the provided `B` value in a
   * [[cats.data.Validated.Valid]].
   *
   * Example:
   * {{{
   * scala> import cats.data.Validated
   * scala> import cats.implicits._
   *
   * scala> val error1: Option[String] = Some("error!")
   * scala> error1.toInvalid(3)
   * res0: Validated[String, Int] = Invalid(error!)
   *
   * scala> val error2: Option[String] = None
   * scala> error2.toInvalid(3)
   * res1: Validated[String, Int] = Valid(3)
   * }}}
   */
  def toInvalid[B](b: => B): Validated[A, B] = oa.fold[Validated[A, B]](Validated.Valid(b))(Validated.Invalid(_))

  /**
   * If the `Option` is a `Some`, wrap its value in a [[cats.data.NonEmptyList]]
   * and return it in a [[cats.data.Validated.Invalid]].
   * If the `Option` is `None`, return the provided `B` value in a
   * [[cats.data.Validated.Valid]].
   *
   * Example:
   * {{{
   * scala> import cats.data.ValidatedNel
   * scala> import cats.implicits._
   *
   * scala> val error1: Option[String] = Some("error!")
   * scala> error1.toInvalidNel(3)
   * res0: ValidatedNel[String, Int] = Invalid(OneAnd(error!,List()))
   *
   * scala> val error2: Option[String] = None
   * scala> error2.toInvalidNel(3)
   * res1: ValidatedNel[String, Int] = Valid(3)
   * }}}
   */
  def toInvalidNel[B](b: => B): ValidatedNel[A, B] = oa.fold[ValidatedNel[A, B]](Validated.Valid(b))(Validated.invalidNel(_))

  /**
   * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Valid]].
   * If the `Option` is `None`, return the provided `B` value in a
   * [[cats.data.Validated.Invalid]].
   *
   * Example:
   * {{{
   * scala> import cats.data.Validated
   * scala> import cats.implicits._
   *
   * scala> val result1: Option[Int] = Some(3)
   * scala> result1.toValid("error!")
   * res0: Validated[String, Int] = Valid(3)
   *
   * scala> val result2: Option[Int] = None
   * scala> result2.toValid("error!")
   * res1: Validated[String, Int] = Invalid(error!)
   * }}}
   */
  def toValid[B](b: => B): Validated[B, A] = oa.fold[Validated[B, A]](Validated.Invalid(b))(Validated.Valid(_))

  /**
   * If the `Option` is a `Some`, return its value in a [[cats.data.Validated.Valid]].
   * If the `Option` is `None`, wrap the provided `B` value in a [[cats.data.NonEmptyList]]
   * and return the result in a [[cats.data.Validated.Invalid]].
   *
   * Example:
   * {{{
   * scala> import cats.data.ValidatedNel
   * scala> import cats.implicits._
   *
   * scala> val result1: Option[Int] = Some(3)
   * scala> result1.toValidNel("error!")
   * res0: ValidatedNel[String, Int] = Valid(3)
   *
   * scala> val result2: Option[Int] = None
   * scala> result2.toValidNel("error!")
   * res1: ValidatedNel[String, Int] = Invalid(OneAnd(error!,List()))
   * }}}
   */
  def toValidNel[B](b: => B): ValidatedNel[B, A] = oa.fold[ValidatedNel[B, A]](Validated.invalidNel(b))(Validated.Valid(_))

  /**
   * If the `Option` is a `Some`, return its value. If the `Option` is `None`,
   * return the `empty` value for `Monoid[A]`.
   *
   * Example:
   * {{{
   * scala> import cats.implicits._
   *
   * scala> val someString: Option[String] = Some("hello")
   * scala> someString.orEmpty
   * res0: String = hello
   *
   * scala> val noneString: Option[String] = None
   * scala> noneString.orEmpty
   * res1: String = ""
   * }}}
   */
  def orEmpty(implicit A: Monoid[A]): A = oa.getOrElse(A.empty)
}
package org.fp.studies.applicative.operators

import org.fp.concepts._
import org.fp.resources._
import org.fp.bookmarks._

import scala.language.higherKinds

//
import org.specs2.specification.dsl.mutable.{TextDsl, AutoExamples}

/**
  *
  */
package object dfault {

  object Spec extends org.specs2.mutable.Spec with AutoExamples with TextDsl {

    s"$keyPoint $applyFunctor-s $operator_compose"

    s"$bookmarks: ..."

    eg { /** in [[Scalaz]] */

      import scalaz.std.list._
      import scalaz.std.option._
      import scalaz.syntax.applicative._

      //@todo
      success
    }

    eg { /** in [[Cats]] */

      import cats.instances.list._
      import cats.instances.option._
      import cats.syntax.applicative._

      //@todo
      success
    }

    eg { /** in [[Cats]] */
      /**
        * #hypis https://hyp.is/Beb4XihFEemvIjvPB2-mig/typelevel.org/cats/typeclasses/applicative.html
        */

      import cats.data.Nested
      import cats.Applicative
      import cats.implicits._
      import scala.concurrent.Future
      import scala.reflect.ClassTag

      import scala.concurrent.ExecutionContext.Implicits.global

      val x: Future[Option[Int]] = Future.successful(Some(5))
      val y: Future[Option[Char]] = Future.successful(Some('a'))

      val composed = Applicative[Future].compose[Option].map2(x, y)(_ + _)
      // composed: scala.concurrent.Future[Option[Int]] = Future(<not completed>)

      composed must beAnInstanceOf(implicitly[ClassTag[Future[Option[Int]]]])

      val nested = Applicative[Nested[Future, Option, ?]].map2(Nested(x), Nested(y))(_ + _)
      // nested: cats.data.Nested[scala.concurrent.Future,Option,Int] = Nested(Future(<not completed>))
      nested must beAnInstanceOf(implicitly[ClassTag[Nested[Future, Option, Int]]]) //#todo use '?'

      success
    }
  }
}
import scala.xml._
import scala.xml.Utility.trim
import akka.actor.{Actor, ActorLogging, Props}
import akka.util.Timeout
import scala.concurrent.Future
import scala.util.Try
import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import akka.Done
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.model.{HttpRequest, StatusCodes}
import akka.http.scaladsl.unmarshalling.Unmarshal
import scala.concurrent.duration.Duration
import scala.concurrent.duration.MILLISECONDS
import scala.io.StdIn
import scala.concurrent.{Await, Future}
import org.json4s._
import org.json4s.jackson.JsonMethods._
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer
import scala.io.StdIn
import akka.http.scaladsl.server.Route
import akka.actor._
import akka.pattern.{ask, pipe}
import scala.collection._
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.Random

object Main extends App{
  implicit val system = ActorSystem("my-system")
  implicit val materializer = ActorMaterializer()
  implicit val executionContext = system.dispatcher
  val cats: mutable.Map[String, (Boolean, String, Int)] = mutable.Map.empty

  def xmlMain(str: String) = trim {
    <Name> <ID> "Вы на ферме по разведению котиков. Заберите котика домой!" </ID> </Name>
  }.toString
  val route = pathPrefix("main") {
    get {
      complete(xmlMain("main"))
      }
  } ~ pathPrefix("add") { add(cats)
  } ~ pathPrefix("take") { take(cats)
  } ~ pathPrefix("mate") { mate(cats)
  }

  val bindingFuture = Http().bindAndHandle(route, "localhost", 8080)
  println(s"Server online at http://localhost:8080/\nPress RETURN to stop...")
  StdIn.readLine()
  bindingFuture
    .flatMap(_.unbind())
    .onComplete(_ => system.terminate())
}

case class Cat(name: String, isMale: Boolean, breed: String, age: Int)

object add {
  import Main.system
  def xmlAdd() =
    trim { <Name> <ID> "Котик принят на ферму" </ID> </Name>}.toString

  def apply(cats: mutable.Map[String, (Boolean, String, Int)]): Route =
    path(Remaining){word: String =>
    val name : String = word.split("_")(0)
    val isMale : Boolean = word.split("_")(1).toBoolean
    val breed : String = word.split("_")(2)
    val age : Int = word.split("_")(3).toInt
    cats += name -> (isMale, breed, age)
    complete(xmlAdd())}
}

object take {
  import Main.system
  def xmlTake(name: String) =
    trim {<Name><ID> "Вы забрали котика {name}"</ID></Name>}.toString
  def xmlNotTake(name: String) =
    trim {<Name><ID> "Котика {name} уже забрали"</ID></Name>}.toString
  def apply(cats: mutable.Map[String, (Boolean, String, Int)]): Route =
    path(Remaining){name: String =>
    if (cats.get(name) != None) {cats -= name
    complete(xmlTake(name))}
    else complete(xmlNotTake(name))
  }
}

object mate {
  import Main.system
  def xmlBornGirl(name: String, breed: String) =
    trim { <Name> <ID> "У вас девочка! Родился новый котик {name} породы {breed}" </ID> </Name> }.toString
  def xmlBornBoy(name: String, breed: String) =
    trim { <Name> <ID> "У вас мальчик! Родился новый котик {name} породы {breed}" </ID> </Name> }.toString
  def xmlNotLove() =
    trim { <Name> <ID> "Такой пары не существует" </ID> </Name> }.toString
  def xmlChildFree() =
    trim { <Name> <ID> "У такой пары не может быть потомства" </ID> </Name> }.toString

  def apply(cats: mutable.Map[String, (Boolean, String, Int)]): Route =
    path(Remaining){word: String =>
    val name1 : String = word.split("_")(0)
    val name2 : String = word.split("_")(1)
    if (cats.get(name1) == None || cats.get(name2) == None) complete(xmlNotLove())
    else if (cats(name1)._1 == cats(name2)._2) complete(xmlChildFree())
      else {
        var isMale = true
        if (Random.nextInt(1) != 1) isMale = false
        var breed = cats(name2)._2
        if (Random.nextInt(1) == 1) breed = cats(name1)._2
        val name: String = name1+name2
        cats += name -> (isMale, breed, 0)
        if (isMale) complete(xmlBornBoy(name, breed))
        else complete(xmlBornGirl(name, breed))
      }

  }
}
package cats.syntax

import scala.collection.immutable.{SortedMap, SortedSet}
import cats.data.NonEmptySet
import cats.Order

trait SetSyntax {
  implicit final def catsSyntaxSet[A](se: SortedSet[A]): SetOps[A] = new SetOps(se)
}

final class SetOps[A](private val se: SortedSet[A]) extends AnyVal {

  /**
   * Returns an Option of NonEmptySet from a SortedSet
   *
   * Example:
   * {{{
   * scala> import scala.collection.immutable.SortedSet
   * scala> import cats.data.NonEmptySet
   * scala> import cats.implicits._
   *
   * scala> val result1: SortedSet[Int] = SortedSet(1, 2)
   * scala> result1.toNes
   * res0: Option[NonEmptySet[Int]] = Some(TreeSet(1, 2))
   *
   * scala> val result2: SortedSet[Int] = SortedSet.empty[Int]
   * scala> result2.toNes
   * res1: Option[NonEmptySet[Int]] = None
   * }}}
   */
  def toNes: Option[NonEmptySet[A]] = NonEmptySet.fromSet(se)

  /**
   * Groups elements inside this `SortedSet` according to the `Order` of the keys
   * produced by the given mapping function.
   *
   * {{{
   * scala> import cats.data.NonEmptySet
   * scala> import scala.collection.immutable.{SortedMap, SortedSet}
   * scala> import cats.implicits._
   *
   * scala> val sortedSet = SortedSet(12, -2, 3, -5)
   *
   * scala> sortedSet.groupByNes(_ >= 0)
   * res0: SortedMap[Boolean, NonEmptySet[Int]] = Map(false -> TreeSet(-5, -2), true -> TreeSet(3, 12))
   * }}}
   */
  def groupByNes[B](f: A => B)(implicit B: Order[B]): SortedMap[B, NonEmptySet[A]] = {
    implicit val ordering = B.toOrdering
    toNes.fold(SortedMap.empty[B, NonEmptySet[A]])(_.groupBy(f).toSortedMap)
  }
}
